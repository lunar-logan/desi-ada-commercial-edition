Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    NUMBERSIGN
    QUOTE
    VLINE
    DELIMITER
    INTERFACE
    SYNCHRONIZED
    SOME
    TRUE
    COMMENT
    LCB
    RSQB
    LSQB
    FALSE
    RCB
    OVERRIDING

Grammar

Rule 0     S' -> goal_symbol
Rule 1     goal_symbol -> compilation
Rule 2     pragma -> PRAGMA IDENTIFIER SEMICOLON
Rule 3     pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
Rule 4     pragma_arg_s -> pragma_arg
Rule 5     pragma_arg_s -> pragma_arg_s COMMA pragma_arg
Rule 6     pragma_arg -> expression
Rule 7     pragma_arg -> simple_name ARROW expression
Rule 8     pragma_s -> <empty>
Rule 9     pragma_s -> pragma_s pragma
Rule 10    decl -> object_decl
Rule 11    decl -> number_decl
Rule 12    decl -> type_decl
Rule 13    decl -> subtype_decl
Rule 14    decl -> subprog_decl
Rule 15    decl -> pkg_decl
Rule 16    decl -> task_decl
Rule 17    decl -> prot_decl
Rule 18    decl -> exception_decl
Rule 19    decl -> rename_decl
Rule 20    decl -> generic_decl
Rule 21    decl -> body_stub
Rule 22    decl -> error SEMICOLON
Rule 23    object_decl -> def_id_s COLON object_qualifier_opt object_subtype_def init_opt SEMICOLON
Rule 24    def_id_s -> def_id
Rule 25    def_id_s -> def_id_s COMMA def_id
Rule 26    def_id -> IDENTIFIER
Rule 27    object_qualifier_opt -> <empty>
Rule 28    object_qualifier_opt -> ALIASED
Rule 29    object_qualifier_opt -> CONSTANT
Rule 30    object_qualifier_opt -> ALIASED CONSTANT
Rule 31    object_subtype_def -> subtype_ind
Rule 32    object_subtype_def -> array_type
Rule 33    init_opt -> <empty>
Rule 34    init_opt -> IS_ASSIGNED expression
Rule 35    number_decl -> def_id_s COLON CONSTANT IS_ASSIGNED expression SEMICOLON
Rule 36    type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion SEMICOLON
Rule 37    discrim_part_opt -> <empty>
Rule 38    discrim_part_opt -> discrim_part
Rule 39    discrim_part_opt -> LPAREN BOX RPAREN
Rule 40    type_completion -> <empty>
Rule 41    type_completion -> IS type_def
Rule 42    type_def -> enumeration_type
Rule 43    type_def -> integer_type
Rule 44    type_def -> real_type
Rule 45    type_def -> array_type
Rule 46    type_def -> record_type
Rule 47    type_def -> access_type
Rule 48    subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind SEMICOLON
Rule 49    subtype_ind -> name constraint
Rule 50    subtype_ind -> name
Rule 51    constraint -> range_constraint
Rule 52    constraint -> decimal_digits_constraint
Rule 53    decimal_digits_constraint -> DIGITS expression range_constr_opt
Rule 54    derived_type -> NEW subtype_ind
Rule 55    derived_type -> NEW subtype_ind WITH PRIVATE
Rule 56    derived_type -> NEW subtype_ind WITH record_def
Rule 57    derived_type -> ABSTRACT NEW subtype_ind WITH PRIVATE
Rule 58    derived_type -> ABSTRACT NEW subtype_ind WITH record_def
Rule 59    range_constraint -> RANGE range
Rule 60    range -> simple_expression DOUBLEDOT simple_expression
Rule 61    range -> name TICK RANGE
Rule 62    range -> name TICK RANGE LPAREN expression RPAREN
Rule 63    enumeration_type -> LPAREN enum_id_s RPAREN
Rule 64    enum_id_s -> enum_id
Rule 65    enum_id_s -> enum_id_s COMMA enum_id
Rule 66    enum_id -> IDENTIFIER
Rule 67    enum_id -> CHARACTER
Rule 68    integer_type -> range_spec
Rule 69    integer_type -> MOD expression
Rule 70    range_spec -> range_constraint
Rule 71    range_spec_opt -> <empty>
Rule 72    range_spec_opt -> range_spec
Rule 73    real_type -> float_type
Rule 74    real_type -> fixed_type
Rule 75    float_type -> DIGITS expression range_spec_opt
Rule 76    fixed_type -> DELTA expression range_spec
Rule 77    fixed_type -> DELTA expression DIGITS expression range_spec_opt
Rule 78    array_type -> unconstr_array_type
Rule 79    array_type -> constr_array_type
Rule 80    unconstr_array_type -> ARRAY LPAREN index_s RPAREN OF component_subtype_def
Rule 81    constr_array_type -> ARRAY iter_index_constraint OF component_subtype_def
Rule 82    component_subtype_def -> aliased_opt subtype_ind
Rule 83    aliased_opt -> <empty>
Rule 84    aliased_opt -> ALIASED
Rule 85    index_s -> index
Rule 86    index_s -> index_s COMMA index
Rule 87    index -> name RANGE BOX
Rule 88    iter_index_constraint -> LPAREN iter_discrete_range_s RPAREN
Rule 89    iter_discrete_range_s -> discrete_range
Rule 90    iter_discrete_range_s -> iter_discrete_range_s COMMA discrete_range
Rule 91    discrete_range -> name range_constr_opt
Rule 92    discrete_range -> range
Rule 93    range_constr_opt -> <empty>
Rule 94    range_constr_opt -> range_constraint
Rule 95    record_type -> tagged_opt limited_opt record_def
Rule 96    record_def -> RECORD comp_list END RECORD
Rule 97    record_def -> NULL RECORD
Rule 98    tagged_opt -> <empty>
Rule 99    tagged_opt -> TAGGED
Rule 100   tagged_opt -> ABSTRACT TAGGED
Rule 101   comp_list -> comp_decl_s variant_part_opt
Rule 102   comp_list -> variant_part
Rule 103   comp_list -> NULL SEMICOLON
Rule 104   comp_decl_s -> comp_decl
Rule 105   comp_decl_s -> comp_decl_s comp_decl
Rule 106   variant_part_opt -> <empty>
Rule 107   variant_part_opt -> variant_part
Rule 108   comp_decl -> def_id_s COLON component_subtype_def init_opt SEMICOLON
Rule 109   comp_decl -> error SEMICOLON
Rule 110   discrim_part -> LPAREN discrim_spec_s RPAREN
Rule 111   discrim_spec_s -> discrim_spec
Rule 112   discrim_spec_s -> discrim_spec_s SEMICOLON discrim_spec
Rule 113   discrim_spec -> def_id_s COLON access_opt mark init_opt
Rule 114   discrim_spec -> error
Rule 115   access_opt -> <empty>
Rule 116   access_opt -> ACCESS
Rule 117   variant_part -> CASE simple_name IS variant_s END CASE SEMICOLON
Rule 118   variant_s -> variant
Rule 119   variant_s -> variant_s variant
Rule 120   variant -> WHEN choice_s ARROW comp_list
Rule 121   choice_s -> choice
Rule 122   choice_s -> choice_s | choice
Rule 123   choice -> expression
Rule 124   choice -> discrete_with_range
Rule 125   choice -> OTHERS
Rule 126   discrete_with_range -> name range_constraint
Rule 127   discrete_with_range -> range
Rule 128   access_type -> ACCESS subtype_ind
Rule 129   access_type -> ACCESS CONSTANT subtype_ind
Rule 130   access_type -> ACCESS ALL subtype_ind
Rule 131   access_type -> ACCESS prot_opt PROCEDURE formal_part_opt
Rule 132   access_type -> ACCESS prot_opt FUNCTION formal_part_opt RETURN mark
Rule 133   prot_opt -> <empty>
Rule 134   prot_opt -> PROTECTED
Rule 135   decl_part -> <empty>
Rule 136   decl_part -> decl_item_or_body_s1
Rule 137   decl_item_s -> <empty>
Rule 138   decl_item_s -> decl_item_s1
Rule 139   decl_item_s1 -> decl_item
Rule 140   decl_item_s1 -> decl_item_s1 decl_item
Rule 141   decl_item -> decl
Rule 142   decl_item -> use_clause
Rule 143   decl_item -> rep_spec
Rule 144   decl_item -> pragma
Rule 145   decl_item_or_body_s1 -> decl_item_or_body
Rule 146   decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body
Rule 147   decl_item_or_body -> body
Rule 148   decl_item_or_body -> decl_item
Rule 149   body -> subprog_body
Rule 150   body -> pkg_body
Rule 151   body -> task_body
Rule 152   body -> prot_body
Rule 153   name -> simple_name
Rule 154   name -> indexed_comp
Rule 155   name -> selected_comp
Rule 156   name -> attribute
Rule 157   name -> operator_symbol
Rule 158   mark -> simple_name
Rule 159   mark -> mark TICK attribute_id
Rule 160   mark -> mark DOT simple_name
Rule 161   simple_name -> IDENTIFIER
Rule 162   compound_name -> simple_name
Rule 163   compound_name -> compound_name DOT simple_name
Rule 164   c_name_list -> compound_name
Rule 165   c_name_list -> c_name_list COMMA compound_name
Rule 166   used_char -> CHARACTER
Rule 167   operator_symbol -> STRING
Rule 168   indexed_comp -> name LPAREN value_s RPAREN
Rule 169   value_s -> value
Rule 170   value_s -> value_s COMMA value
Rule 171   value -> expression
Rule 172   value -> comp_assoc
Rule 173   value -> discrete_with_range
Rule 174   value -> error
Rule 175   selected_comp -> name DOT simple_name
Rule 176   selected_comp -> name DOT used_char
Rule 177   selected_comp -> name DOT operator_symbol
Rule 178   selected_comp -> name DOT ALL
Rule 179   attribute -> name TICK attribute_id
Rule 180   attribute_id -> IDENTIFIER
Rule 181   attribute_id -> DIGITS
Rule 182   attribute_id -> DELTA
Rule 183   attribute_id -> ACCESS
Rule 184   literal -> NUMBER
Rule 185   literal -> used_char
Rule 186   literal -> NULL
Rule 187   aggregate -> LPAREN comp_assoc RPAREN
Rule 188   aggregate -> LPAREN value_s_2 RPAREN
Rule 189   aggregate -> LPAREN expression WITH value_s RPAREN
Rule 190   aggregate -> LPAREN expression WITH NULL RECORD RPAREN
Rule 191   aggregate -> LPAREN NULL RECORD RPAREN
Rule 192   value_s_2 -> value COMMA value
Rule 193   value_s_2 -> value_s_2 COMMA value
Rule 194   comp_assoc -> choice_s ARROW expression
Rule 195   expression -> relation
Rule 196   expression -> expression logical relation
Rule 197   expression -> expression short_circuit relation
Rule 198   logical -> AND
Rule 199   logical -> OR
Rule 200   logical -> XOR
Rule 201   short_circuit -> AND THEN
Rule 202   short_circuit -> OR ELSE
Rule 203   relation -> simple_expression
Rule 204   relation -> simple_expression relational simple_expression
Rule 205   relation -> simple_expression membership range
Rule 206   relation -> simple_expression membership name
Rule 207   relational -> EQ
Rule 208   relational -> NE
Rule 209   relational -> LT
Rule 210   relational -> LE
Rule 211   relational -> GT
Rule 212   relational -> GE
Rule 213   membership -> IN
Rule 214   membership -> NOT IN
Rule 215   simple_expression -> unary term
Rule 216   simple_expression -> term
Rule 217   simple_expression -> simple_expression adding term
Rule 218   unary -> PLUS
Rule 219   unary -> MINUS
Rule 220   adding -> PLUS
Rule 221   adding -> MINUS
Rule 222   adding -> AMPERSAND
Rule 223   term -> factor
Rule 224   term -> term multiplying factor
Rule 225   multiplying -> TIMES
Rule 226   multiplying -> DIVIDE
Rule 227   multiplying -> MOD
Rule 228   multiplying -> REM
Rule 229   factor -> primary
Rule 230   factor -> NOT primary
Rule 231   factor -> ABS primary
Rule 232   factor -> primary POW primary
Rule 233   primary -> literal
Rule 234   primary -> allocator
Rule 235   primary -> qualified
Rule 236   primary -> parenthesized_primary
Rule 237   primary -> name
Rule 238   parenthesized_primary -> aggregate
Rule 239   parenthesized_primary -> LPAREN expression RPAREN
Rule 240   qualified -> name TICK parenthesized_primary
Rule 241   allocator -> NEW name
Rule 242   allocator -> NEW qualified
Rule 243   statement_s -> statement
Rule 244   statement_s -> statement_s statement
Rule 245   statement -> unlabeled
Rule 246   statement -> label statement
Rule 247   unlabeled -> simple_stmt
Rule 248   unlabeled -> compound_stmt
Rule 249   unlabeled -> pragma
Rule 250   simple_stmt -> NULL_stmt
Rule 251   simple_stmt -> assign_stmt
Rule 252   simple_stmt -> exit_stmt
Rule 253   simple_stmt -> return_stmt
Rule 254   simple_stmt -> goto_stmt
Rule 255   simple_stmt -> procedure_call
Rule 256   simple_stmt -> delay_stmt
Rule 257   simple_stmt -> abort_stmt
Rule 258   simple_stmt -> raise_stmt
Rule 259   simple_stmt -> code_stmt
Rule 260   simple_stmt -> requeue_stmt
Rule 261   simple_stmt -> error SEMICOLON
Rule 262   compound_stmt -> if_stmt
Rule 263   compound_stmt -> case_stmt
Rule 264   compound_stmt -> loop_stmt
Rule 265   compound_stmt -> block
Rule 266   compound_stmt -> accept_stmt
Rule 267   compound_stmt -> select_stmt
Rule 268   label -> LLB IDENTIFIER RLB
Rule 269   NULL_stmt -> NULL SEMICOLON
Rule 270   assign_stmt -> name IS_ASSIGNED expression SEMICOLON
Rule 271   if_stmt -> IF cond_clause else_opt END IF SEMICOLON
Rule 272   cond_clause -> cond_part statement_s
Rule 273   cond_part -> condition THEN
Rule 274   condition -> expression
Rule 275   else_opt -> <empty>
Rule 276   else_opt -> ELSE statement_s
Rule 277   else_opt -> ELSIF cond_clause else_opt
Rule 278   case_stmt -> case_hdr alternative_s END CASE SEMICOLON
Rule 279   case_hdr -> CASE expression IS
Rule 280   alternative_s -> <empty>
Rule 281   alternative_s -> alternative_s alternative
Rule 282   alternative -> WHEN choice_s ARROW statement_s
Rule 283   loop_stmt -> label_opt iteration basic_loop id_opt SEMICOLON
Rule 284   label_opt -> <empty>
Rule 285   label_opt -> IDENTIFIER COLON
Rule 286   iter_part -> FOR IDENTIFIER IN
Rule 287   iteration -> <empty>
Rule 288   iteration -> WHILE condition
Rule 289   iteration -> iter_part reverse_opt discrete_range
Rule 290   reverse_opt -> <empty>
Rule 291   reverse_opt -> REVERSE
Rule 292   basic_loop -> LOOP statement_s END LOOP
Rule 293   id_opt -> <empty>
Rule 294   id_opt -> designator
Rule 295   block -> label_opt block_decl block_body END id_opt SEMICOLON
Rule 296   block_decl -> <empty>
Rule 297   block_decl -> DECLARE decl_part
Rule 298   block_body -> BEGIN handled_stmt_s
Rule 299   handled_stmt_s -> statement_s except_handler_part_opt
Rule 300   except_handler_part_opt -> <empty>
Rule 301   except_handler_part_opt -> except_handler_part
Rule 302   exit_stmt -> EXIT name_opt when_opt SEMICOLON
Rule 303   name_opt -> empty
Rule 304   name_opt -> name
Rule 305   when_opt -> <empty>
Rule 306   when_opt -> WHEN condition
Rule 307   return_stmt -> RETURN SEMICOLON
Rule 308   return_stmt -> RETURN expression SEMICOLON
Rule 309   goto_stmt -> GOTO name SEMICOLON
Rule 310   subprog_decl -> subprog_spec SEMICOLON
Rule 311   subprog_decl -> generic_subp_inst SEMICOLON
Rule 312   subprog_decl -> subprog_spec_is_push ABSTRACT SEMICOLON
Rule 313   subprog_spec -> PROCEDURE compound_name formal_part_opt
Rule 314   subprog_spec -> FUNCTION designator formal_part_opt RETURN name
Rule 315   subprog_spec -> FUNCTION designator
Rule 316   designator -> compound_name
Rule 317   designator -> STRING
Rule 318   formal_part_opt -> <empty>
Rule 319   formal_part_opt -> formal_part
Rule 320   formal_part -> LPAREN param_s RPAREN
Rule 321   param_s -> param
Rule 322   param_s -> param_s SEMICOLON param
Rule 323   param -> def_id_s COLON mode mark init_opt
Rule 324   param -> error
Rule 325   mode -> <empty>
Rule 326   mode -> IN
Rule 327   mode -> OUT
Rule 328   mode -> IN OUT
Rule 329   mode -> ACCESS
Rule 330   subprog_spec_is_push -> subprog_spec IS
Rule 331   subprog_body -> subprog_spec_is_push decl_part block_body END id_opt SEMICOLON
Rule 332   procedure_call -> name SEMICOLON
Rule 333   pkg_decl -> pkg_spec SEMICOLON
Rule 334   pkg_decl -> generic_pkg_inst SEMICOLON
Rule 335   pkg_spec -> PACKAGE compound_name IS decl_item_s private_part END c_id_opt
Rule 336   private_part -> <empty>
Rule 337   private_part -> PRIVATE decl_item_s
Rule 338   c_id_opt -> <empty>
Rule 339   c_id_opt -> compound_name
Rule 340   pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt SEMICOLON
Rule 341   body_opt -> <empty>
Rule 342   body_opt -> block_body
Rule 343   private_type -> tagged_opt limited_opt PRIVATE
Rule 344   limited_opt -> <empty>
Rule 345   limited_opt -> LIMITED
Rule 346   use_clause -> USE name_s SEMICOLON
Rule 347   use_clause -> USE TYPE name_s SEMICOLON
Rule 348   name_s -> name
Rule 349   name_s -> name_s COMMA name
Rule 350   rename_decl -> def_id_s COLON object_qualifier_opt subtype_ind renames SEMICOLON
Rule 351   rename_decl -> def_id_s COLON EXCEPTION renames SEMICOLON
Rule 352   rename_decl -> rename_unit
Rule 353   rename_unit -> PACKAGE compound_name renames SEMICOLON
Rule 354   rename_unit -> subprog_spec renames SEMICOLON
Rule 355   rename_unit -> generic_formal_part PACKAGE compound_name renames SEMICOLON
Rule 356   rename_unit -> generic_formal_part subprog_spec renames SEMICOLON
Rule 357   renames -> RENAMES name
Rule 358   task_decl -> task_spec SEMICOLON
Rule 359   task_spec -> TASK simple_name task_def
Rule 360   task_spec -> TASK TYPE simple_name discrim_part_opt task_def
Rule 361   task_def -> <empty>
Rule 362   task_def -> IS entry_decl_s rep_spec_s task_private_opt END id_opt
Rule 363   task_private_opt -> <empty>
Rule 364   task_private_opt -> PRIVATE entry_decl_s rep_spec_s
Rule 365   task_body -> TASK BODY simple_name IS decl_part block_body END id_opt SEMICOLON
Rule 366   prot_decl -> prot_spec SEMICOLON
Rule 367   prot_spec -> PROTECTED IDENTIFIER prot_def
Rule 368   prot_spec -> PROTECTED TYPE simple_name discrim_part_opt prot_def
Rule 369   prot_def -> IS prot_op_decl_s prot_private_opt END id_opt
Rule 370   prot_private_opt -> <empty>
Rule 371   prot_private_opt -> PRIVATE prot_elem_decl_s
Rule 372   prot_op_decl_s -> <empty>
Rule 373   prot_op_decl_s -> prot_op_decl_s prot_op_decl
Rule 374   prot_op_decl -> entry_decl
Rule 375   prot_op_decl -> subprog_spec SEMICOLON
Rule 376   prot_op_decl -> rep_spec
Rule 377   prot_op_decl -> pragma
Rule 378   prot_elem_decl_s -> <empty>
Rule 379   prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl
Rule 380   prot_elem_decl -> prot_op_decl
Rule 381   prot_elem_decl -> comp_decl
Rule 382   prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt SEMICOLON
Rule 383   prot_op_body_s -> pragma_s
Rule 384   prot_op_body_s -> prot_op_body_s prot_op_body pragma_s
Rule 385   prot_op_body -> entry_body
Rule 386   prot_op_body -> subprog_body
Rule 387   prot_op_body -> subprog_spec SEMICOLON
Rule 388   entry_decl_s -> pragma_s
Rule 389   entry_decl_s -> entry_decl_s entry_decl pragma_s
Rule 390   entry_decl -> ENTRY IDENTIFIER formal_part_opt SEMICOLON
Rule 391   entry_decl -> ENTRY IDENTIFIER LPAREN discrete_range RPAREN formal_part_opt SEMICOLON
Rule 392   entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN condition entry_body_part
Rule 393   entry_body -> ENTRY IDENTIFIER LPAREN iter_part discrete_range RPAREN formal_part_opt WHEN condition entry_body_part
Rule 394   entry_body_part -> SEMICOLON
Rule 395   entry_body_part -> IS decl_part block_body END id_opt SEMICOLON
Rule 396   rep_spec_s -> <empty>
Rule 397   rep_spec_s -> rep_spec_s rep_spec pragma_s
Rule 398   entry_call -> procedure_call
Rule 399   accept_stmt -> accept_hdr SEMICOLON
Rule 400   accept_stmt -> accept_hdr DO handled_stmt_s END id_opt SEMICOLON
Rule 401   accept_hdr -> ACCEPT entry_name formal_part_opt
Rule 402   entry_name -> simple_name
Rule 403   entry_name -> entry_name LPAREN expression RPAREN
Rule 404   delay_stmt -> DELAY expression SEMICOLON
Rule 405   delay_stmt -> DELAY UNTIL expression SEMICOLON
Rule 406   select_stmt -> select_wait
Rule 407   select_stmt -> async_select
Rule 408   select_stmt -> timed_entry_call
Rule 409   select_stmt -> cond_entry_call
Rule 410   select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON
Rule 411   guarded_select_alt -> select_alt
Rule 412   guarded_select_alt -> WHEN condition ARROW select_alt
Rule 413   or_select -> <empty>
Rule 414   or_select -> or_select OR guarded_select_alt
Rule 415   select_alt -> accept_stmt stmts_opt
Rule 416   select_alt -> delay_stmt stmts_opt
Rule 417   select_alt -> TERMINATE SEMICOLON
Rule 418   delay_or_entry_alt -> delay_stmt stmts_opt
Rule 419   delay_or_entry_alt -> entry_call stmts_opt
Rule 420   async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON
Rule 421   timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON
Rule 422   cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON
Rule 423   stmts_opt -> <empty>
Rule 424   stmts_opt -> statement_s
Rule 425   abort_stmt -> ABORT name_s SEMICOLON
Rule 426   compilation -> <empty>
Rule 427   compilation -> compilation comp_unit
Rule 428   compilation -> pragma pragma_s
Rule 429   comp_unit -> context_spec private_opt unit
Rule 430   comp_unit -> private_opt unit
Rule 431   private_opt -> <empty>
Rule 432   private_opt -> PRIVATE
Rule 433   context_spec -> with_clause use_clause_opt
Rule 434   context_spec -> context_spec with_clause use_clause_opt
Rule 435   context_spec -> context_spec pragma
Rule 436   with_clause -> WITH c_name_list SEMICOLON
Rule 437   use_clause_opt -> <empty>
Rule 438   use_clause_opt -> use_clause_opt use_clause
Rule 439   unit -> pkg_decl
Rule 440   unit -> pkg_body
Rule 441   unit -> subprog_decl
Rule 442   unit -> subprog_body
Rule 443   unit -> subunit
Rule 444   unit -> generic_decl
Rule 445   unit -> rename_unit
Rule 446   subunit -> SEPARATE LPAREN compound_name RPAREN subunit_body
Rule 447   subunit_body -> subprog_body
Rule 448   subunit_body -> pkg_body
Rule 449   subunit_body -> task_body
Rule 450   subunit_body -> prot_body
Rule 451   body_stub -> TASK BODY simple_name IS SEPARATE SEMICOLON
Rule 452   body_stub -> PACKAGE BODY compound_name IS SEPARATE SEMICOLON
Rule 453   body_stub -> subprog_spec IS SEPARATE SEMICOLON
Rule 454   body_stub -> PROTECTED BODY simple_name IS SEPARATE SEMICOLON
Rule 455   exception_decl -> def_id_s COLON EXCEPTION SEMICOLON
Rule 456   except_handler_part -> EXCEPTION exception_handler
Rule 457   except_handler_part -> except_handler_part exception_handler
Rule 458   exception_handler -> WHEN except_choice_s ARROW statement_s
Rule 459   exception_handler -> WHEN IDENTIFIER COLON except_choice_s ARROW statement_s
Rule 460   except_choice_s -> except_choice
Rule 461   except_choice_s -> except_choice_s | except_choice
Rule 462   except_choice -> name
Rule 463   except_choice -> OTHERS
Rule 464   raise_stmt -> RAISE name_opt SEMICOLON
Rule 465   requeue_stmt -> REQUEUE name SEMICOLON
Rule 466   requeue_stmt -> REQUEUE name WITH ABORT SEMICOLON
Rule 467   generic_decl -> generic_formal_part subprog_spec SEMICOLON
Rule 468   generic_decl -> generic_formal_part pkg_spec SEMICOLON
Rule 469   generic_formal_part -> GENERIC
Rule 470   generic_formal_part -> generic_formal_part generic_formal
Rule 471   generic_formal -> param SEMICOLON
Rule 472   generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def SEMICOLON
Rule 473   generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default SEMICOLON
Rule 474   generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default SEMICOLON
Rule 475   generic_formal -> WITH PACKAGE simple_name IS NEW name LPAREN BOX RPAREN SEMICOLON
Rule 476   generic_formal -> WITH PACKAGE simple_name IS NEW name SEMICOLON
Rule 477   generic_formal -> use_clause
Rule 478   generic_discrim_part_opt -> <empty>
Rule 479   generic_discrim_part_opt -> discrim_part
Rule 480   generic_discrim_part_opt -> LPAREN BOX RPAREN
Rule 481   subp_default -> <empty>
Rule 482   subp_default -> IS name
Rule 483   subp_default -> IS BOX
Rule 484   generic_type_def -> LPAREN BOX RPAREN
Rule 485   generic_type_def -> RANGE BOX
Rule 486   generic_type_def -> MOD BOX
Rule 487   generic_type_def -> DELTA BOX
Rule 488   generic_type_def -> DELTA BOX DIGITS BOX
Rule 489   generic_type_def -> DIGITS BOX
Rule 490   generic_type_def -> array_type
Rule 491   generic_type_def -> access_type
Rule 492   generic_type_def -> private_type
Rule 493   generic_type_def -> generic_derived_type
Rule 494   generic_derived_type -> NEW subtype_ind
Rule 495   generic_derived_type -> NEW subtype_ind WITH PRIVATE
Rule 496   generic_derived_type -> ABSTRACT NEW subtype_ind WITH PRIVATE
Rule 497   generic_subp_inst -> subprog_spec IS generic_inst
Rule 498   generic_pkg_inst -> PACKAGE compound_name IS generic_inst
Rule 499   generic_inst -> NEW name
Rule 500   rep_spec -> attrib_def
Rule 501   rep_spec -> record_type_spec
Rule 502   rep_spec -> address_spec
Rule 503   attrib_def -> FOR mark USE expression SEMICOLON
Rule 504   record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD SEMICOLON
Rule 505   align_opt -> <empty>
Rule 506   align_opt -> AT MOD expression SEMICOLON
Rule 507   comp_loc_s -> <empty>
Rule 508   comp_loc_s -> comp_loc_s mark AT expression RANGE range SEMICOLON
Rule 509   address_spec -> FOR mark USE AT expression SEMICOLON
Rule 510   code_stmt -> qualified SEMICOLON
Rule 511   empty -> <empty>

Terminals, with rules where they appear

ABORT                : 420 425 466
ABS                  : 231
ABSTRACT             : 57 58 100 312 496
ACCEPT               : 401
ACCESS               : 116 128 129 130 131 132 183 329
ALIASED              : 28 30 84
ALL                  : 130 178
AMPERSAND            : 222
AND                  : 198 201
ARRAY                : 80 81
ARROW                : 7 120 194 282 412 458 459
AT                   : 506 508 509
BEGIN                : 298
BODY                 : 340 365 382 451 452 454
BOX                  : 39 87 475 480 483 484 485 486 487 488 488 489
CASE                 : 117 117 278 279
CHARACTER            : 67 166
COLON                : 23 35 108 113 285 323 350 351 455 459
COMMA                : 5 25 65 86 90 165 170 192 193 349
COMMENT              : 
CONSTANT             : 29 30 35 129
DECLARE              : 297
DELAY                : 404 405
DELIMITER            : 
DELTA                : 76 77 182 487 488
DIGITS               : 53 75 77 181 488 489
DIVIDE               : 226
DO                   : 400
DOT                  : 160 163 175 176 177 178
DOUBLEDOT            : 60
ELSE                 : 202 276 422
ELSIF                : 277
END                  : 96 117 271 278 292 295 331 335 340 362 365 369 382 395 400 410 420 421 422 504
ENTRY                : 390 391 392 393
EQ                   : 207
EXCEPTION            : 351 455 456
EXIT                 : 302
FALSE                : 
FOR                  : 286 503 504 509
FUNCTION             : 132 314 315 474
GE                   : 212
GENERIC              : 469
GOTO                 : 309
GT                   : 211
IDENTIFIER           : 2 26 36 48 66 161 180 268 285 286 367 390 391 392 393 459
IF                   : 271 271
IN                   : 213 214 286 326 328
INTERFACE            : 
IS                   : 41 48 117 279 330 335 340 362 365 369 382 395 451 452 453 454 472 475 476 482 483 497 498
IS_ASSIGNED          : 34 35 270
LCB                  : 
LE                   : 210
LIMITED              : 345
LLB                  : 268
LOOP                 : 292 292
LPAREN               : 3 39 62 63 80 88 110 168 187 188 189 190 191 239 320 391 393 403 446 475 480 484
LSQB                 : 
LT                   : 209
MINUS                : 219 221
MOD                  : 69 227 486 506
NE                   : 208
NEW                  : 54 55 56 57 58 241 242 475 476 494 495 496 499
NOT                  : 214 230
NULL                 : 97 103 186 190 191 269
NUMBER               : 184
NUMBERSIGN           : 
OF                   : 80 81
OR                   : 199 202 414 421
OTHERS               : 125 463
OUT                  : 327 328
OVERRIDING           : 
PACKAGE              : 335 340 353 355 452 475 476 498
PLUS                 : 218 220
POW                  : 232
PRAGMA               : 2 3
PRIVATE              : 55 57 337 343 364 371 432 495 496
PROCEDURE            : 131 313 473
PROTECTED            : 134 367 368 382 454
QUOTE                : 
RAISE                : 464
RANGE                : 59 61 62 87 485 508
RCB                  : 
RECORD               : 96 96 97 190 191 504 504
REM                  : 228
RENAMES              : 357
REQUEUE              : 465 466
RETURN               : 132 307 308 314 474
REVERSE              : 291
RLB                  : 268
RPAREN               : 3 39 62 63 80 88 110 168 187 188 189 190 191 239 320 391 393 403 446 475 480 484
RSQB                 : 
SELECT               : 410 410 420 420 421 421 422 422
SEMICOLON            : 2 3 22 23 35 36 48 103 108 109 112 117 261 269 270 271 278 283 295 302 307 308 309 310 311 312 322 331 332 333 334 340 346 347 350 351 353 354 355 356 358 365 366 375 382 387 390 391 394 395 399 400 404 405 410 417 420 421 422 425 436 451 452 453 454 455 464 465 466 467 468 471 472 473 474 475 476 503 504 506 508 509 510
SEPARATE             : 446 451 452 453 454
SOME                 : 
STRING               : 167 317
SUBTYPE              : 48
SYNCHRONIZED         : 
TAGGED               : 99 100
TASK                 : 359 360 365 451
TERMINATE            : 417
THEN                 : 201 273 420
TICK                 : 61 62 159 179 240
TIMES                : 225
TRUE                 : 
TYPE                 : 36 347 360 368 472
UNTIL                : 405
USE                  : 346 347 503 504 509
VLINE                : 
WHEN                 : 120 282 306 392 393 412 458 459
WHILE                : 288
WITH                 : 55 56 57 58 189 190 436 466 473 474 475 476 495 496
XOR                  : 200
error                : 22 109 114 174 261 324
|                    : 122 461

Nonterminals, with rules where they appear

NULL_stmt            : 250
abort_stmt           : 257
accept_hdr           : 399 400
accept_stmt          : 266 415
access_opt           : 113
access_type          : 47 491
adding               : 217
address_spec         : 502
aggregate            : 238
aliased_opt          : 82
align_opt            : 504
allocator            : 234
alternative          : 281
alternative_s        : 278 281
array_type           : 32 45 490
assign_stmt          : 251
async_select         : 407
attrib_def           : 500
attribute            : 156
attribute_id         : 159 179
basic_loop           : 283
block                : 265
block_body           : 295 331 342 365 395
block_decl           : 295
body                 : 147
body_opt             : 340
body_stub            : 21
c_id_opt             : 335 340
c_name_list          : 165 436
case_hdr             : 278
case_stmt            : 263
choice               : 121 122
choice_s             : 120 122 194 282
code_stmt            : 259
comp_assoc           : 172 187
comp_decl            : 104 105 381
comp_decl_s          : 101 105
comp_list            : 96 120
comp_loc_s           : 504 508
comp_unit            : 427
compilation          : 1 427
component_subtype_def : 80 81 108
compound_name        : 163 164 165 313 316 335 339 340 353 355 446 452 498
compound_stmt        : 248
cond_clause          : 271 277
cond_entry_call      : 409
cond_part            : 272
condition            : 273 288 306 392 393 412
constr_array_type    : 79
constraint           : 49
context_spec         : 429 434 435
decimal_digits_constraint : 52
decl                 : 141
decl_item            : 139 140 148
decl_item_or_body    : 145 146
decl_item_or_body_s1 : 136 146
decl_item_s          : 335 337
decl_item_s1         : 138 140
decl_part            : 297 331 340 365 395
def_id               : 24 25
def_id_s             : 23 25 35 108 113 323 350 351 455
delay_or_entry_alt   : 420
delay_stmt           : 256 416 418 421
derived_type         : 
designator           : 294 314 315 474
discrete_range       : 89 90 289 391 393
discrete_with_range  : 124 173
discrim_part         : 38 479
discrim_part_opt     : 36 360 368
discrim_spec         : 111 112
discrim_spec_s       : 110 112
else_opt             : 271 277 410
empty                : 303
entry_body           : 385
entry_body_part      : 392 393
entry_call           : 419 421 422
entry_decl           : 374 389
entry_decl_s         : 362 364 389
entry_name           : 401 403
enum_id              : 64 65
enum_id_s            : 63 65
enumeration_type     : 42
except_choice        : 460 461
except_choice_s      : 458 459 461
except_handler_part  : 301 457
except_handler_part_opt : 299
exception_decl       : 18
exception_handler    : 456 457
exit_stmt            : 252
expression           : 6 7 34 35 53 62 69 75 76 77 77 123 171 189 190 194 196 197 239 270 274 279 308 403 404 405 503 506 508 509
factor               : 223 224
fixed_type           : 74
float_type           : 73
formal_part          : 319
formal_part_opt      : 131 132 313 314 390 391 392 393 401 473 474
generic_decl         : 20 444
generic_derived_type : 493
generic_discrim_part_opt : 472
generic_formal       : 470
generic_formal_part  : 355 356 467 468 470
generic_inst         : 497 498
generic_pkg_inst     : 334
generic_subp_inst    : 311
generic_type_def     : 472
goal_symbol          : 0
goto_stmt            : 254
guarded_select_alt   : 410 414
handled_stmt_s       : 298 400
id_opt               : 283 295 331 362 365 369 382 395 400
if_stmt              : 262
index                : 85 86
index_s              : 80 86
indexed_comp         : 154
init_opt             : 23 108 113 323
integer_type         : 43
iter_discrete_range_s : 88 90
iter_index_constraint : 81
iter_part            : 289 393
iteration            : 283
label                : 246
label_opt            : 283 295
limited_opt          : 95 343
literal              : 233
logical              : 196
loop_stmt            : 264
mark                 : 113 132 159 160 323 503 504 508 509
membership           : 205 206
mode                 : 323
multiplying          : 224
name                 : 49 50 61 62 87 91 126 168 175 176 177 178 179 206 237 240 241 270 304 309 314 332 348 349 357 462 465 466 474 475 476 482 499
name_opt             : 302 464
name_s               : 346 347 349 425
number_decl          : 11
object_decl          : 10
object_qualifier_opt : 23 350
object_subtype_def   : 23
operator_symbol      : 157 177
or_select            : 410 414
param                : 321 322 471
param_s              : 320 322
parenthesized_primary : 236 240
pkg_body             : 150 440 448
pkg_decl             : 15 439
pkg_spec             : 333 468
pragma               : 9 144 249 377 428 435
pragma_arg           : 4 5
pragma_arg_s         : 3 5
pragma_s             : 9 383 384 388 389 397 428
primary              : 229 230 231 232 232
private_opt          : 429 430
private_part         : 335
private_type         : 492
procedure_call       : 255 398
prot_body            : 152 450
prot_decl            : 17
prot_def             : 367 368
prot_elem_decl       : 379
prot_elem_decl_s     : 371 379
prot_op_body         : 384
prot_op_body_s       : 382 384
prot_op_decl         : 373 380
prot_op_decl_s       : 369 373
prot_opt             : 131 132
prot_private_opt     : 369
prot_spec            : 366
qualified            : 235 242 510
raise_stmt           : 258
range                : 59 92 127 205 508
range_constr_opt     : 53 91
range_constraint     : 51 70 94 126
range_spec           : 68 72 76
range_spec_opt       : 75 77
real_type            : 44
record_def           : 56 58 95
record_type          : 46
record_type_spec     : 501
relation             : 195 196 197
relational           : 204
rename_decl          : 19
rename_unit          : 352 445
renames              : 350 351 353 354 355 356
rep_spec             : 143 376 397
rep_spec_s           : 362 364 397
requeue_stmt         : 260
return_stmt          : 253
reverse_opt          : 289
select_alt           : 411 412
select_stmt          : 267
select_wait          : 406
selected_comp        : 155
short_circuit        : 197
simple_expression    : 60 60 203 204 204 205 206 217
simple_name          : 3 7 117 153 158 160 162 163 175 359 360 365 368 382 402 451 454 472 473 475 476
simple_stmt          : 247
statement            : 243 244 246
statement_s          : 244 272 276 282 292 299 420 422 424 458 459
stmts_opt            : 415 416 418 419 421 421 422
subp_default         : 473 474
subprog_body         : 149 386 442 447
subprog_decl         : 14 441
subprog_spec         : 310 330 354 356 375 387 453 467 497
subprog_spec_is_push : 312 331
subtype_decl         : 13
subtype_ind          : 31 48 54 55 56 57 58 82 128 129 130 350 494 495 496
subunit              : 443
subunit_body         : 446
tagged_opt           : 95 343
task_body            : 151 449
task_decl            : 16
task_def             : 359 360
task_private_opt     : 362
task_spec            : 358
term                 : 215 216 217 224
timed_entry_call     : 408
type_completion      : 36
type_decl            : 12
type_def             : 41
unary                : 215
unconstr_array_type  : 78
unit                 : 429 430
unlabeled            : 245
use_clause           : 142 438 477
use_clause_opt       : 433 434 438
used_char            : 176 185
value                : 169 170 192 192 193
value_s              : 168 170 189
value_s_2            : 188 193
variant              : 118 119
variant_part         : 102 107
variant_part_opt     : 101
variant_s            : 117 119
when_opt             : 302
with_clause          : 433 434

Parsing method: LALR

state 0

    (0) S' -> . goal_symbol
    (1) goal_symbol -> . compilation
    (426) compilation -> .
    (427) compilation -> . compilation comp_unit
    (428) compilation -> . pragma pragma_s
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON

    PRIVATE         reduce using rule 426 (compilation -> .)
    WITH            reduce using rule 426 (compilation -> .)
    PACKAGE         reduce using rule 426 (compilation -> .)
    SEPARATE        reduce using rule 426 (compilation -> .)
    PROCEDURE       reduce using rule 426 (compilation -> .)
    FUNCTION        reduce using rule 426 (compilation -> .)
    GENERIC         reduce using rule 426 (compilation -> .)
    $end            reduce using rule 426 (compilation -> .)
    PRAGMA          shift and go to state 4

    compilation                    shift and go to state 2
    goal_symbol                    shift and go to state 3
    pragma                         shift and go to state 1

state 1

    (428) compilation -> pragma . pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    PRIVATE         reduce using rule 8 (pragma_s -> .)
    WITH            reduce using rule 8 (pragma_s -> .)
    PACKAGE         reduce using rule 8 (pragma_s -> .)
    SEPARATE        reduce using rule 8 (pragma_s -> .)
    PROCEDURE       reduce using rule 8 (pragma_s -> .)
    FUNCTION        reduce using rule 8 (pragma_s -> .)
    GENERIC         reduce using rule 8 (pragma_s -> .)
    $end            reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 5

state 2

    (1) goal_symbol -> compilation .
    (427) compilation -> compilation . comp_unit
    (429) comp_unit -> . context_spec private_opt unit
    (430) comp_unit -> . private_opt unit
    (433) context_spec -> . with_clause use_clause_opt
    (434) context_spec -> . context_spec with_clause use_clause_opt
    (435) context_spec -> . context_spec pragma
    (431) private_opt -> .
    (432) private_opt -> . PRIVATE
    (436) with_clause -> . WITH c_name_list SEMICOLON

    $end            reduce using rule 1 (goal_symbol -> compilation .)
    PACKAGE         reduce using rule 431 (private_opt -> .)
    SEPARATE        reduce using rule 431 (private_opt -> .)
    PROCEDURE       reduce using rule 431 (private_opt -> .)
    FUNCTION        reduce using rule 431 (private_opt -> .)
    GENERIC         reduce using rule 431 (private_opt -> .)
    PRIVATE         shift and go to state 7
    WITH            shift and go to state 11

    context_spec                   shift and go to state 6
    with_clause                    shift and go to state 8
    private_opt                    shift and go to state 9
    comp_unit                      shift and go to state 10

state 3

    (0) S' -> goal_symbol .



state 4

    (2) pragma -> PRAGMA . IDENTIFIER SEMICOLON
    (3) pragma -> PRAGMA . simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 12

    simple_name                    shift and go to state 13

state 5

    (428) compilation -> pragma pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON

    PRIVATE         reduce using rule 428 (compilation -> pragma pragma_s .)
    WITH            reduce using rule 428 (compilation -> pragma pragma_s .)
    PACKAGE         reduce using rule 428 (compilation -> pragma pragma_s .)
    SEPARATE        reduce using rule 428 (compilation -> pragma pragma_s .)
    PROCEDURE       reduce using rule 428 (compilation -> pragma pragma_s .)
    FUNCTION        reduce using rule 428 (compilation -> pragma pragma_s .)
    GENERIC         reduce using rule 428 (compilation -> pragma pragma_s .)
    $end            reduce using rule 428 (compilation -> pragma pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 6

    (429) comp_unit -> context_spec . private_opt unit
    (434) context_spec -> context_spec . with_clause use_clause_opt
    (435) context_spec -> context_spec . pragma
    (431) private_opt -> .
    (432) private_opt -> . PRIVATE
    (436) with_clause -> . WITH c_name_list SEMICOLON
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON

    PACKAGE         reduce using rule 431 (private_opt -> .)
    SEPARATE        reduce using rule 431 (private_opt -> .)
    PROCEDURE       reduce using rule 431 (private_opt -> .)
    FUNCTION        reduce using rule 431 (private_opt -> .)
    GENERIC         reduce using rule 431 (private_opt -> .)
    PRIVATE         shift and go to state 7
    WITH            shift and go to state 11
    PRAGMA          shift and go to state 4

    with_clause                    shift and go to state 15
    private_opt                    shift and go to state 16
    pragma                         shift and go to state 17

state 7

    (432) private_opt -> PRIVATE .

    PACKAGE         reduce using rule 432 (private_opt -> PRIVATE .)
    SEPARATE        reduce using rule 432 (private_opt -> PRIVATE .)
    PROCEDURE       reduce using rule 432 (private_opt -> PRIVATE .)
    FUNCTION        reduce using rule 432 (private_opt -> PRIVATE .)
    GENERIC         reduce using rule 432 (private_opt -> PRIVATE .)


state 8

    (433) context_spec -> with_clause . use_clause_opt
    (437) use_clause_opt -> .
    (438) use_clause_opt -> . use_clause_opt use_clause

    USE             reduce using rule 437 (use_clause_opt -> .)
    PRIVATE         reduce using rule 437 (use_clause_opt -> .)
    WITH            reduce using rule 437 (use_clause_opt -> .)
    PRAGMA          reduce using rule 437 (use_clause_opt -> .)
    PACKAGE         reduce using rule 437 (use_clause_opt -> .)
    SEPARATE        reduce using rule 437 (use_clause_opt -> .)
    PROCEDURE       reduce using rule 437 (use_clause_opt -> .)
    FUNCTION        reduce using rule 437 (use_clause_opt -> .)
    GENERIC         reduce using rule 437 (use_clause_opt -> .)

    use_clause_opt                 shift and go to state 18

state 9

    (430) comp_unit -> private_opt . unit
    (439) unit -> . pkg_decl
    (440) unit -> . pkg_body
    (441) unit -> . subprog_decl
    (442) unit -> . subprog_body
    (443) unit -> . subunit
    (444) unit -> . generic_decl
    (445) unit -> . rename_unit
    (333) pkg_decl -> . pkg_spec SEMICOLON
    (334) pkg_decl -> . generic_pkg_inst SEMICOLON
    (340) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt SEMICOLON
    (310) subprog_decl -> . subprog_spec SEMICOLON
    (311) subprog_decl -> . generic_subp_inst SEMICOLON
    (312) subprog_decl -> . subprog_spec_is_push ABSTRACT SEMICOLON
    (331) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt SEMICOLON
    (446) subunit -> . SEPARATE LPAREN compound_name RPAREN subunit_body
    (467) generic_decl -> . generic_formal_part subprog_spec SEMICOLON
    (468) generic_decl -> . generic_formal_part pkg_spec SEMICOLON
    (353) rename_unit -> . PACKAGE compound_name renames SEMICOLON
    (354) rename_unit -> . subprog_spec renames SEMICOLON
    (355) rename_unit -> . generic_formal_part PACKAGE compound_name renames SEMICOLON
    (356) rename_unit -> . generic_formal_part subprog_spec renames SEMICOLON
    (335) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (498) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (313) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (314) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (315) subprog_spec -> . FUNCTION designator
    (497) generic_subp_inst -> . subprog_spec IS generic_inst
    (330) subprog_spec_is_push -> . subprog_spec IS
    (469) generic_formal_part -> . GENERIC
    (470) generic_formal_part -> . generic_formal_part generic_formal

    PACKAGE         shift and go to state 27
    SEPARATE        shift and go to state 20
    PROCEDURE       shift and go to state 30
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21

    subprog_body                   shift and go to state 19
    subprog_decl                   shift and go to state 22
    unit                           shift and go to state 23
    subprog_spec_is_push           shift and go to state 32
    generic_decl                   shift and go to state 24
    subprog_spec                   shift and go to state 25
    subunit                        shift and go to state 26
    generic_subp_inst              shift and go to state 28
    rename_unit                    shift and go to state 29
    pkg_decl                       shift and go to state 31
    generic_formal_part            shift and go to state 33
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 35
    pkg_spec                       shift and go to state 37

state 10

    (427) compilation -> compilation comp_unit .

    PRIVATE         reduce using rule 427 (compilation -> compilation comp_unit .)
    WITH            reduce using rule 427 (compilation -> compilation comp_unit .)
    PACKAGE         reduce using rule 427 (compilation -> compilation comp_unit .)
    SEPARATE        reduce using rule 427 (compilation -> compilation comp_unit .)
    PROCEDURE       reduce using rule 427 (compilation -> compilation comp_unit .)
    FUNCTION        reduce using rule 427 (compilation -> compilation comp_unit .)
    GENERIC         reduce using rule 427 (compilation -> compilation comp_unit .)
    $end            reduce using rule 427 (compilation -> compilation comp_unit .)


state 11

    (436) with_clause -> WITH . c_name_list SEMICOLON
    (164) c_name_list -> . compound_name
    (165) c_name_list -> . c_name_list COMMA compound_name
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name DOT simple_name
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 40

    c_name_list                    shift and go to state 38
    compound_name                  shift and go to state 39
    simple_name                    shift and go to state 41

state 12

    (2) pragma -> PRAGMA IDENTIFIER . SEMICOLON
    (161) simple_name -> IDENTIFIER .

    SEMICOLON       shift and go to state 42
    LPAREN          reduce using rule 161 (simple_name -> IDENTIFIER .)


state 13

    (3) pragma -> PRAGMA simple_name . LPAREN pragma_arg_s RPAREN SEMICOLON

    LPAREN          shift and go to state 43


state 14

    (9) pragma_s -> pragma_s pragma .

    PRAGMA          reduce using rule 9 (pragma_s -> pragma_s pragma .)
    PRIVATE         reduce using rule 9 (pragma_s -> pragma_s pragma .)
    FOR             reduce using rule 9 (pragma_s -> pragma_s pragma .)
    END             reduce using rule 9 (pragma_s -> pragma_s pragma .)
    ENTRY           reduce using rule 9 (pragma_s -> pragma_s pragma .)
    PROCEDURE       reduce using rule 9 (pragma_s -> pragma_s pragma .)
    FUNCTION        reduce using rule 9 (pragma_s -> pragma_s pragma .)
    WITH            reduce using rule 9 (pragma_s -> pragma_s pragma .)
    PACKAGE         reduce using rule 9 (pragma_s -> pragma_s pragma .)
    SEPARATE        reduce using rule 9 (pragma_s -> pragma_s pragma .)
    GENERIC         reduce using rule 9 (pragma_s -> pragma_s pragma .)
    $end            reduce using rule 9 (pragma_s -> pragma_s pragma .)


state 15

    (434) context_spec -> context_spec with_clause . use_clause_opt
    (437) use_clause_opt -> .
    (438) use_clause_opt -> . use_clause_opt use_clause

    USE             reduce using rule 437 (use_clause_opt -> .)
    PRIVATE         reduce using rule 437 (use_clause_opt -> .)
    WITH            reduce using rule 437 (use_clause_opt -> .)
    PRAGMA          reduce using rule 437 (use_clause_opt -> .)
    PACKAGE         reduce using rule 437 (use_clause_opt -> .)
    SEPARATE        reduce using rule 437 (use_clause_opt -> .)
    PROCEDURE       reduce using rule 437 (use_clause_opt -> .)
    FUNCTION        reduce using rule 437 (use_clause_opt -> .)
    GENERIC         reduce using rule 437 (use_clause_opt -> .)

    use_clause_opt                 shift and go to state 44

state 16

    (429) comp_unit -> context_spec private_opt . unit
    (439) unit -> . pkg_decl
    (440) unit -> . pkg_body
    (441) unit -> . subprog_decl
    (442) unit -> . subprog_body
    (443) unit -> . subunit
    (444) unit -> . generic_decl
    (445) unit -> . rename_unit
    (333) pkg_decl -> . pkg_spec SEMICOLON
    (334) pkg_decl -> . generic_pkg_inst SEMICOLON
    (340) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt SEMICOLON
    (310) subprog_decl -> . subprog_spec SEMICOLON
    (311) subprog_decl -> . generic_subp_inst SEMICOLON
    (312) subprog_decl -> . subprog_spec_is_push ABSTRACT SEMICOLON
    (331) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt SEMICOLON
    (446) subunit -> . SEPARATE LPAREN compound_name RPAREN subunit_body
    (467) generic_decl -> . generic_formal_part subprog_spec SEMICOLON
    (468) generic_decl -> . generic_formal_part pkg_spec SEMICOLON
    (353) rename_unit -> . PACKAGE compound_name renames SEMICOLON
    (354) rename_unit -> . subprog_spec renames SEMICOLON
    (355) rename_unit -> . generic_formal_part PACKAGE compound_name renames SEMICOLON
    (356) rename_unit -> . generic_formal_part subprog_spec renames SEMICOLON
    (335) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (498) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (313) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (314) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (315) subprog_spec -> . FUNCTION designator
    (497) generic_subp_inst -> . subprog_spec IS generic_inst
    (330) subprog_spec_is_push -> . subprog_spec IS
    (469) generic_formal_part -> . GENERIC
    (470) generic_formal_part -> . generic_formal_part generic_formal

    PACKAGE         shift and go to state 27
    SEPARATE        shift and go to state 20
    PROCEDURE       shift and go to state 30
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21

    subprog_body                   shift and go to state 19
    pkg_body                       shift and go to state 35
    unit                           shift and go to state 45
    subprog_spec_is_push           shift and go to state 32
    generic_decl                   shift and go to state 24
    subprog_spec                   shift and go to state 25
    subunit                        shift and go to state 26
    generic_subp_inst              shift and go to state 28
    rename_unit                    shift and go to state 29
    pkg_decl                       shift and go to state 31
    generic_formal_part            shift and go to state 33
    generic_pkg_inst               shift and go to state 34
    subprog_decl                   shift and go to state 22
    pkg_spec                       shift and go to state 37

state 17

    (435) context_spec -> context_spec pragma .

    PRIVATE         reduce using rule 435 (context_spec -> context_spec pragma .)
    WITH            reduce using rule 435 (context_spec -> context_spec pragma .)
    PRAGMA          reduce using rule 435 (context_spec -> context_spec pragma .)
    PACKAGE         reduce using rule 435 (context_spec -> context_spec pragma .)
    SEPARATE        reduce using rule 435 (context_spec -> context_spec pragma .)
    PROCEDURE       reduce using rule 435 (context_spec -> context_spec pragma .)
    FUNCTION        reduce using rule 435 (context_spec -> context_spec pragma .)
    GENERIC         reduce using rule 435 (context_spec -> context_spec pragma .)


state 18

    (433) context_spec -> with_clause use_clause_opt .
    (438) use_clause_opt -> use_clause_opt . use_clause
    (346) use_clause -> . USE name_s SEMICOLON
    (347) use_clause -> . USE TYPE name_s SEMICOLON

    PRIVATE         reduce using rule 433 (context_spec -> with_clause use_clause_opt .)
    WITH            reduce using rule 433 (context_spec -> with_clause use_clause_opt .)
    PRAGMA          reduce using rule 433 (context_spec -> with_clause use_clause_opt .)
    PACKAGE         reduce using rule 433 (context_spec -> with_clause use_clause_opt .)
    SEPARATE        reduce using rule 433 (context_spec -> with_clause use_clause_opt .)
    PROCEDURE       reduce using rule 433 (context_spec -> with_clause use_clause_opt .)
    FUNCTION        reduce using rule 433 (context_spec -> with_clause use_clause_opt .)
    GENERIC         reduce using rule 433 (context_spec -> with_clause use_clause_opt .)
    USE             shift and go to state 46

    use_clause                     shift and go to state 47

state 19

    (442) unit -> subprog_body .

    PRIVATE         reduce using rule 442 (unit -> subprog_body .)
    WITH            reduce using rule 442 (unit -> subprog_body .)
    PACKAGE         reduce using rule 442 (unit -> subprog_body .)
    SEPARATE        reduce using rule 442 (unit -> subprog_body .)
    PROCEDURE       reduce using rule 442 (unit -> subprog_body .)
    FUNCTION        reduce using rule 442 (unit -> subprog_body .)
    GENERIC         reduce using rule 442 (unit -> subprog_body .)
    $end            reduce using rule 442 (unit -> subprog_body .)


state 20

    (446) subunit -> SEPARATE . LPAREN compound_name RPAREN subunit_body

    LPAREN          shift and go to state 48


state 21

    (469) generic_formal_part -> GENERIC .

    PACKAGE         reduce using rule 469 (generic_formal_part -> GENERIC .)
    PROCEDURE       reduce using rule 469 (generic_formal_part -> GENERIC .)
    FUNCTION        reduce using rule 469 (generic_formal_part -> GENERIC .)
    TYPE            reduce using rule 469 (generic_formal_part -> GENERIC .)
    WITH            reduce using rule 469 (generic_formal_part -> GENERIC .)
    error           reduce using rule 469 (generic_formal_part -> GENERIC .)
    USE             reduce using rule 469 (generic_formal_part -> GENERIC .)
    IDENTIFIER      reduce using rule 469 (generic_formal_part -> GENERIC .)


state 22

    (441) unit -> subprog_decl .

    PRIVATE         reduce using rule 441 (unit -> subprog_decl .)
    WITH            reduce using rule 441 (unit -> subprog_decl .)
    PACKAGE         reduce using rule 441 (unit -> subprog_decl .)
    SEPARATE        reduce using rule 441 (unit -> subprog_decl .)
    PROCEDURE       reduce using rule 441 (unit -> subprog_decl .)
    FUNCTION        reduce using rule 441 (unit -> subprog_decl .)
    GENERIC         reduce using rule 441 (unit -> subprog_decl .)
    $end            reduce using rule 441 (unit -> subprog_decl .)


state 23

    (430) comp_unit -> private_opt unit .

    PRIVATE         reduce using rule 430 (comp_unit -> private_opt unit .)
    WITH            reduce using rule 430 (comp_unit -> private_opt unit .)
    PACKAGE         reduce using rule 430 (comp_unit -> private_opt unit .)
    SEPARATE        reduce using rule 430 (comp_unit -> private_opt unit .)
    PROCEDURE       reduce using rule 430 (comp_unit -> private_opt unit .)
    FUNCTION        reduce using rule 430 (comp_unit -> private_opt unit .)
    GENERIC         reduce using rule 430 (comp_unit -> private_opt unit .)
    $end            reduce using rule 430 (comp_unit -> private_opt unit .)


state 24

    (444) unit -> generic_decl .

    PRIVATE         reduce using rule 444 (unit -> generic_decl .)
    WITH            reduce using rule 444 (unit -> generic_decl .)
    PACKAGE         reduce using rule 444 (unit -> generic_decl .)
    SEPARATE        reduce using rule 444 (unit -> generic_decl .)
    PROCEDURE       reduce using rule 444 (unit -> generic_decl .)
    FUNCTION        reduce using rule 444 (unit -> generic_decl .)
    GENERIC         reduce using rule 444 (unit -> generic_decl .)
    $end            reduce using rule 444 (unit -> generic_decl .)


state 25

    (310) subprog_decl -> subprog_spec . SEMICOLON
    (354) rename_unit -> subprog_spec . renames SEMICOLON
    (497) generic_subp_inst -> subprog_spec . IS generic_inst
    (330) subprog_spec_is_push -> subprog_spec . IS
    (357) renames -> . RENAMES name

    SEMICOLON       shift and go to state 49
    IS              shift and go to state 52
    RENAMES         shift and go to state 51

    renames                        shift and go to state 50

state 26

    (443) unit -> subunit .

    PRIVATE         reduce using rule 443 (unit -> subunit .)
    WITH            reduce using rule 443 (unit -> subunit .)
    PACKAGE         reduce using rule 443 (unit -> subunit .)
    SEPARATE        reduce using rule 443 (unit -> subunit .)
    PROCEDURE       reduce using rule 443 (unit -> subunit .)
    FUNCTION        reduce using rule 443 (unit -> subunit .)
    GENERIC         reduce using rule 443 (unit -> subunit .)
    $end            reduce using rule 443 (unit -> subunit .)


state 27

    (340) pkg_body -> PACKAGE . BODY compound_name IS decl_part body_opt END c_id_opt SEMICOLON
    (353) rename_unit -> PACKAGE . compound_name renames SEMICOLON
    (335) pkg_spec -> PACKAGE . compound_name IS decl_item_s private_part END c_id_opt
    (498) generic_pkg_inst -> PACKAGE . compound_name IS generic_inst
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name DOT simple_name
    (161) simple_name -> . IDENTIFIER

    BODY            shift and go to state 53
    IDENTIFIER      shift and go to state 40

    simple_name                    shift and go to state 41
    compound_name                  shift and go to state 54

state 28

    (311) subprog_decl -> generic_subp_inst . SEMICOLON

    SEMICOLON       shift and go to state 55


state 29

    (445) unit -> rename_unit .

    PRIVATE         reduce using rule 445 (unit -> rename_unit .)
    WITH            reduce using rule 445 (unit -> rename_unit .)
    PACKAGE         reduce using rule 445 (unit -> rename_unit .)
    SEPARATE        reduce using rule 445 (unit -> rename_unit .)
    PROCEDURE       reduce using rule 445 (unit -> rename_unit .)
    FUNCTION        reduce using rule 445 (unit -> rename_unit .)
    GENERIC         reduce using rule 445 (unit -> rename_unit .)
    $end            reduce using rule 445 (unit -> rename_unit .)


state 30

    (313) subprog_spec -> PROCEDURE . compound_name formal_part_opt
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name DOT simple_name
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 40

    compound_name                  shift and go to state 56
    simple_name                    shift and go to state 41

state 31

    (439) unit -> pkg_decl .

    PRIVATE         reduce using rule 439 (unit -> pkg_decl .)
    WITH            reduce using rule 439 (unit -> pkg_decl .)
    PACKAGE         reduce using rule 439 (unit -> pkg_decl .)
    SEPARATE        reduce using rule 439 (unit -> pkg_decl .)
    PROCEDURE       reduce using rule 439 (unit -> pkg_decl .)
    FUNCTION        reduce using rule 439 (unit -> pkg_decl .)
    GENERIC         reduce using rule 439 (unit -> pkg_decl .)
    $end            reduce using rule 439 (unit -> pkg_decl .)


state 32

    (312) subprog_decl -> subprog_spec_is_push . ABSTRACT SEMICOLON
    (331) subprog_body -> subprog_spec_is_push . decl_part block_body END id_opt SEMICOLON
    (135) decl_part -> .
    (136) decl_part -> . decl_item_or_body_s1
    (145) decl_item_or_body_s1 -> . decl_item_or_body
    (146) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (147) decl_item_or_body -> . body
    (148) decl_item_or_body -> . decl_item
    (149) body -> . subprog_body
    (150) body -> . pkg_body
    (151) body -> . task_body
    (152) body -> . prot_body
    (141) decl_item -> . decl
    (142) decl_item -> . use_clause
    (143) decl_item -> . rep_spec
    (144) decl_item -> . pragma
    (331) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt SEMICOLON
    (340) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt SEMICOLON
    (365) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt SEMICOLON
    (382) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt SEMICOLON
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error SEMICOLON
    (346) use_clause -> . USE name_s SEMICOLON
    (347) use_clause -> . USE TYPE name_s SEMICOLON
    (500) rep_spec -> . attrib_def
    (501) rep_spec -> . record_type_spec
    (502) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (330) subprog_spec_is_push -> . subprog_spec IS
    (23) object_decl -> . def_id_s COLON object_qualifier_opt object_subtype_def init_opt SEMICOLON
    (35) number_decl -> . def_id_s COLON CONSTANT IS_ASSIGNED expression SEMICOLON
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion SEMICOLON
    (48) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind SEMICOLON
    (310) subprog_decl -> . subprog_spec SEMICOLON
    (311) subprog_decl -> . generic_subp_inst SEMICOLON
    (312) subprog_decl -> . subprog_spec_is_push ABSTRACT SEMICOLON
    (333) pkg_decl -> . pkg_spec SEMICOLON
    (334) pkg_decl -> . generic_pkg_inst SEMICOLON
    (358) task_decl -> . task_spec SEMICOLON
    (366) prot_decl -> . prot_spec SEMICOLON
    (455) exception_decl -> . def_id_s COLON EXCEPTION SEMICOLON
    (350) rename_decl -> . def_id_s COLON object_qualifier_opt subtype_ind renames SEMICOLON
    (351) rename_decl -> . def_id_s COLON EXCEPTION renames SEMICOLON
    (352) rename_decl -> . rename_unit
    (467) generic_decl -> . generic_formal_part subprog_spec SEMICOLON
    (468) generic_decl -> . generic_formal_part pkg_spec SEMICOLON
    (451) body_stub -> . TASK BODY simple_name IS SEPARATE SEMICOLON
    (452) body_stub -> . PACKAGE BODY compound_name IS SEPARATE SEMICOLON
    (453) body_stub -> . subprog_spec IS SEPARATE SEMICOLON
    (454) body_stub -> . PROTECTED BODY simple_name IS SEPARATE SEMICOLON
    (503) attrib_def -> . FOR mark USE expression SEMICOLON
    (504) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD SEMICOLON
    (509) address_spec -> . FOR mark USE AT expression SEMICOLON
    (313) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (314) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (315) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s COMMA def_id
    (497) generic_subp_inst -> . subprog_spec IS generic_inst
    (335) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (498) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (359) task_spec -> . TASK simple_name task_def
    (360) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (367) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (368) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (353) rename_unit -> . PACKAGE compound_name renames SEMICOLON
    (354) rename_unit -> . subprog_spec renames SEMICOLON
    (355) rename_unit -> . generic_formal_part PACKAGE compound_name renames SEMICOLON
    (356) rename_unit -> . generic_formal_part subprog_spec renames SEMICOLON
    (469) generic_formal_part -> . GENERIC
    (470) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    ABSTRACT        shift and go to state 88
    BEGIN           reduce using rule 135 (decl_part -> .)
    PACKAGE         shift and go to state 80
    TASK            shift and go to state 74
    PROTECTED       shift and go to state 58
    error           shift and go to state 85
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 87
    SUBTYPE         shift and go to state 91
    FOR             shift and go to state 70
    PROCEDURE       shift and go to state 30
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 79

    decl                           shift and go to state 57
    subprog_body                   shift and go to state 66
    task_decl                      shift and go to state 67
    type_decl                      shift and go to state 63
    rep_spec                       shift and go to state 89
    task_body                      shift and go to state 90
    subtype_decl                   shift and go to state 68
    exception_decl                 shift and go to state 92
    address_spec                   shift and go to state 59
    subprog_spec_is_push           shift and go to state 93
    decl_part                      shift and go to state 61
    prot_decl                      shift and go to state 62
    record_type_spec               shift and go to state 75
    generic_decl                   shift and go to state 76
    def_id                         shift and go to state 96
    attrib_def                     shift and go to state 77
    subprog_spec                   shift and go to state 94
    def_id_s                       shift and go to state 95
    decl_item_or_body_s1           shift and go to state 78
    decl_item                      shift and go to state 60
    task_spec                      shift and go to state 72
    body                           shift and go to state 69
    object_decl                    shift and go to state 71
    body_stub                      shift and go to state 81
    pkg_spec                       shift and go to state 37
    rename_decl                    shift and go to state 97
    generic_subp_inst              shift and go to state 28
    pragma                         shift and go to state 82
    rename_unit                    shift and go to state 98
    subprog_decl                   shift and go to state 65
    pkg_decl                       shift and go to state 64
    prot_spec                      shift and go to state 83
    generic_formal_part            shift and go to state 33
    prot_body                      shift and go to state 99
    use_clause                     shift and go to state 73
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 84
    decl_item_or_body              shift and go to state 86
    number_decl                    shift and go to state 100

state 33

    (467) generic_decl -> generic_formal_part . subprog_spec SEMICOLON
    (468) generic_decl -> generic_formal_part . pkg_spec SEMICOLON
    (355) rename_unit -> generic_formal_part . PACKAGE compound_name renames SEMICOLON
    (356) rename_unit -> generic_formal_part . subprog_spec renames SEMICOLON
    (470) generic_formal_part -> generic_formal_part . generic_formal
    (313) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (314) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (315) subprog_spec -> . FUNCTION designator
    (335) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (471) generic_formal -> . param SEMICOLON
    (472) generic_formal -> . TYPE simple_name generic_discrim_part_opt IS generic_type_def SEMICOLON
    (473) generic_formal -> . WITH PROCEDURE simple_name formal_part_opt subp_default SEMICOLON
    (474) generic_formal -> . WITH FUNCTION designator formal_part_opt RETURN name subp_default SEMICOLON
    (475) generic_formal -> . WITH PACKAGE simple_name IS NEW name LPAREN BOX RPAREN SEMICOLON
    (476) generic_formal -> . WITH PACKAGE simple_name IS NEW name SEMICOLON
    (477) generic_formal -> . use_clause
    (323) param -> . def_id_s COLON mode mark init_opt
    (324) param -> . error
    (346) use_clause -> . USE name_s SEMICOLON
    (347) use_clause -> . USE TYPE name_s SEMICOLON
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s COMMA def_id
    (26) def_id -> . IDENTIFIER

    PACKAGE         shift and go to state 105
    PROCEDURE       shift and go to state 30
    FUNCTION        shift and go to state 36
    TYPE            shift and go to state 110
    WITH            shift and go to state 101
    error           shift and go to state 108
    USE             shift and go to state 46
    IDENTIFIER      shift and go to state 79

    param                          shift and go to state 102
    subprog_spec                   shift and go to state 103
    def_id_s                       shift and go to state 104
    def_id                         shift and go to state 96
    generic_formal                 shift and go to state 106
    use_clause                     shift and go to state 107
    pkg_spec                       shift and go to state 109

state 34

    (334) pkg_decl -> generic_pkg_inst . SEMICOLON

    SEMICOLON       shift and go to state 111


state 35

    (440) unit -> pkg_body .

    PRIVATE         reduce using rule 440 (unit -> pkg_body .)
    WITH            reduce using rule 440 (unit -> pkg_body .)
    PACKAGE         reduce using rule 440 (unit -> pkg_body .)
    SEPARATE        reduce using rule 440 (unit -> pkg_body .)
    PROCEDURE       reduce using rule 440 (unit -> pkg_body .)
    FUNCTION        reduce using rule 440 (unit -> pkg_body .)
    GENERIC         reduce using rule 440 (unit -> pkg_body .)
    $end            reduce using rule 440 (unit -> pkg_body .)


state 36

    (314) subprog_spec -> FUNCTION . designator formal_part_opt RETURN name
    (315) subprog_spec -> FUNCTION . designator
    (316) designator -> . compound_name
    (317) designator -> . STRING
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name DOT simple_name
    (161) simple_name -> . IDENTIFIER

    STRING          shift and go to state 114
    IDENTIFIER      shift and go to state 40

    compound_name                  shift and go to state 113
    designator                     shift and go to state 112
    simple_name                    shift and go to state 41

state 37

    (333) pkg_decl -> pkg_spec . SEMICOLON

    SEMICOLON       shift and go to state 115


state 38

    (436) with_clause -> WITH c_name_list . SEMICOLON
    (165) c_name_list -> c_name_list . COMMA compound_name

    SEMICOLON       shift and go to state 117
    COMMA           shift and go to state 116


state 39

    (164) c_name_list -> compound_name .
    (163) compound_name -> compound_name . DOT simple_name

    SEMICOLON       reduce using rule 164 (c_name_list -> compound_name .)
    COMMA           reduce using rule 164 (c_name_list -> compound_name .)
    DOT             shift and go to state 118


state 40

    (161) simple_name -> IDENTIFIER .

    TICK            reduce using rule 161 (simple_name -> IDENTIFIER .)
    LPAREN          reduce using rule 161 (simple_name -> IDENTIFIER .)
    DOT             reduce using rule 161 (simple_name -> IDENTIFIER .)
    RANGE           reduce using rule 161 (simple_name -> IDENTIFIER .)
    POW             reduce using rule 161 (simple_name -> IDENTIFIER .)
    TIMES           reduce using rule 161 (simple_name -> IDENTIFIER .)
    DIVIDE          reduce using rule 161 (simple_name -> IDENTIFIER .)
    MOD             reduce using rule 161 (simple_name -> IDENTIFIER .)
    REM             reduce using rule 161 (simple_name -> IDENTIFIER .)
    DOUBLEDOT       reduce using rule 161 (simple_name -> IDENTIFIER .)
    EQ              reduce using rule 161 (simple_name -> IDENTIFIER .)
    NE              reduce using rule 161 (simple_name -> IDENTIFIER .)
    LT              reduce using rule 161 (simple_name -> IDENTIFIER .)
    LE              reduce using rule 161 (simple_name -> IDENTIFIER .)
    GT              reduce using rule 161 (simple_name -> IDENTIFIER .)
    GE              reduce using rule 161 (simple_name -> IDENTIFIER .)
    IN              reduce using rule 161 (simple_name -> IDENTIFIER .)
    NOT             reduce using rule 161 (simple_name -> IDENTIFIER .)
    PLUS            reduce using rule 161 (simple_name -> IDENTIFIER .)
    MINUS           reduce using rule 161 (simple_name -> IDENTIFIER .)
    AMPERSAND       reduce using rule 161 (simple_name -> IDENTIFIER .)
    AND             reduce using rule 161 (simple_name -> IDENTIFIER .)
    OR              reduce using rule 161 (simple_name -> IDENTIFIER .)
    XOR             reduce using rule 161 (simple_name -> IDENTIFIER .)
    RPAREN          reduce using rule 161 (simple_name -> IDENTIFIER .)
    COMMA           reduce using rule 161 (simple_name -> IDENTIFIER .)
    ARROW           reduce using rule 161 (simple_name -> IDENTIFIER .)
    |               reduce using rule 161 (simple_name -> IDENTIFIER .)
    IS              reduce using rule 161 (simple_name -> IDENTIFIER .)
    SEMICOLON       reduce using rule 161 (simple_name -> IDENTIFIER .)
    WITH            reduce using rule 161 (simple_name -> IDENTIFIER .)
    THEN            reduce using rule 161 (simple_name -> IDENTIFIER .)
    LOOP            reduce using rule 161 (simple_name -> IDENTIFIER .)
    DIGITS          reduce using rule 161 (simple_name -> IDENTIFIER .)
    RENAMES         reduce using rule 161 (simple_name -> IDENTIFIER .)
    IS_ASSIGNED     reduce using rule 161 (simple_name -> IDENTIFIER .)
    WHEN            reduce using rule 161 (simple_name -> IDENTIFIER .)
    RETURN          reduce using rule 161 (simple_name -> IDENTIFIER .)
    DO              reduce using rule 161 (simple_name -> IDENTIFIER .)
    USE             reduce using rule 161 (simple_name -> IDENTIFIER .)
    AT              reduce using rule 161 (simple_name -> IDENTIFIER .)


state 41

    (162) compound_name -> simple_name .

    IS              reduce using rule 162 (compound_name -> simple_name .)
    DOT             reduce using rule 162 (compound_name -> simple_name .)
    SEMICOLON       reduce using rule 162 (compound_name -> simple_name .)
    COMMA           reduce using rule 162 (compound_name -> simple_name .)
    RENAMES         reduce using rule 162 (compound_name -> simple_name .)
    LPAREN          reduce using rule 162 (compound_name -> simple_name .)
    RETURN          reduce using rule 162 (compound_name -> simple_name .)
    RPAREN          reduce using rule 162 (compound_name -> simple_name .)


state 42

    (2) pragma -> PRAGMA IDENTIFIER SEMICOLON .

    error           reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)
    USE             reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)
    PRAGMA          reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)
    TYPE            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)
    SUBTYPE         reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)
    TASK            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)
    PACKAGE         reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)
    PROTECTED       reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)
    FOR             reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)
    PROCEDURE       reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)
    FUNCTION        reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)
    GENERIC         reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)
    IDENTIFIER      reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)
    PRIVATE         reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)
    END             reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)
    ENTRY           reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)
    BEGIN           reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)
    LLB             reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)
    NULL            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)
    EXIT            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)
    RETURN          reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)
    GOTO            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)
    DELAY           reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)
    ABORT           reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)
    RAISE           reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)
    REQUEUE         reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)
    IF              reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)
    CASE            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)
    ACCEPT          reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)
    SELECT          reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)
    STRING          reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)
    WHILE           reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)
    DECLARE         reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)
    LOOP            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)
    WITH            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)
    SEPARATE        reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)
    $end            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)
    OR              reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)
    ELSE            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)
    ELSIF           reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)
    WHEN            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)
    THEN            reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)
    EXCEPTION       reduce using rule 2 (pragma -> PRAGMA IDENTIFIER SEMICOLON .)


state 43

    (3) pragma -> PRAGMA simple_name LPAREN . pragma_arg_s RPAREN SEMICOLON
    (4) pragma_arg_s -> . pragma_arg
    (5) pragma_arg_s -> . pragma_arg_s COMMA pragma_arg
    (6) pragma_arg -> . expression
    (7) pragma_arg -> . simple_name ARROW expression
    (195) expression -> . relation
    (196) expression -> . expression logical relation
    (197) expression -> . expression short_circuit relation
    (161) simple_name -> . IDENTIFIER
    (203) relation -> . simple_expression
    (204) relation -> . simple_expression relational simple_expression
    (205) relation -> . simple_expression membership range
    (206) relation -> . simple_expression membership name
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 40
    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122
    STRING          shift and go to state 137

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    pragma_arg                     shift and go to state 124
    unary                          shift and go to state 125
    relation                       shift and go to state 127
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 133
    literal                        shift and go to state 135
    factor                         shift and go to state 136
    pragma_arg_s                   shift and go to state 139
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    used_char                      shift and go to state 143
    term                           shift and go to state 144
    name                           shift and go to state 145
    operator_symbol                shift and go to state 146
    expression                     shift and go to state 149

state 44

    (434) context_spec -> context_spec with_clause use_clause_opt .
    (438) use_clause_opt -> use_clause_opt . use_clause
    (346) use_clause -> . USE name_s SEMICOLON
    (347) use_clause -> . USE TYPE name_s SEMICOLON

    PRIVATE         reduce using rule 434 (context_spec -> context_spec with_clause use_clause_opt .)
    WITH            reduce using rule 434 (context_spec -> context_spec with_clause use_clause_opt .)
    PRAGMA          reduce using rule 434 (context_spec -> context_spec with_clause use_clause_opt .)
    PACKAGE         reduce using rule 434 (context_spec -> context_spec with_clause use_clause_opt .)
    SEPARATE        reduce using rule 434 (context_spec -> context_spec with_clause use_clause_opt .)
    PROCEDURE       reduce using rule 434 (context_spec -> context_spec with_clause use_clause_opt .)
    FUNCTION        reduce using rule 434 (context_spec -> context_spec with_clause use_clause_opt .)
    GENERIC         reduce using rule 434 (context_spec -> context_spec with_clause use_clause_opt .)
    USE             shift and go to state 46

    use_clause                     shift and go to state 47

state 45

    (429) comp_unit -> context_spec private_opt unit .

    PRIVATE         reduce using rule 429 (comp_unit -> context_spec private_opt unit .)
    WITH            reduce using rule 429 (comp_unit -> context_spec private_opt unit .)
    PACKAGE         reduce using rule 429 (comp_unit -> context_spec private_opt unit .)
    SEPARATE        reduce using rule 429 (comp_unit -> context_spec private_opt unit .)
    PROCEDURE       reduce using rule 429 (comp_unit -> context_spec private_opt unit .)
    FUNCTION        reduce using rule 429 (comp_unit -> context_spec private_opt unit .)
    GENERIC         reduce using rule 429 (comp_unit -> context_spec private_opt unit .)
    $end            reduce using rule 429 (comp_unit -> context_spec private_opt unit .)


state 46

    (346) use_clause -> USE . name_s SEMICOLON
    (347) use_clause -> USE . TYPE name_s SEMICOLON
    (348) name_s -> . name
    (349) name_s -> . name_s COMMA name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    TYPE            shift and go to state 152
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    name_s                         shift and go to state 150
    name                           shift and go to state 151
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 146
    indexed_comp                   shift and go to state 119
    simple_name                    shift and go to state 153

state 47

    (438) use_clause_opt -> use_clause_opt use_clause .

    USE             reduce using rule 438 (use_clause_opt -> use_clause_opt use_clause .)
    PRIVATE         reduce using rule 438 (use_clause_opt -> use_clause_opt use_clause .)
    WITH            reduce using rule 438 (use_clause_opt -> use_clause_opt use_clause .)
    PRAGMA          reduce using rule 438 (use_clause_opt -> use_clause_opt use_clause .)
    PACKAGE         reduce using rule 438 (use_clause_opt -> use_clause_opt use_clause .)
    SEPARATE        reduce using rule 438 (use_clause_opt -> use_clause_opt use_clause .)
    PROCEDURE       reduce using rule 438 (use_clause_opt -> use_clause_opt use_clause .)
    FUNCTION        reduce using rule 438 (use_clause_opt -> use_clause_opt use_clause .)
    GENERIC         reduce using rule 438 (use_clause_opt -> use_clause_opt use_clause .)


state 48

    (446) subunit -> SEPARATE LPAREN . compound_name RPAREN subunit_body
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name DOT simple_name
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 40

    compound_name                  shift and go to state 154
    simple_name                    shift and go to state 41

state 49

    (310) subprog_decl -> subprog_spec SEMICOLON .

    PRIVATE         reduce using rule 310 (subprog_decl -> subprog_spec SEMICOLON .)
    WITH            reduce using rule 310 (subprog_decl -> subprog_spec SEMICOLON .)
    PACKAGE         reduce using rule 310 (subprog_decl -> subprog_spec SEMICOLON .)
    SEPARATE        reduce using rule 310 (subprog_decl -> subprog_spec SEMICOLON .)
    PROCEDURE       reduce using rule 310 (subprog_decl -> subprog_spec SEMICOLON .)
    FUNCTION        reduce using rule 310 (subprog_decl -> subprog_spec SEMICOLON .)
    GENERIC         reduce using rule 310 (subprog_decl -> subprog_spec SEMICOLON .)
    $end            reduce using rule 310 (subprog_decl -> subprog_spec SEMICOLON .)
    error           reduce using rule 310 (subprog_decl -> subprog_spec SEMICOLON .)
    USE             reduce using rule 310 (subprog_decl -> subprog_spec SEMICOLON .)
    PRAGMA          reduce using rule 310 (subprog_decl -> subprog_spec SEMICOLON .)
    TYPE            reduce using rule 310 (subprog_decl -> subprog_spec SEMICOLON .)
    SUBTYPE         reduce using rule 310 (subprog_decl -> subprog_spec SEMICOLON .)
    TASK            reduce using rule 310 (subprog_decl -> subprog_spec SEMICOLON .)
    PROTECTED       reduce using rule 310 (subprog_decl -> subprog_spec SEMICOLON .)
    FOR             reduce using rule 310 (subprog_decl -> subprog_spec SEMICOLON .)
    IDENTIFIER      reduce using rule 310 (subprog_decl -> subprog_spec SEMICOLON .)
    END             reduce using rule 310 (subprog_decl -> subprog_spec SEMICOLON .)
    BEGIN           reduce using rule 310 (subprog_decl -> subprog_spec SEMICOLON .)


state 50

    (354) rename_unit -> subprog_spec renames . SEMICOLON

    SEMICOLON       shift and go to state 155


state 51

    (357) renames -> RENAMES . name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    name                           shift and go to state 156
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 146
    indexed_comp                   shift and go to state 119
    simple_name                    shift and go to state 153

state 52

    (497) generic_subp_inst -> subprog_spec IS . generic_inst
    (330) subprog_spec_is_push -> subprog_spec IS .
    (499) generic_inst -> . NEW name

    ABSTRACT        reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    PACKAGE         reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    TASK            reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    PROTECTED       reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    error           reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    USE             reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    PRAGMA          reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    TYPE            reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    SUBTYPE         reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    FOR             reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    PROCEDURE       reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    FUNCTION        reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    GENERIC         reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    IDENTIFIER      reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    BEGIN           reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    NEW             shift and go to state 157

    generic_inst                   shift and go to state 158

state 53

    (340) pkg_body -> PACKAGE BODY . compound_name IS decl_part body_opt END c_id_opt SEMICOLON
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name DOT simple_name
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 40

    compound_name                  shift and go to state 159
    simple_name                    shift and go to state 41

state 54

    (353) rename_unit -> PACKAGE compound_name . renames SEMICOLON
    (335) pkg_spec -> PACKAGE compound_name . IS decl_item_s private_part END c_id_opt
    (498) generic_pkg_inst -> PACKAGE compound_name . IS generic_inst
    (163) compound_name -> compound_name . DOT simple_name
    (357) renames -> . RENAMES name

    IS              shift and go to state 161
    DOT             shift and go to state 118
    RENAMES         shift and go to state 51

    renames                        shift and go to state 160

state 55

    (311) subprog_decl -> generic_subp_inst SEMICOLON .

    PRIVATE         reduce using rule 311 (subprog_decl -> generic_subp_inst SEMICOLON .)
    WITH            reduce using rule 311 (subprog_decl -> generic_subp_inst SEMICOLON .)
    PACKAGE         reduce using rule 311 (subprog_decl -> generic_subp_inst SEMICOLON .)
    SEPARATE        reduce using rule 311 (subprog_decl -> generic_subp_inst SEMICOLON .)
    PROCEDURE       reduce using rule 311 (subprog_decl -> generic_subp_inst SEMICOLON .)
    FUNCTION        reduce using rule 311 (subprog_decl -> generic_subp_inst SEMICOLON .)
    GENERIC         reduce using rule 311 (subprog_decl -> generic_subp_inst SEMICOLON .)
    $end            reduce using rule 311 (subprog_decl -> generic_subp_inst SEMICOLON .)
    error           reduce using rule 311 (subprog_decl -> generic_subp_inst SEMICOLON .)
    USE             reduce using rule 311 (subprog_decl -> generic_subp_inst SEMICOLON .)
    PRAGMA          reduce using rule 311 (subprog_decl -> generic_subp_inst SEMICOLON .)
    TYPE            reduce using rule 311 (subprog_decl -> generic_subp_inst SEMICOLON .)
    SUBTYPE         reduce using rule 311 (subprog_decl -> generic_subp_inst SEMICOLON .)
    TASK            reduce using rule 311 (subprog_decl -> generic_subp_inst SEMICOLON .)
    PROTECTED       reduce using rule 311 (subprog_decl -> generic_subp_inst SEMICOLON .)
    FOR             reduce using rule 311 (subprog_decl -> generic_subp_inst SEMICOLON .)
    IDENTIFIER      reduce using rule 311 (subprog_decl -> generic_subp_inst SEMICOLON .)
    END             reduce using rule 311 (subprog_decl -> generic_subp_inst SEMICOLON .)
    BEGIN           reduce using rule 311 (subprog_decl -> generic_subp_inst SEMICOLON .)


state 56

    (313) subprog_spec -> PROCEDURE compound_name . formal_part_opt
    (163) compound_name -> compound_name . DOT simple_name
    (318) formal_part_opt -> .
    (319) formal_part_opt -> . formal_part
    (320) formal_part -> . LPAREN param_s RPAREN

    DOT             shift and go to state 118
    SEMICOLON       reduce using rule 318 (formal_part_opt -> .)
    IS              reduce using rule 318 (formal_part_opt -> .)
    RENAMES         reduce using rule 318 (formal_part_opt -> .)
    LPAREN          shift and go to state 164

    formal_part                    shift and go to state 162
    formal_part_opt                shift and go to state 163

state 57

    (141) decl_item -> decl .

    PACKAGE         reduce using rule 141 (decl_item -> decl .)
    TASK            reduce using rule 141 (decl_item -> decl .)
    PROTECTED       reduce using rule 141 (decl_item -> decl .)
    error           reduce using rule 141 (decl_item -> decl .)
    USE             reduce using rule 141 (decl_item -> decl .)
    PRAGMA          reduce using rule 141 (decl_item -> decl .)
    TYPE            reduce using rule 141 (decl_item -> decl .)
    SUBTYPE         reduce using rule 141 (decl_item -> decl .)
    FOR             reduce using rule 141 (decl_item -> decl .)
    PROCEDURE       reduce using rule 141 (decl_item -> decl .)
    FUNCTION        reduce using rule 141 (decl_item -> decl .)
    GENERIC         reduce using rule 141 (decl_item -> decl .)
    IDENTIFIER      reduce using rule 141 (decl_item -> decl .)
    BEGIN           reduce using rule 141 (decl_item -> decl .)
    END             reduce using rule 141 (decl_item -> decl .)
    PRIVATE         reduce using rule 141 (decl_item -> decl .)


state 58

    (382) prot_body -> PROTECTED . BODY simple_name IS prot_op_body_s END id_opt SEMICOLON
    (454) body_stub -> PROTECTED . BODY simple_name IS SEPARATE SEMICOLON
    (367) prot_spec -> PROTECTED . IDENTIFIER prot_def
    (368) prot_spec -> PROTECTED . TYPE simple_name discrim_part_opt prot_def

    BODY            shift and go to state 165
    IDENTIFIER      shift and go to state 166
    TYPE            shift and go to state 167


state 59

    (502) rep_spec -> address_spec .

    PACKAGE         reduce using rule 502 (rep_spec -> address_spec .)
    TASK            reduce using rule 502 (rep_spec -> address_spec .)
    PROTECTED       reduce using rule 502 (rep_spec -> address_spec .)
    error           reduce using rule 502 (rep_spec -> address_spec .)
    USE             reduce using rule 502 (rep_spec -> address_spec .)
    PRAGMA          reduce using rule 502 (rep_spec -> address_spec .)
    TYPE            reduce using rule 502 (rep_spec -> address_spec .)
    SUBTYPE         reduce using rule 502 (rep_spec -> address_spec .)
    FOR             reduce using rule 502 (rep_spec -> address_spec .)
    PROCEDURE       reduce using rule 502 (rep_spec -> address_spec .)
    FUNCTION        reduce using rule 502 (rep_spec -> address_spec .)
    GENERIC         reduce using rule 502 (rep_spec -> address_spec .)
    IDENTIFIER      reduce using rule 502 (rep_spec -> address_spec .)
    BEGIN           reduce using rule 502 (rep_spec -> address_spec .)
    PRIVATE         reduce using rule 502 (rep_spec -> address_spec .)
    END             reduce using rule 502 (rep_spec -> address_spec .)
    ENTRY           reduce using rule 502 (rep_spec -> address_spec .)


state 60

    (148) decl_item_or_body -> decl_item .

    PACKAGE         reduce using rule 148 (decl_item_or_body -> decl_item .)
    TASK            reduce using rule 148 (decl_item_or_body -> decl_item .)
    PROTECTED       reduce using rule 148 (decl_item_or_body -> decl_item .)
    error           reduce using rule 148 (decl_item_or_body -> decl_item .)
    USE             reduce using rule 148 (decl_item_or_body -> decl_item .)
    PRAGMA          reduce using rule 148 (decl_item_or_body -> decl_item .)
    TYPE            reduce using rule 148 (decl_item_or_body -> decl_item .)
    SUBTYPE         reduce using rule 148 (decl_item_or_body -> decl_item .)
    FOR             reduce using rule 148 (decl_item_or_body -> decl_item .)
    PROCEDURE       reduce using rule 148 (decl_item_or_body -> decl_item .)
    FUNCTION        reduce using rule 148 (decl_item_or_body -> decl_item .)
    GENERIC         reduce using rule 148 (decl_item_or_body -> decl_item .)
    IDENTIFIER      reduce using rule 148 (decl_item_or_body -> decl_item .)
    BEGIN           reduce using rule 148 (decl_item_or_body -> decl_item .)
    END             reduce using rule 148 (decl_item_or_body -> decl_item .)


state 61

    (331) subprog_body -> subprog_spec_is_push decl_part . block_body END id_opt SEMICOLON
    (298) block_body -> . BEGIN handled_stmt_s

    BEGIN           shift and go to state 168

    block_body                     shift and go to state 169

state 62

    (17) decl -> prot_decl .

    PACKAGE         reduce using rule 17 (decl -> prot_decl .)
    TASK            reduce using rule 17 (decl -> prot_decl .)
    PROTECTED       reduce using rule 17 (decl -> prot_decl .)
    error           reduce using rule 17 (decl -> prot_decl .)
    USE             reduce using rule 17 (decl -> prot_decl .)
    PRAGMA          reduce using rule 17 (decl -> prot_decl .)
    TYPE            reduce using rule 17 (decl -> prot_decl .)
    SUBTYPE         reduce using rule 17 (decl -> prot_decl .)
    FOR             reduce using rule 17 (decl -> prot_decl .)
    PROCEDURE       reduce using rule 17 (decl -> prot_decl .)
    FUNCTION        reduce using rule 17 (decl -> prot_decl .)
    GENERIC         reduce using rule 17 (decl -> prot_decl .)
    IDENTIFIER      reduce using rule 17 (decl -> prot_decl .)
    BEGIN           reduce using rule 17 (decl -> prot_decl .)
    END             reduce using rule 17 (decl -> prot_decl .)
    PRIVATE         reduce using rule 17 (decl -> prot_decl .)


state 63

    (12) decl -> type_decl .

    PACKAGE         reduce using rule 12 (decl -> type_decl .)
    TASK            reduce using rule 12 (decl -> type_decl .)
    PROTECTED       reduce using rule 12 (decl -> type_decl .)
    error           reduce using rule 12 (decl -> type_decl .)
    USE             reduce using rule 12 (decl -> type_decl .)
    PRAGMA          reduce using rule 12 (decl -> type_decl .)
    TYPE            reduce using rule 12 (decl -> type_decl .)
    SUBTYPE         reduce using rule 12 (decl -> type_decl .)
    FOR             reduce using rule 12 (decl -> type_decl .)
    PROCEDURE       reduce using rule 12 (decl -> type_decl .)
    FUNCTION        reduce using rule 12 (decl -> type_decl .)
    GENERIC         reduce using rule 12 (decl -> type_decl .)
    IDENTIFIER      reduce using rule 12 (decl -> type_decl .)
    BEGIN           reduce using rule 12 (decl -> type_decl .)
    END             reduce using rule 12 (decl -> type_decl .)
    PRIVATE         reduce using rule 12 (decl -> type_decl .)


state 64

    (15) decl -> pkg_decl .

    PACKAGE         reduce using rule 15 (decl -> pkg_decl .)
    TASK            reduce using rule 15 (decl -> pkg_decl .)
    PROTECTED       reduce using rule 15 (decl -> pkg_decl .)
    error           reduce using rule 15 (decl -> pkg_decl .)
    USE             reduce using rule 15 (decl -> pkg_decl .)
    PRAGMA          reduce using rule 15 (decl -> pkg_decl .)
    TYPE            reduce using rule 15 (decl -> pkg_decl .)
    SUBTYPE         reduce using rule 15 (decl -> pkg_decl .)
    FOR             reduce using rule 15 (decl -> pkg_decl .)
    PROCEDURE       reduce using rule 15 (decl -> pkg_decl .)
    FUNCTION        reduce using rule 15 (decl -> pkg_decl .)
    GENERIC         reduce using rule 15 (decl -> pkg_decl .)
    IDENTIFIER      reduce using rule 15 (decl -> pkg_decl .)
    BEGIN           reduce using rule 15 (decl -> pkg_decl .)
    END             reduce using rule 15 (decl -> pkg_decl .)
    PRIVATE         reduce using rule 15 (decl -> pkg_decl .)


state 65

    (14) decl -> subprog_decl .

    PACKAGE         reduce using rule 14 (decl -> subprog_decl .)
    TASK            reduce using rule 14 (decl -> subprog_decl .)
    PROTECTED       reduce using rule 14 (decl -> subprog_decl .)
    error           reduce using rule 14 (decl -> subprog_decl .)
    USE             reduce using rule 14 (decl -> subprog_decl .)
    PRAGMA          reduce using rule 14 (decl -> subprog_decl .)
    TYPE            reduce using rule 14 (decl -> subprog_decl .)
    SUBTYPE         reduce using rule 14 (decl -> subprog_decl .)
    FOR             reduce using rule 14 (decl -> subprog_decl .)
    PROCEDURE       reduce using rule 14 (decl -> subprog_decl .)
    FUNCTION        reduce using rule 14 (decl -> subprog_decl .)
    GENERIC         reduce using rule 14 (decl -> subprog_decl .)
    IDENTIFIER      reduce using rule 14 (decl -> subprog_decl .)
    BEGIN           reduce using rule 14 (decl -> subprog_decl .)
    END             reduce using rule 14 (decl -> subprog_decl .)
    PRIVATE         reduce using rule 14 (decl -> subprog_decl .)


state 66

    (149) body -> subprog_body .

    PACKAGE         reduce using rule 149 (body -> subprog_body .)
    TASK            reduce using rule 149 (body -> subprog_body .)
    PROTECTED       reduce using rule 149 (body -> subprog_body .)
    error           reduce using rule 149 (body -> subprog_body .)
    USE             reduce using rule 149 (body -> subprog_body .)
    PRAGMA          reduce using rule 149 (body -> subprog_body .)
    TYPE            reduce using rule 149 (body -> subprog_body .)
    SUBTYPE         reduce using rule 149 (body -> subprog_body .)
    FOR             reduce using rule 149 (body -> subprog_body .)
    PROCEDURE       reduce using rule 149 (body -> subprog_body .)
    FUNCTION        reduce using rule 149 (body -> subprog_body .)
    GENERIC         reduce using rule 149 (body -> subprog_body .)
    IDENTIFIER      reduce using rule 149 (body -> subprog_body .)
    BEGIN           reduce using rule 149 (body -> subprog_body .)
    END             reduce using rule 149 (body -> subprog_body .)


state 67

    (16) decl -> task_decl .

    PACKAGE         reduce using rule 16 (decl -> task_decl .)
    TASK            reduce using rule 16 (decl -> task_decl .)
    PROTECTED       reduce using rule 16 (decl -> task_decl .)
    error           reduce using rule 16 (decl -> task_decl .)
    USE             reduce using rule 16 (decl -> task_decl .)
    PRAGMA          reduce using rule 16 (decl -> task_decl .)
    TYPE            reduce using rule 16 (decl -> task_decl .)
    SUBTYPE         reduce using rule 16 (decl -> task_decl .)
    FOR             reduce using rule 16 (decl -> task_decl .)
    PROCEDURE       reduce using rule 16 (decl -> task_decl .)
    FUNCTION        reduce using rule 16 (decl -> task_decl .)
    GENERIC         reduce using rule 16 (decl -> task_decl .)
    IDENTIFIER      reduce using rule 16 (decl -> task_decl .)
    BEGIN           reduce using rule 16 (decl -> task_decl .)
    END             reduce using rule 16 (decl -> task_decl .)
    PRIVATE         reduce using rule 16 (decl -> task_decl .)


state 68

    (13) decl -> subtype_decl .

    PACKAGE         reduce using rule 13 (decl -> subtype_decl .)
    TASK            reduce using rule 13 (decl -> subtype_decl .)
    PROTECTED       reduce using rule 13 (decl -> subtype_decl .)
    error           reduce using rule 13 (decl -> subtype_decl .)
    USE             reduce using rule 13 (decl -> subtype_decl .)
    PRAGMA          reduce using rule 13 (decl -> subtype_decl .)
    TYPE            reduce using rule 13 (decl -> subtype_decl .)
    SUBTYPE         reduce using rule 13 (decl -> subtype_decl .)
    FOR             reduce using rule 13 (decl -> subtype_decl .)
    PROCEDURE       reduce using rule 13 (decl -> subtype_decl .)
    FUNCTION        reduce using rule 13 (decl -> subtype_decl .)
    GENERIC         reduce using rule 13 (decl -> subtype_decl .)
    IDENTIFIER      reduce using rule 13 (decl -> subtype_decl .)
    BEGIN           reduce using rule 13 (decl -> subtype_decl .)
    END             reduce using rule 13 (decl -> subtype_decl .)
    PRIVATE         reduce using rule 13 (decl -> subtype_decl .)


state 69

    (147) decl_item_or_body -> body .

    PACKAGE         reduce using rule 147 (decl_item_or_body -> body .)
    TASK            reduce using rule 147 (decl_item_or_body -> body .)
    PROTECTED       reduce using rule 147 (decl_item_or_body -> body .)
    error           reduce using rule 147 (decl_item_or_body -> body .)
    USE             reduce using rule 147 (decl_item_or_body -> body .)
    PRAGMA          reduce using rule 147 (decl_item_or_body -> body .)
    TYPE            reduce using rule 147 (decl_item_or_body -> body .)
    SUBTYPE         reduce using rule 147 (decl_item_or_body -> body .)
    FOR             reduce using rule 147 (decl_item_or_body -> body .)
    PROCEDURE       reduce using rule 147 (decl_item_or_body -> body .)
    FUNCTION        reduce using rule 147 (decl_item_or_body -> body .)
    GENERIC         reduce using rule 147 (decl_item_or_body -> body .)
    IDENTIFIER      reduce using rule 147 (decl_item_or_body -> body .)
    BEGIN           reduce using rule 147 (decl_item_or_body -> body .)
    END             reduce using rule 147 (decl_item_or_body -> body .)


state 70

    (503) attrib_def -> FOR . mark USE expression SEMICOLON
    (504) record_type_spec -> FOR . mark USE RECORD align_opt comp_loc_s END RECORD SEMICOLON
    (509) address_spec -> FOR . mark USE AT expression SEMICOLON
    (158) mark -> . simple_name
    (159) mark -> . mark TICK attribute_id
    (160) mark -> . mark DOT simple_name
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 40

    mark                           shift and go to state 170
    simple_name                    shift and go to state 171

state 71

    (10) decl -> object_decl .

    PACKAGE         reduce using rule 10 (decl -> object_decl .)
    TASK            reduce using rule 10 (decl -> object_decl .)
    PROTECTED       reduce using rule 10 (decl -> object_decl .)
    error           reduce using rule 10 (decl -> object_decl .)
    USE             reduce using rule 10 (decl -> object_decl .)
    PRAGMA          reduce using rule 10 (decl -> object_decl .)
    TYPE            reduce using rule 10 (decl -> object_decl .)
    SUBTYPE         reduce using rule 10 (decl -> object_decl .)
    FOR             reduce using rule 10 (decl -> object_decl .)
    PROCEDURE       reduce using rule 10 (decl -> object_decl .)
    FUNCTION        reduce using rule 10 (decl -> object_decl .)
    GENERIC         reduce using rule 10 (decl -> object_decl .)
    IDENTIFIER      reduce using rule 10 (decl -> object_decl .)
    BEGIN           reduce using rule 10 (decl -> object_decl .)
    END             reduce using rule 10 (decl -> object_decl .)
    PRIVATE         reduce using rule 10 (decl -> object_decl .)


state 72

    (358) task_decl -> task_spec . SEMICOLON

    SEMICOLON       shift and go to state 172


state 73

    (142) decl_item -> use_clause .

    PACKAGE         reduce using rule 142 (decl_item -> use_clause .)
    TASK            reduce using rule 142 (decl_item -> use_clause .)
    PROTECTED       reduce using rule 142 (decl_item -> use_clause .)
    error           reduce using rule 142 (decl_item -> use_clause .)
    USE             reduce using rule 142 (decl_item -> use_clause .)
    PRAGMA          reduce using rule 142 (decl_item -> use_clause .)
    TYPE            reduce using rule 142 (decl_item -> use_clause .)
    SUBTYPE         reduce using rule 142 (decl_item -> use_clause .)
    FOR             reduce using rule 142 (decl_item -> use_clause .)
    PROCEDURE       reduce using rule 142 (decl_item -> use_clause .)
    FUNCTION        reduce using rule 142 (decl_item -> use_clause .)
    GENERIC         reduce using rule 142 (decl_item -> use_clause .)
    IDENTIFIER      reduce using rule 142 (decl_item -> use_clause .)
    BEGIN           reduce using rule 142 (decl_item -> use_clause .)
    END             reduce using rule 142 (decl_item -> use_clause .)
    PRIVATE         reduce using rule 142 (decl_item -> use_clause .)


state 74

    (365) task_body -> TASK . BODY simple_name IS decl_part block_body END id_opt SEMICOLON
    (451) body_stub -> TASK . BODY simple_name IS SEPARATE SEMICOLON
    (359) task_spec -> TASK . simple_name task_def
    (360) task_spec -> TASK . TYPE simple_name discrim_part_opt task_def
    (161) simple_name -> . IDENTIFIER

    BODY            shift and go to state 173
    TYPE            shift and go to state 174
    IDENTIFIER      shift and go to state 40

    simple_name                    shift and go to state 175

state 75

    (501) rep_spec -> record_type_spec .

    PACKAGE         reduce using rule 501 (rep_spec -> record_type_spec .)
    TASK            reduce using rule 501 (rep_spec -> record_type_spec .)
    PROTECTED       reduce using rule 501 (rep_spec -> record_type_spec .)
    error           reduce using rule 501 (rep_spec -> record_type_spec .)
    USE             reduce using rule 501 (rep_spec -> record_type_spec .)
    PRAGMA          reduce using rule 501 (rep_spec -> record_type_spec .)
    TYPE            reduce using rule 501 (rep_spec -> record_type_spec .)
    SUBTYPE         reduce using rule 501 (rep_spec -> record_type_spec .)
    FOR             reduce using rule 501 (rep_spec -> record_type_spec .)
    PROCEDURE       reduce using rule 501 (rep_spec -> record_type_spec .)
    FUNCTION        reduce using rule 501 (rep_spec -> record_type_spec .)
    GENERIC         reduce using rule 501 (rep_spec -> record_type_spec .)
    IDENTIFIER      reduce using rule 501 (rep_spec -> record_type_spec .)
    BEGIN           reduce using rule 501 (rep_spec -> record_type_spec .)
    PRIVATE         reduce using rule 501 (rep_spec -> record_type_spec .)
    END             reduce using rule 501 (rep_spec -> record_type_spec .)
    ENTRY           reduce using rule 501 (rep_spec -> record_type_spec .)


state 76

    (20) decl -> generic_decl .

    PACKAGE         reduce using rule 20 (decl -> generic_decl .)
    TASK            reduce using rule 20 (decl -> generic_decl .)
    PROTECTED       reduce using rule 20 (decl -> generic_decl .)
    error           reduce using rule 20 (decl -> generic_decl .)
    USE             reduce using rule 20 (decl -> generic_decl .)
    PRAGMA          reduce using rule 20 (decl -> generic_decl .)
    TYPE            reduce using rule 20 (decl -> generic_decl .)
    SUBTYPE         reduce using rule 20 (decl -> generic_decl .)
    FOR             reduce using rule 20 (decl -> generic_decl .)
    PROCEDURE       reduce using rule 20 (decl -> generic_decl .)
    FUNCTION        reduce using rule 20 (decl -> generic_decl .)
    GENERIC         reduce using rule 20 (decl -> generic_decl .)
    IDENTIFIER      reduce using rule 20 (decl -> generic_decl .)
    BEGIN           reduce using rule 20 (decl -> generic_decl .)
    END             reduce using rule 20 (decl -> generic_decl .)
    PRIVATE         reduce using rule 20 (decl -> generic_decl .)


state 77

    (500) rep_spec -> attrib_def .

    PACKAGE         reduce using rule 500 (rep_spec -> attrib_def .)
    TASK            reduce using rule 500 (rep_spec -> attrib_def .)
    PROTECTED       reduce using rule 500 (rep_spec -> attrib_def .)
    error           reduce using rule 500 (rep_spec -> attrib_def .)
    USE             reduce using rule 500 (rep_spec -> attrib_def .)
    PRAGMA          reduce using rule 500 (rep_spec -> attrib_def .)
    TYPE            reduce using rule 500 (rep_spec -> attrib_def .)
    SUBTYPE         reduce using rule 500 (rep_spec -> attrib_def .)
    FOR             reduce using rule 500 (rep_spec -> attrib_def .)
    PROCEDURE       reduce using rule 500 (rep_spec -> attrib_def .)
    FUNCTION        reduce using rule 500 (rep_spec -> attrib_def .)
    GENERIC         reduce using rule 500 (rep_spec -> attrib_def .)
    IDENTIFIER      reduce using rule 500 (rep_spec -> attrib_def .)
    BEGIN           reduce using rule 500 (rep_spec -> attrib_def .)
    PRIVATE         reduce using rule 500 (rep_spec -> attrib_def .)
    END             reduce using rule 500 (rep_spec -> attrib_def .)
    ENTRY           reduce using rule 500 (rep_spec -> attrib_def .)


state 78

    (136) decl_part -> decl_item_or_body_s1 .
    (146) decl_item_or_body_s1 -> decl_item_or_body_s1 . decl_item_or_body
    (147) decl_item_or_body -> . body
    (148) decl_item_or_body -> . decl_item
    (149) body -> . subprog_body
    (150) body -> . pkg_body
    (151) body -> . task_body
    (152) body -> . prot_body
    (141) decl_item -> . decl
    (142) decl_item -> . use_clause
    (143) decl_item -> . rep_spec
    (144) decl_item -> . pragma
    (331) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt SEMICOLON
    (340) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt SEMICOLON
    (365) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt SEMICOLON
    (382) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt SEMICOLON
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error SEMICOLON
    (346) use_clause -> . USE name_s SEMICOLON
    (347) use_clause -> . USE TYPE name_s SEMICOLON
    (500) rep_spec -> . attrib_def
    (501) rep_spec -> . record_type_spec
    (502) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (330) subprog_spec_is_push -> . subprog_spec IS
    (23) object_decl -> . def_id_s COLON object_qualifier_opt object_subtype_def init_opt SEMICOLON
    (35) number_decl -> . def_id_s COLON CONSTANT IS_ASSIGNED expression SEMICOLON
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion SEMICOLON
    (48) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind SEMICOLON
    (310) subprog_decl -> . subprog_spec SEMICOLON
    (311) subprog_decl -> . generic_subp_inst SEMICOLON
    (312) subprog_decl -> . subprog_spec_is_push ABSTRACT SEMICOLON
    (333) pkg_decl -> . pkg_spec SEMICOLON
    (334) pkg_decl -> . generic_pkg_inst SEMICOLON
    (358) task_decl -> . task_spec SEMICOLON
    (366) prot_decl -> . prot_spec SEMICOLON
    (455) exception_decl -> . def_id_s COLON EXCEPTION SEMICOLON
    (350) rename_decl -> . def_id_s COLON object_qualifier_opt subtype_ind renames SEMICOLON
    (351) rename_decl -> . def_id_s COLON EXCEPTION renames SEMICOLON
    (352) rename_decl -> . rename_unit
    (467) generic_decl -> . generic_formal_part subprog_spec SEMICOLON
    (468) generic_decl -> . generic_formal_part pkg_spec SEMICOLON
    (451) body_stub -> . TASK BODY simple_name IS SEPARATE SEMICOLON
    (452) body_stub -> . PACKAGE BODY compound_name IS SEPARATE SEMICOLON
    (453) body_stub -> . subprog_spec IS SEPARATE SEMICOLON
    (454) body_stub -> . PROTECTED BODY simple_name IS SEPARATE SEMICOLON
    (503) attrib_def -> . FOR mark USE expression SEMICOLON
    (504) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD SEMICOLON
    (509) address_spec -> . FOR mark USE AT expression SEMICOLON
    (313) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (314) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (315) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s COMMA def_id
    (497) generic_subp_inst -> . subprog_spec IS generic_inst
    (335) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (498) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (359) task_spec -> . TASK simple_name task_def
    (360) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (367) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (368) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (353) rename_unit -> . PACKAGE compound_name renames SEMICOLON
    (354) rename_unit -> . subprog_spec renames SEMICOLON
    (355) rename_unit -> . generic_formal_part PACKAGE compound_name renames SEMICOLON
    (356) rename_unit -> . generic_formal_part subprog_spec renames SEMICOLON
    (469) generic_formal_part -> . GENERIC
    (470) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    BEGIN           reduce using rule 136 (decl_part -> decl_item_or_body_s1 .)
    END             reduce using rule 136 (decl_part -> decl_item_or_body_s1 .)
    PACKAGE         shift and go to state 80
    TASK            shift and go to state 74
    PROTECTED       shift and go to state 58
    error           shift and go to state 85
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 87
    SUBTYPE         shift and go to state 91
    FOR             shift and go to state 70
    PROCEDURE       shift and go to state 30
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 79

    decl                           shift and go to state 57
    subprog_body                   shift and go to state 66
    task_decl                      shift and go to state 67
    type_decl                      shift and go to state 63
    rep_spec                       shift and go to state 89
    task_body                      shift and go to state 90
    subtype_decl                   shift and go to state 68
    exception_decl                 shift and go to state 92
    address_spec                   shift and go to state 59
    subprog_spec_is_push           shift and go to state 93
    prot_decl                      shift and go to state 62
    record_type_spec               shift and go to state 75
    generic_decl                   shift and go to state 76
    def_id                         shift and go to state 96
    attrib_def                     shift and go to state 77
    subprog_spec                   shift and go to state 94
    def_id_s                       shift and go to state 95
    decl_item                      shift and go to state 60
    task_spec                      shift and go to state 72
    body                           shift and go to state 69
    object_decl                    shift and go to state 71
    body_stub                      shift and go to state 81
    pkg_spec                       shift and go to state 37
    rename_decl                    shift and go to state 97
    generic_subp_inst              shift and go to state 28
    pragma                         shift and go to state 82
    rename_unit                    shift and go to state 98
    subprog_decl                   shift and go to state 65
    pkg_decl                       shift and go to state 64
    prot_spec                      shift and go to state 83
    generic_formal_part            shift and go to state 33
    prot_body                      shift and go to state 99
    use_clause                     shift and go to state 73
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 84
    decl_item_or_body              shift and go to state 176
    number_decl                    shift and go to state 100

state 79

    (26) def_id -> IDENTIFIER .

    COLON           reduce using rule 26 (def_id -> IDENTIFIER .)
    COMMA           reduce using rule 26 (def_id -> IDENTIFIER .)


state 80

    (340) pkg_body -> PACKAGE . BODY compound_name IS decl_part body_opt END c_id_opt SEMICOLON
    (452) body_stub -> PACKAGE . BODY compound_name IS SEPARATE SEMICOLON
    (335) pkg_spec -> PACKAGE . compound_name IS decl_item_s private_part END c_id_opt
    (498) generic_pkg_inst -> PACKAGE . compound_name IS generic_inst
    (353) rename_unit -> PACKAGE . compound_name renames SEMICOLON
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name DOT simple_name
    (161) simple_name -> . IDENTIFIER

    BODY            shift and go to state 177
    IDENTIFIER      shift and go to state 40

    simple_name                    shift and go to state 41
    compound_name                  shift and go to state 178

state 81

    (21) decl -> body_stub .

    PACKAGE         reduce using rule 21 (decl -> body_stub .)
    TASK            reduce using rule 21 (decl -> body_stub .)
    PROTECTED       reduce using rule 21 (decl -> body_stub .)
    error           reduce using rule 21 (decl -> body_stub .)
    USE             reduce using rule 21 (decl -> body_stub .)
    PRAGMA          reduce using rule 21 (decl -> body_stub .)
    TYPE            reduce using rule 21 (decl -> body_stub .)
    SUBTYPE         reduce using rule 21 (decl -> body_stub .)
    FOR             reduce using rule 21 (decl -> body_stub .)
    PROCEDURE       reduce using rule 21 (decl -> body_stub .)
    FUNCTION        reduce using rule 21 (decl -> body_stub .)
    GENERIC         reduce using rule 21 (decl -> body_stub .)
    IDENTIFIER      reduce using rule 21 (decl -> body_stub .)
    BEGIN           reduce using rule 21 (decl -> body_stub .)
    END             reduce using rule 21 (decl -> body_stub .)
    PRIVATE         reduce using rule 21 (decl -> body_stub .)


state 82

    (144) decl_item -> pragma .

    PACKAGE         reduce using rule 144 (decl_item -> pragma .)
    TASK            reduce using rule 144 (decl_item -> pragma .)
    PROTECTED       reduce using rule 144 (decl_item -> pragma .)
    error           reduce using rule 144 (decl_item -> pragma .)
    USE             reduce using rule 144 (decl_item -> pragma .)
    PRAGMA          reduce using rule 144 (decl_item -> pragma .)
    TYPE            reduce using rule 144 (decl_item -> pragma .)
    SUBTYPE         reduce using rule 144 (decl_item -> pragma .)
    FOR             reduce using rule 144 (decl_item -> pragma .)
    PROCEDURE       reduce using rule 144 (decl_item -> pragma .)
    FUNCTION        reduce using rule 144 (decl_item -> pragma .)
    GENERIC         reduce using rule 144 (decl_item -> pragma .)
    IDENTIFIER      reduce using rule 144 (decl_item -> pragma .)
    BEGIN           reduce using rule 144 (decl_item -> pragma .)
    END             reduce using rule 144 (decl_item -> pragma .)
    PRIVATE         reduce using rule 144 (decl_item -> pragma .)


state 83

    (366) prot_decl -> prot_spec . SEMICOLON

    SEMICOLON       shift and go to state 179


state 84

    (150) body -> pkg_body .

    PACKAGE         reduce using rule 150 (body -> pkg_body .)
    TASK            reduce using rule 150 (body -> pkg_body .)
    PROTECTED       reduce using rule 150 (body -> pkg_body .)
    error           reduce using rule 150 (body -> pkg_body .)
    USE             reduce using rule 150 (body -> pkg_body .)
    PRAGMA          reduce using rule 150 (body -> pkg_body .)
    TYPE            reduce using rule 150 (body -> pkg_body .)
    SUBTYPE         reduce using rule 150 (body -> pkg_body .)
    FOR             reduce using rule 150 (body -> pkg_body .)
    PROCEDURE       reduce using rule 150 (body -> pkg_body .)
    FUNCTION        reduce using rule 150 (body -> pkg_body .)
    GENERIC         reduce using rule 150 (body -> pkg_body .)
    IDENTIFIER      reduce using rule 150 (body -> pkg_body .)
    BEGIN           reduce using rule 150 (body -> pkg_body .)
    END             reduce using rule 150 (body -> pkg_body .)


state 85

    (22) decl -> error . SEMICOLON

    SEMICOLON       shift and go to state 180


state 86

    (145) decl_item_or_body_s1 -> decl_item_or_body .

    PACKAGE         reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)
    TASK            reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)
    PROTECTED       reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)
    error           reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)
    USE             reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)
    PRAGMA          reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)
    TYPE            reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)
    SUBTYPE         reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)
    FOR             reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)
    PROCEDURE       reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)
    FUNCTION        reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)
    GENERIC         reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)
    IDENTIFIER      reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)
    BEGIN           reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)
    END             reduce using rule 145 (decl_item_or_body_s1 -> decl_item_or_body .)


state 87

    (36) type_decl -> TYPE . IDENTIFIER discrim_part_opt type_completion SEMICOLON

    IDENTIFIER      shift and go to state 181


state 88

    (312) subprog_decl -> subprog_spec_is_push ABSTRACT . SEMICOLON

    SEMICOLON       shift and go to state 182


state 89

    (143) decl_item -> rep_spec .

    PACKAGE         reduce using rule 143 (decl_item -> rep_spec .)
    TASK            reduce using rule 143 (decl_item -> rep_spec .)
    PROTECTED       reduce using rule 143 (decl_item -> rep_spec .)
    error           reduce using rule 143 (decl_item -> rep_spec .)
    USE             reduce using rule 143 (decl_item -> rep_spec .)
    PRAGMA          reduce using rule 143 (decl_item -> rep_spec .)
    TYPE            reduce using rule 143 (decl_item -> rep_spec .)
    SUBTYPE         reduce using rule 143 (decl_item -> rep_spec .)
    FOR             reduce using rule 143 (decl_item -> rep_spec .)
    PROCEDURE       reduce using rule 143 (decl_item -> rep_spec .)
    FUNCTION        reduce using rule 143 (decl_item -> rep_spec .)
    GENERIC         reduce using rule 143 (decl_item -> rep_spec .)
    IDENTIFIER      reduce using rule 143 (decl_item -> rep_spec .)
    BEGIN           reduce using rule 143 (decl_item -> rep_spec .)
    END             reduce using rule 143 (decl_item -> rep_spec .)
    PRIVATE         reduce using rule 143 (decl_item -> rep_spec .)


state 90

    (151) body -> task_body .

    PACKAGE         reduce using rule 151 (body -> task_body .)
    TASK            reduce using rule 151 (body -> task_body .)
    PROTECTED       reduce using rule 151 (body -> task_body .)
    error           reduce using rule 151 (body -> task_body .)
    USE             reduce using rule 151 (body -> task_body .)
    PRAGMA          reduce using rule 151 (body -> task_body .)
    TYPE            reduce using rule 151 (body -> task_body .)
    SUBTYPE         reduce using rule 151 (body -> task_body .)
    FOR             reduce using rule 151 (body -> task_body .)
    PROCEDURE       reduce using rule 151 (body -> task_body .)
    FUNCTION        reduce using rule 151 (body -> task_body .)
    GENERIC         reduce using rule 151 (body -> task_body .)
    IDENTIFIER      reduce using rule 151 (body -> task_body .)
    BEGIN           reduce using rule 151 (body -> task_body .)
    END             reduce using rule 151 (body -> task_body .)


state 91

    (48) subtype_decl -> SUBTYPE . IDENTIFIER IS subtype_ind SEMICOLON

    IDENTIFIER      shift and go to state 183


state 92

    (18) decl -> exception_decl .

    PACKAGE         reduce using rule 18 (decl -> exception_decl .)
    TASK            reduce using rule 18 (decl -> exception_decl .)
    PROTECTED       reduce using rule 18 (decl -> exception_decl .)
    error           reduce using rule 18 (decl -> exception_decl .)
    USE             reduce using rule 18 (decl -> exception_decl .)
    PRAGMA          reduce using rule 18 (decl -> exception_decl .)
    TYPE            reduce using rule 18 (decl -> exception_decl .)
    SUBTYPE         reduce using rule 18 (decl -> exception_decl .)
    FOR             reduce using rule 18 (decl -> exception_decl .)
    PROCEDURE       reduce using rule 18 (decl -> exception_decl .)
    FUNCTION        reduce using rule 18 (decl -> exception_decl .)
    GENERIC         reduce using rule 18 (decl -> exception_decl .)
    IDENTIFIER      reduce using rule 18 (decl -> exception_decl .)
    BEGIN           reduce using rule 18 (decl -> exception_decl .)
    END             reduce using rule 18 (decl -> exception_decl .)
    PRIVATE         reduce using rule 18 (decl -> exception_decl .)


state 93

    (331) subprog_body -> subprog_spec_is_push . decl_part block_body END id_opt SEMICOLON
    (312) subprog_decl -> subprog_spec_is_push . ABSTRACT SEMICOLON
    (135) decl_part -> .
    (136) decl_part -> . decl_item_or_body_s1
    (145) decl_item_or_body_s1 -> . decl_item_or_body
    (146) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (147) decl_item_or_body -> . body
    (148) decl_item_or_body -> . decl_item
    (149) body -> . subprog_body
    (150) body -> . pkg_body
    (151) body -> . task_body
    (152) body -> . prot_body
    (141) decl_item -> . decl
    (142) decl_item -> . use_clause
    (143) decl_item -> . rep_spec
    (144) decl_item -> . pragma
    (331) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt SEMICOLON
    (340) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt SEMICOLON
    (365) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt SEMICOLON
    (382) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt SEMICOLON
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error SEMICOLON
    (346) use_clause -> . USE name_s SEMICOLON
    (347) use_clause -> . USE TYPE name_s SEMICOLON
    (500) rep_spec -> . attrib_def
    (501) rep_spec -> . record_type_spec
    (502) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (330) subprog_spec_is_push -> . subprog_spec IS
    (23) object_decl -> . def_id_s COLON object_qualifier_opt object_subtype_def init_opt SEMICOLON
    (35) number_decl -> . def_id_s COLON CONSTANT IS_ASSIGNED expression SEMICOLON
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion SEMICOLON
    (48) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind SEMICOLON
    (310) subprog_decl -> . subprog_spec SEMICOLON
    (311) subprog_decl -> . generic_subp_inst SEMICOLON
    (312) subprog_decl -> . subprog_spec_is_push ABSTRACT SEMICOLON
    (333) pkg_decl -> . pkg_spec SEMICOLON
    (334) pkg_decl -> . generic_pkg_inst SEMICOLON
    (358) task_decl -> . task_spec SEMICOLON
    (366) prot_decl -> . prot_spec SEMICOLON
    (455) exception_decl -> . def_id_s COLON EXCEPTION SEMICOLON
    (350) rename_decl -> . def_id_s COLON object_qualifier_opt subtype_ind renames SEMICOLON
    (351) rename_decl -> . def_id_s COLON EXCEPTION renames SEMICOLON
    (352) rename_decl -> . rename_unit
    (467) generic_decl -> . generic_formal_part subprog_spec SEMICOLON
    (468) generic_decl -> . generic_formal_part pkg_spec SEMICOLON
    (451) body_stub -> . TASK BODY simple_name IS SEPARATE SEMICOLON
    (452) body_stub -> . PACKAGE BODY compound_name IS SEPARATE SEMICOLON
    (453) body_stub -> . subprog_spec IS SEPARATE SEMICOLON
    (454) body_stub -> . PROTECTED BODY simple_name IS SEPARATE SEMICOLON
    (503) attrib_def -> . FOR mark USE expression SEMICOLON
    (504) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD SEMICOLON
    (509) address_spec -> . FOR mark USE AT expression SEMICOLON
    (313) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (314) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (315) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s COMMA def_id
    (497) generic_subp_inst -> . subprog_spec IS generic_inst
    (335) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (498) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (359) task_spec -> . TASK simple_name task_def
    (360) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (367) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (368) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (353) rename_unit -> . PACKAGE compound_name renames SEMICOLON
    (354) rename_unit -> . subprog_spec renames SEMICOLON
    (355) rename_unit -> . generic_formal_part PACKAGE compound_name renames SEMICOLON
    (356) rename_unit -> . generic_formal_part subprog_spec renames SEMICOLON
    (469) generic_formal_part -> . GENERIC
    (470) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    ABSTRACT        shift and go to state 88
    BEGIN           reduce using rule 135 (decl_part -> .)
    PACKAGE         shift and go to state 80
    TASK            shift and go to state 74
    PROTECTED       shift and go to state 58
    error           shift and go to state 85
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 87
    SUBTYPE         shift and go to state 91
    FOR             shift and go to state 70
    PROCEDURE       shift and go to state 30
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 79

    decl                           shift and go to state 57
    subprog_body                   shift and go to state 66
    task_decl                      shift and go to state 67
    type_decl                      shift and go to state 63
    rep_spec                       shift and go to state 89
    task_body                      shift and go to state 90
    subtype_decl                   shift and go to state 68
    exception_decl                 shift and go to state 92
    address_spec                   shift and go to state 59
    subprog_spec_is_push           shift and go to state 93
    decl_part                      shift and go to state 61
    prot_decl                      shift and go to state 62
    record_type_spec               shift and go to state 75
    generic_decl                   shift and go to state 76
    def_id                         shift and go to state 96
    attrib_def                     shift and go to state 77
    subprog_spec                   shift and go to state 94
    def_id_s                       shift and go to state 95
    decl_item_or_body_s1           shift and go to state 78
    decl_item                      shift and go to state 60
    task_spec                      shift and go to state 72
    body                           shift and go to state 69
    object_decl                    shift and go to state 71
    body_stub                      shift and go to state 81
    pkg_spec                       shift and go to state 37
    rename_decl                    shift and go to state 97
    generic_subp_inst              shift and go to state 28
    pragma                         shift and go to state 82
    rename_unit                    shift and go to state 98
    subprog_decl                   shift and go to state 65
    pkg_decl                       shift and go to state 64
    prot_spec                      shift and go to state 83
    generic_formal_part            shift and go to state 33
    prot_body                      shift and go to state 99
    use_clause                     shift and go to state 73
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 84
    decl_item_or_body              shift and go to state 86
    number_decl                    shift and go to state 100

state 94

    (330) subprog_spec_is_push -> subprog_spec . IS
    (310) subprog_decl -> subprog_spec . SEMICOLON
    (453) body_stub -> subprog_spec . IS SEPARATE SEMICOLON
    (497) generic_subp_inst -> subprog_spec . IS generic_inst
    (354) rename_unit -> subprog_spec . renames SEMICOLON
    (357) renames -> . RENAMES name

    IS              shift and go to state 184
    SEMICOLON       shift and go to state 49
    RENAMES         shift and go to state 51

    renames                        shift and go to state 50

state 95

    (23) object_decl -> def_id_s . COLON object_qualifier_opt object_subtype_def init_opt SEMICOLON
    (35) number_decl -> def_id_s . COLON CONSTANT IS_ASSIGNED expression SEMICOLON
    (455) exception_decl -> def_id_s . COLON EXCEPTION SEMICOLON
    (350) rename_decl -> def_id_s . COLON object_qualifier_opt subtype_ind renames SEMICOLON
    (351) rename_decl -> def_id_s . COLON EXCEPTION renames SEMICOLON
    (25) def_id_s -> def_id_s . COMMA def_id

    COLON           shift and go to state 185
    COMMA           shift and go to state 186


state 96

    (24) def_id_s -> def_id .

    COLON           reduce using rule 24 (def_id_s -> def_id .)
    COMMA           reduce using rule 24 (def_id_s -> def_id .)


state 97

    (19) decl -> rename_decl .

    PACKAGE         reduce using rule 19 (decl -> rename_decl .)
    TASK            reduce using rule 19 (decl -> rename_decl .)
    PROTECTED       reduce using rule 19 (decl -> rename_decl .)
    error           reduce using rule 19 (decl -> rename_decl .)
    USE             reduce using rule 19 (decl -> rename_decl .)
    PRAGMA          reduce using rule 19 (decl -> rename_decl .)
    TYPE            reduce using rule 19 (decl -> rename_decl .)
    SUBTYPE         reduce using rule 19 (decl -> rename_decl .)
    FOR             reduce using rule 19 (decl -> rename_decl .)
    PROCEDURE       reduce using rule 19 (decl -> rename_decl .)
    FUNCTION        reduce using rule 19 (decl -> rename_decl .)
    GENERIC         reduce using rule 19 (decl -> rename_decl .)
    IDENTIFIER      reduce using rule 19 (decl -> rename_decl .)
    BEGIN           reduce using rule 19 (decl -> rename_decl .)
    END             reduce using rule 19 (decl -> rename_decl .)
    PRIVATE         reduce using rule 19 (decl -> rename_decl .)


state 98

    (352) rename_decl -> rename_unit .

    error           reduce using rule 352 (rename_decl -> rename_unit .)
    USE             reduce using rule 352 (rename_decl -> rename_unit .)
    PRAGMA          reduce using rule 352 (rename_decl -> rename_unit .)
    TYPE            reduce using rule 352 (rename_decl -> rename_unit .)
    SUBTYPE         reduce using rule 352 (rename_decl -> rename_unit .)
    TASK            reduce using rule 352 (rename_decl -> rename_unit .)
    PACKAGE         reduce using rule 352 (rename_decl -> rename_unit .)
    PROTECTED       reduce using rule 352 (rename_decl -> rename_unit .)
    FOR             reduce using rule 352 (rename_decl -> rename_unit .)
    PROCEDURE       reduce using rule 352 (rename_decl -> rename_unit .)
    FUNCTION        reduce using rule 352 (rename_decl -> rename_unit .)
    GENERIC         reduce using rule 352 (rename_decl -> rename_unit .)
    IDENTIFIER      reduce using rule 352 (rename_decl -> rename_unit .)
    PRIVATE         reduce using rule 352 (rename_decl -> rename_unit .)
    END             reduce using rule 352 (rename_decl -> rename_unit .)
    BEGIN           reduce using rule 352 (rename_decl -> rename_unit .)


state 99

    (152) body -> prot_body .

    PACKAGE         reduce using rule 152 (body -> prot_body .)
    TASK            reduce using rule 152 (body -> prot_body .)
    PROTECTED       reduce using rule 152 (body -> prot_body .)
    error           reduce using rule 152 (body -> prot_body .)
    USE             reduce using rule 152 (body -> prot_body .)
    PRAGMA          reduce using rule 152 (body -> prot_body .)
    TYPE            reduce using rule 152 (body -> prot_body .)
    SUBTYPE         reduce using rule 152 (body -> prot_body .)
    FOR             reduce using rule 152 (body -> prot_body .)
    PROCEDURE       reduce using rule 152 (body -> prot_body .)
    FUNCTION        reduce using rule 152 (body -> prot_body .)
    GENERIC         reduce using rule 152 (body -> prot_body .)
    IDENTIFIER      reduce using rule 152 (body -> prot_body .)
    BEGIN           reduce using rule 152 (body -> prot_body .)
    END             reduce using rule 152 (body -> prot_body .)


state 100

    (11) decl -> number_decl .

    PACKAGE         reduce using rule 11 (decl -> number_decl .)
    TASK            reduce using rule 11 (decl -> number_decl .)
    PROTECTED       reduce using rule 11 (decl -> number_decl .)
    error           reduce using rule 11 (decl -> number_decl .)
    USE             reduce using rule 11 (decl -> number_decl .)
    PRAGMA          reduce using rule 11 (decl -> number_decl .)
    TYPE            reduce using rule 11 (decl -> number_decl .)
    SUBTYPE         reduce using rule 11 (decl -> number_decl .)
    FOR             reduce using rule 11 (decl -> number_decl .)
    PROCEDURE       reduce using rule 11 (decl -> number_decl .)
    FUNCTION        reduce using rule 11 (decl -> number_decl .)
    GENERIC         reduce using rule 11 (decl -> number_decl .)
    IDENTIFIER      reduce using rule 11 (decl -> number_decl .)
    BEGIN           reduce using rule 11 (decl -> number_decl .)
    END             reduce using rule 11 (decl -> number_decl .)
    PRIVATE         reduce using rule 11 (decl -> number_decl .)


state 101

    (473) generic_formal -> WITH . PROCEDURE simple_name formal_part_opt subp_default SEMICOLON
    (474) generic_formal -> WITH . FUNCTION designator formal_part_opt RETURN name subp_default SEMICOLON
    (475) generic_formal -> WITH . PACKAGE simple_name IS NEW name LPAREN BOX RPAREN SEMICOLON
    (476) generic_formal -> WITH . PACKAGE simple_name IS NEW name SEMICOLON

    PROCEDURE       shift and go to state 189
    FUNCTION        shift and go to state 187
    PACKAGE         shift and go to state 188


state 102

    (471) generic_formal -> param . SEMICOLON

    SEMICOLON       shift and go to state 190


state 103

    (467) generic_decl -> generic_formal_part subprog_spec . SEMICOLON
    (356) rename_unit -> generic_formal_part subprog_spec . renames SEMICOLON
    (357) renames -> . RENAMES name

    SEMICOLON       shift and go to state 191
    RENAMES         shift and go to state 51

    renames                        shift and go to state 192

state 104

    (323) param -> def_id_s . COLON mode mark init_opt
    (25) def_id_s -> def_id_s . COMMA def_id

    COLON           shift and go to state 193
    COMMA           shift and go to state 186


state 105

    (355) rename_unit -> generic_formal_part PACKAGE . compound_name renames SEMICOLON
    (335) pkg_spec -> PACKAGE . compound_name IS decl_item_s private_part END c_id_opt
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name DOT simple_name
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 40

    simple_name                    shift and go to state 41
    compound_name                  shift and go to state 194

state 106

    (470) generic_formal_part -> generic_formal_part generic_formal .

    PACKAGE         reduce using rule 470 (generic_formal_part -> generic_formal_part generic_formal .)
    PROCEDURE       reduce using rule 470 (generic_formal_part -> generic_formal_part generic_formal .)
    FUNCTION        reduce using rule 470 (generic_formal_part -> generic_formal_part generic_formal .)
    TYPE            reduce using rule 470 (generic_formal_part -> generic_formal_part generic_formal .)
    WITH            reduce using rule 470 (generic_formal_part -> generic_formal_part generic_formal .)
    error           reduce using rule 470 (generic_formal_part -> generic_formal_part generic_formal .)
    USE             reduce using rule 470 (generic_formal_part -> generic_formal_part generic_formal .)
    IDENTIFIER      reduce using rule 470 (generic_formal_part -> generic_formal_part generic_formal .)


state 107

    (477) generic_formal -> use_clause .

    PACKAGE         reduce using rule 477 (generic_formal -> use_clause .)
    PROCEDURE       reduce using rule 477 (generic_formal -> use_clause .)
    FUNCTION        reduce using rule 477 (generic_formal -> use_clause .)
    TYPE            reduce using rule 477 (generic_formal -> use_clause .)
    WITH            reduce using rule 477 (generic_formal -> use_clause .)
    error           reduce using rule 477 (generic_formal -> use_clause .)
    USE             reduce using rule 477 (generic_formal -> use_clause .)
    IDENTIFIER      reduce using rule 477 (generic_formal -> use_clause .)


state 108

    (324) param -> error .

    RPAREN          reduce using rule 324 (param -> error .)
    SEMICOLON       reduce using rule 324 (param -> error .)


state 109

    (468) generic_decl -> generic_formal_part pkg_spec . SEMICOLON

    SEMICOLON       shift and go to state 195


state 110

    (472) generic_formal -> TYPE . simple_name generic_discrim_part_opt IS generic_type_def SEMICOLON
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 40

    simple_name                    shift and go to state 196

state 111

    (334) pkg_decl -> generic_pkg_inst SEMICOLON .

    PACKAGE         reduce using rule 334 (pkg_decl -> generic_pkg_inst SEMICOLON .)
    TASK            reduce using rule 334 (pkg_decl -> generic_pkg_inst SEMICOLON .)
    PROTECTED       reduce using rule 334 (pkg_decl -> generic_pkg_inst SEMICOLON .)
    error           reduce using rule 334 (pkg_decl -> generic_pkg_inst SEMICOLON .)
    USE             reduce using rule 334 (pkg_decl -> generic_pkg_inst SEMICOLON .)
    PRAGMA          reduce using rule 334 (pkg_decl -> generic_pkg_inst SEMICOLON .)
    TYPE            reduce using rule 334 (pkg_decl -> generic_pkg_inst SEMICOLON .)
    SUBTYPE         reduce using rule 334 (pkg_decl -> generic_pkg_inst SEMICOLON .)
    FOR             reduce using rule 334 (pkg_decl -> generic_pkg_inst SEMICOLON .)
    PROCEDURE       reduce using rule 334 (pkg_decl -> generic_pkg_inst SEMICOLON .)
    FUNCTION        reduce using rule 334 (pkg_decl -> generic_pkg_inst SEMICOLON .)
    GENERIC         reduce using rule 334 (pkg_decl -> generic_pkg_inst SEMICOLON .)
    IDENTIFIER      reduce using rule 334 (pkg_decl -> generic_pkg_inst SEMICOLON .)
    BEGIN           reduce using rule 334 (pkg_decl -> generic_pkg_inst SEMICOLON .)
    PRIVATE         reduce using rule 334 (pkg_decl -> generic_pkg_inst SEMICOLON .)
    END             reduce using rule 334 (pkg_decl -> generic_pkg_inst SEMICOLON .)
    WITH            reduce using rule 334 (pkg_decl -> generic_pkg_inst SEMICOLON .)
    SEPARATE        reduce using rule 334 (pkg_decl -> generic_pkg_inst SEMICOLON .)
    $end            reduce using rule 334 (pkg_decl -> generic_pkg_inst SEMICOLON .)


state 112

    (314) subprog_spec -> FUNCTION designator . formal_part_opt RETURN name
    (315) subprog_spec -> FUNCTION designator .
    (318) formal_part_opt -> .
    (319) formal_part_opt -> . formal_part
    (320) formal_part -> . LPAREN param_s RPAREN

    SEMICOLON       reduce using rule 315 (subprog_spec -> FUNCTION designator .)
    IS              reduce using rule 315 (subprog_spec -> FUNCTION designator .)
    RENAMES         reduce using rule 315 (subprog_spec -> FUNCTION designator .)
    RETURN          reduce using rule 318 (formal_part_opt -> .)
    LPAREN          shift and go to state 164

    formal_part                    shift and go to state 162
    formal_part_opt                shift and go to state 197

state 113

    (316) designator -> compound_name .
    (163) compound_name -> compound_name . DOT simple_name

    LPAREN          reduce using rule 316 (designator -> compound_name .)
    RETURN          reduce using rule 316 (designator -> compound_name .)
    SEMICOLON       reduce using rule 316 (designator -> compound_name .)
    IS              reduce using rule 316 (designator -> compound_name .)
    RENAMES         reduce using rule 316 (designator -> compound_name .)
    DOT             shift and go to state 118


state 114

    (317) designator -> STRING .

    LPAREN          reduce using rule 317 (designator -> STRING .)
    RETURN          reduce using rule 317 (designator -> STRING .)
    SEMICOLON       reduce using rule 317 (designator -> STRING .)
    IS              reduce using rule 317 (designator -> STRING .)
    RENAMES         reduce using rule 317 (designator -> STRING .)


state 115

    (333) pkg_decl -> pkg_spec SEMICOLON .

    PACKAGE         reduce using rule 333 (pkg_decl -> pkg_spec SEMICOLON .)
    TASK            reduce using rule 333 (pkg_decl -> pkg_spec SEMICOLON .)
    PROTECTED       reduce using rule 333 (pkg_decl -> pkg_spec SEMICOLON .)
    error           reduce using rule 333 (pkg_decl -> pkg_spec SEMICOLON .)
    USE             reduce using rule 333 (pkg_decl -> pkg_spec SEMICOLON .)
    PRAGMA          reduce using rule 333 (pkg_decl -> pkg_spec SEMICOLON .)
    TYPE            reduce using rule 333 (pkg_decl -> pkg_spec SEMICOLON .)
    SUBTYPE         reduce using rule 333 (pkg_decl -> pkg_spec SEMICOLON .)
    FOR             reduce using rule 333 (pkg_decl -> pkg_spec SEMICOLON .)
    PROCEDURE       reduce using rule 333 (pkg_decl -> pkg_spec SEMICOLON .)
    FUNCTION        reduce using rule 333 (pkg_decl -> pkg_spec SEMICOLON .)
    GENERIC         reduce using rule 333 (pkg_decl -> pkg_spec SEMICOLON .)
    IDENTIFIER      reduce using rule 333 (pkg_decl -> pkg_spec SEMICOLON .)
    BEGIN           reduce using rule 333 (pkg_decl -> pkg_spec SEMICOLON .)
    PRIVATE         reduce using rule 333 (pkg_decl -> pkg_spec SEMICOLON .)
    END             reduce using rule 333 (pkg_decl -> pkg_spec SEMICOLON .)
    WITH            reduce using rule 333 (pkg_decl -> pkg_spec SEMICOLON .)
    SEPARATE        reduce using rule 333 (pkg_decl -> pkg_spec SEMICOLON .)
    $end            reduce using rule 333 (pkg_decl -> pkg_spec SEMICOLON .)


state 116

    (165) c_name_list -> c_name_list COMMA . compound_name
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name DOT simple_name
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 40

    compound_name                  shift and go to state 198
    simple_name                    shift and go to state 41

state 117

    (436) with_clause -> WITH c_name_list SEMICOLON .

    USE             reduce using rule 436 (with_clause -> WITH c_name_list SEMICOLON .)
    PRIVATE         reduce using rule 436 (with_clause -> WITH c_name_list SEMICOLON .)
    WITH            reduce using rule 436 (with_clause -> WITH c_name_list SEMICOLON .)
    PRAGMA          reduce using rule 436 (with_clause -> WITH c_name_list SEMICOLON .)
    PACKAGE         reduce using rule 436 (with_clause -> WITH c_name_list SEMICOLON .)
    SEPARATE        reduce using rule 436 (with_clause -> WITH c_name_list SEMICOLON .)
    PROCEDURE       reduce using rule 436 (with_clause -> WITH c_name_list SEMICOLON .)
    FUNCTION        reduce using rule 436 (with_clause -> WITH c_name_list SEMICOLON .)
    GENERIC         reduce using rule 436 (with_clause -> WITH c_name_list SEMICOLON .)


state 118

    (163) compound_name -> compound_name DOT . simple_name
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 40

    simple_name                    shift and go to state 199

state 119

    (154) name -> indexed_comp .

    IS_ASSIGNED     reduce using rule 154 (name -> indexed_comp .)
    SEMICOLON       reduce using rule 154 (name -> indexed_comp .)
    TICK            reduce using rule 154 (name -> indexed_comp .)
    LPAREN          reduce using rule 154 (name -> indexed_comp .)
    DOT             reduce using rule 154 (name -> indexed_comp .)
    RANGE           reduce using rule 154 (name -> indexed_comp .)
    POW             reduce using rule 154 (name -> indexed_comp .)
    TIMES           reduce using rule 154 (name -> indexed_comp .)
    DIVIDE          reduce using rule 154 (name -> indexed_comp .)
    MOD             reduce using rule 154 (name -> indexed_comp .)
    REM             reduce using rule 154 (name -> indexed_comp .)
    DOUBLEDOT       reduce using rule 154 (name -> indexed_comp .)
    EQ              reduce using rule 154 (name -> indexed_comp .)
    NE              reduce using rule 154 (name -> indexed_comp .)
    LT              reduce using rule 154 (name -> indexed_comp .)
    LE              reduce using rule 154 (name -> indexed_comp .)
    GT              reduce using rule 154 (name -> indexed_comp .)
    GE              reduce using rule 154 (name -> indexed_comp .)
    IN              reduce using rule 154 (name -> indexed_comp .)
    NOT             reduce using rule 154 (name -> indexed_comp .)
    PLUS            reduce using rule 154 (name -> indexed_comp .)
    MINUS           reduce using rule 154 (name -> indexed_comp .)
    AMPERSAND       reduce using rule 154 (name -> indexed_comp .)
    AND             reduce using rule 154 (name -> indexed_comp .)
    OR              reduce using rule 154 (name -> indexed_comp .)
    XOR             reduce using rule 154 (name -> indexed_comp .)
    RPAREN          reduce using rule 154 (name -> indexed_comp .)
    COMMA           reduce using rule 154 (name -> indexed_comp .)
    ARROW           reduce using rule 154 (name -> indexed_comp .)
    |               reduce using rule 154 (name -> indexed_comp .)
    IS              reduce using rule 154 (name -> indexed_comp .)
    RENAMES         reduce using rule 154 (name -> indexed_comp .)
    WHEN            reduce using rule 154 (name -> indexed_comp .)
    DIGITS          reduce using rule 154 (name -> indexed_comp .)
    WITH            reduce using rule 154 (name -> indexed_comp .)
    THEN            reduce using rule 154 (name -> indexed_comp .)
    LOOP            reduce using rule 154 (name -> indexed_comp .)


state 120

    (155) name -> selected_comp .

    IS_ASSIGNED     reduce using rule 155 (name -> selected_comp .)
    SEMICOLON       reduce using rule 155 (name -> selected_comp .)
    TICK            reduce using rule 155 (name -> selected_comp .)
    LPAREN          reduce using rule 155 (name -> selected_comp .)
    DOT             reduce using rule 155 (name -> selected_comp .)
    RANGE           reduce using rule 155 (name -> selected_comp .)
    POW             reduce using rule 155 (name -> selected_comp .)
    TIMES           reduce using rule 155 (name -> selected_comp .)
    DIVIDE          reduce using rule 155 (name -> selected_comp .)
    MOD             reduce using rule 155 (name -> selected_comp .)
    REM             reduce using rule 155 (name -> selected_comp .)
    DOUBLEDOT       reduce using rule 155 (name -> selected_comp .)
    EQ              reduce using rule 155 (name -> selected_comp .)
    NE              reduce using rule 155 (name -> selected_comp .)
    LT              reduce using rule 155 (name -> selected_comp .)
    LE              reduce using rule 155 (name -> selected_comp .)
    GT              reduce using rule 155 (name -> selected_comp .)
    GE              reduce using rule 155 (name -> selected_comp .)
    IN              reduce using rule 155 (name -> selected_comp .)
    NOT             reduce using rule 155 (name -> selected_comp .)
    PLUS            reduce using rule 155 (name -> selected_comp .)
    MINUS           reduce using rule 155 (name -> selected_comp .)
    AMPERSAND       reduce using rule 155 (name -> selected_comp .)
    AND             reduce using rule 155 (name -> selected_comp .)
    OR              reduce using rule 155 (name -> selected_comp .)
    XOR             reduce using rule 155 (name -> selected_comp .)
    RPAREN          reduce using rule 155 (name -> selected_comp .)
    COMMA           reduce using rule 155 (name -> selected_comp .)
    ARROW           reduce using rule 155 (name -> selected_comp .)
    |               reduce using rule 155 (name -> selected_comp .)
    IS              reduce using rule 155 (name -> selected_comp .)
    RENAMES         reduce using rule 155 (name -> selected_comp .)
    WHEN            reduce using rule 155 (name -> selected_comp .)
    DIGITS          reduce using rule 155 (name -> selected_comp .)
    WITH            reduce using rule 155 (name -> selected_comp .)
    THEN            reduce using rule 155 (name -> selected_comp .)
    LOOP            reduce using rule 155 (name -> selected_comp .)


state 121

    (156) name -> attribute .

    IS_ASSIGNED     reduce using rule 156 (name -> attribute .)
    SEMICOLON       reduce using rule 156 (name -> attribute .)
    TICK            reduce using rule 156 (name -> attribute .)
    LPAREN          reduce using rule 156 (name -> attribute .)
    DOT             reduce using rule 156 (name -> attribute .)
    RANGE           reduce using rule 156 (name -> attribute .)
    POW             reduce using rule 156 (name -> attribute .)
    TIMES           reduce using rule 156 (name -> attribute .)
    DIVIDE          reduce using rule 156 (name -> attribute .)
    MOD             reduce using rule 156 (name -> attribute .)
    REM             reduce using rule 156 (name -> attribute .)
    DOUBLEDOT       reduce using rule 156 (name -> attribute .)
    EQ              reduce using rule 156 (name -> attribute .)
    NE              reduce using rule 156 (name -> attribute .)
    LT              reduce using rule 156 (name -> attribute .)
    LE              reduce using rule 156 (name -> attribute .)
    GT              reduce using rule 156 (name -> attribute .)
    GE              reduce using rule 156 (name -> attribute .)
    IN              reduce using rule 156 (name -> attribute .)
    NOT             reduce using rule 156 (name -> attribute .)
    PLUS            reduce using rule 156 (name -> attribute .)
    MINUS           reduce using rule 156 (name -> attribute .)
    AMPERSAND       reduce using rule 156 (name -> attribute .)
    AND             reduce using rule 156 (name -> attribute .)
    OR              reduce using rule 156 (name -> attribute .)
    XOR             reduce using rule 156 (name -> attribute .)
    RPAREN          reduce using rule 156 (name -> attribute .)
    COMMA           reduce using rule 156 (name -> attribute .)
    ARROW           reduce using rule 156 (name -> attribute .)
    |               reduce using rule 156 (name -> attribute .)
    IS              reduce using rule 156 (name -> attribute .)
    RENAMES         reduce using rule 156 (name -> attribute .)
    WHEN            reduce using rule 156 (name -> attribute .)
    DIGITS          reduce using rule 156 (name -> attribute .)
    WITH            reduce using rule 156 (name -> attribute .)
    THEN            reduce using rule 156 (name -> attribute .)
    LOOP            reduce using rule 156 (name -> attribute .)


state 122

    (166) used_char -> CHARACTER .

    POW             reduce using rule 166 (used_char -> CHARACTER .)
    TIMES           reduce using rule 166 (used_char -> CHARACTER .)
    DIVIDE          reduce using rule 166 (used_char -> CHARACTER .)
    MOD             reduce using rule 166 (used_char -> CHARACTER .)
    REM             reduce using rule 166 (used_char -> CHARACTER .)
    EQ              reduce using rule 166 (used_char -> CHARACTER .)
    NE              reduce using rule 166 (used_char -> CHARACTER .)
    LT              reduce using rule 166 (used_char -> CHARACTER .)
    LE              reduce using rule 166 (used_char -> CHARACTER .)
    GT              reduce using rule 166 (used_char -> CHARACTER .)
    GE              reduce using rule 166 (used_char -> CHARACTER .)
    IN              reduce using rule 166 (used_char -> CHARACTER .)
    NOT             reduce using rule 166 (used_char -> CHARACTER .)
    PLUS            reduce using rule 166 (used_char -> CHARACTER .)
    MINUS           reduce using rule 166 (used_char -> CHARACTER .)
    AMPERSAND       reduce using rule 166 (used_char -> CHARACTER .)
    AND             reduce using rule 166 (used_char -> CHARACTER .)
    OR              reduce using rule 166 (used_char -> CHARACTER .)
    XOR             reduce using rule 166 (used_char -> CHARACTER .)
    SEMICOLON       reduce using rule 166 (used_char -> CHARACTER .)
    DOUBLEDOT       reduce using rule 166 (used_char -> CHARACTER .)
    ARROW           reduce using rule 166 (used_char -> CHARACTER .)
    |               reduce using rule 166 (used_char -> CHARACTER .)
    RPAREN          reduce using rule 166 (used_char -> CHARACTER .)
    COMMA           reduce using rule 166 (used_char -> CHARACTER .)
    WITH            reduce using rule 166 (used_char -> CHARACTER .)
    IS              reduce using rule 166 (used_char -> CHARACTER .)
    THEN            reduce using rule 166 (used_char -> CHARACTER .)
    LOOP            reduce using rule 166 (used_char -> CHARACTER .)
    RANGE           reduce using rule 166 (used_char -> CHARACTER .)
    DIGITS          reduce using rule 166 (used_char -> CHARACTER .)
    RENAMES         reduce using rule 166 (used_char -> CHARACTER .)
    IS_ASSIGNED     reduce using rule 166 (used_char -> CHARACTER .)
    TICK            reduce using rule 166 (used_char -> CHARACTER .)
    LPAREN          reduce using rule 166 (used_char -> CHARACTER .)
    DOT             reduce using rule 166 (used_char -> CHARACTER .)
    WHEN            reduce using rule 166 (used_char -> CHARACTER .)


state 123

    (229) factor -> primary .
    (232) factor -> primary . POW primary

    TIMES           reduce using rule 229 (factor -> primary .)
    DIVIDE          reduce using rule 229 (factor -> primary .)
    MOD             reduce using rule 229 (factor -> primary .)
    REM             reduce using rule 229 (factor -> primary .)
    DOUBLEDOT       reduce using rule 229 (factor -> primary .)
    EQ              reduce using rule 229 (factor -> primary .)
    NE              reduce using rule 229 (factor -> primary .)
    LT              reduce using rule 229 (factor -> primary .)
    LE              reduce using rule 229 (factor -> primary .)
    GT              reduce using rule 229 (factor -> primary .)
    GE              reduce using rule 229 (factor -> primary .)
    IN              reduce using rule 229 (factor -> primary .)
    NOT             reduce using rule 229 (factor -> primary .)
    PLUS            reduce using rule 229 (factor -> primary .)
    MINUS           reduce using rule 229 (factor -> primary .)
    AMPERSAND       reduce using rule 229 (factor -> primary .)
    AND             reduce using rule 229 (factor -> primary .)
    OR              reduce using rule 229 (factor -> primary .)
    XOR             reduce using rule 229 (factor -> primary .)
    RPAREN          reduce using rule 229 (factor -> primary .)
    COMMA           reduce using rule 229 (factor -> primary .)
    ARROW           reduce using rule 229 (factor -> primary .)
    |               reduce using rule 229 (factor -> primary .)
    DIGITS          reduce using rule 229 (factor -> primary .)
    RANGE           reduce using rule 229 (factor -> primary .)
    SEMICOLON       reduce using rule 229 (factor -> primary .)
    IS              reduce using rule 229 (factor -> primary .)
    THEN            reduce using rule 229 (factor -> primary .)
    LOOP            reduce using rule 229 (factor -> primary .)
    WITH            reduce using rule 229 (factor -> primary .)
    RENAMES         reduce using rule 229 (factor -> primary .)
    IS_ASSIGNED     reduce using rule 229 (factor -> primary .)
    POW             shift and go to state 200


state 124

    (4) pragma_arg_s -> pragma_arg .

    RPAREN          reduce using rule 4 (pragma_arg_s -> pragma_arg .)
    COMMA           reduce using rule 4 (pragma_arg_s -> pragma_arg .)


state 125

    (215) simple_expression -> unary . term
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    factor                         shift and go to state 136
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    term                           shift and go to state 201
    name                           shift and go to state 145
    operator_symbol                shift and go to state 146

state 126

    (238) parenthesized_primary -> aggregate .

    POW             reduce using rule 238 (parenthesized_primary -> aggregate .)
    TIMES           reduce using rule 238 (parenthesized_primary -> aggregate .)
    DIVIDE          reduce using rule 238 (parenthesized_primary -> aggregate .)
    MOD             reduce using rule 238 (parenthesized_primary -> aggregate .)
    REM             reduce using rule 238 (parenthesized_primary -> aggregate .)
    EQ              reduce using rule 238 (parenthesized_primary -> aggregate .)
    NE              reduce using rule 238 (parenthesized_primary -> aggregate .)
    LT              reduce using rule 238 (parenthesized_primary -> aggregate .)
    LE              reduce using rule 238 (parenthesized_primary -> aggregate .)
    GT              reduce using rule 238 (parenthesized_primary -> aggregate .)
    GE              reduce using rule 238 (parenthesized_primary -> aggregate .)
    IN              reduce using rule 238 (parenthesized_primary -> aggregate .)
    NOT             reduce using rule 238 (parenthesized_primary -> aggregate .)
    PLUS            reduce using rule 238 (parenthesized_primary -> aggregate .)
    MINUS           reduce using rule 238 (parenthesized_primary -> aggregate .)
    AMPERSAND       reduce using rule 238 (parenthesized_primary -> aggregate .)
    IS              reduce using rule 238 (parenthesized_primary -> aggregate .)
    AND             reduce using rule 238 (parenthesized_primary -> aggregate .)
    OR              reduce using rule 238 (parenthesized_primary -> aggregate .)
    XOR             reduce using rule 238 (parenthesized_primary -> aggregate .)
    RPAREN          reduce using rule 238 (parenthesized_primary -> aggregate .)
    COMMA           reduce using rule 238 (parenthesized_primary -> aggregate .)
    WITH            reduce using rule 238 (parenthesized_primary -> aggregate .)
    ARROW           reduce using rule 238 (parenthesized_primary -> aggregate .)
    |               reduce using rule 238 (parenthesized_primary -> aggregate .)
    SEMICOLON       reduce using rule 238 (parenthesized_primary -> aggregate .)
    THEN            reduce using rule 238 (parenthesized_primary -> aggregate .)
    LOOP            reduce using rule 238 (parenthesized_primary -> aggregate .)
    RANGE           reduce using rule 238 (parenthesized_primary -> aggregate .)
    DIGITS          reduce using rule 238 (parenthesized_primary -> aggregate .)
    RENAMES         reduce using rule 238 (parenthesized_primary -> aggregate .)
    IS_ASSIGNED     reduce using rule 238 (parenthesized_primary -> aggregate .)
    DOUBLEDOT       reduce using rule 238 (parenthesized_primary -> aggregate .)


state 127

    (195) expression -> relation .

    AND             reduce using rule 195 (expression -> relation .)
    OR              reduce using rule 195 (expression -> relation .)
    XOR             reduce using rule 195 (expression -> relation .)
    SEMICOLON       reduce using rule 195 (expression -> relation .)
    IS              reduce using rule 195 (expression -> relation .)
    RPAREN          reduce using rule 195 (expression -> relation .)
    COMMA           reduce using rule 195 (expression -> relation .)
    ARROW           reduce using rule 195 (expression -> relation .)
    |               reduce using rule 195 (expression -> relation .)
    RANGE           reduce using rule 195 (expression -> relation .)
    RENAMES         reduce using rule 195 (expression -> relation .)
    IS_ASSIGNED     reduce using rule 195 (expression -> relation .)
    WITH            reduce using rule 195 (expression -> relation .)
    THEN            reduce using rule 195 (expression -> relation .)
    LOOP            reduce using rule 195 (expression -> relation .)
    DIGITS          reduce using rule 195 (expression -> relation .)


state 128

    (241) allocator -> NEW . name
    (242) allocator -> NEW . qualified
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (240) qualified -> . name TICK parenthesized_primary
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    name                           shift and go to state 202
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 146
    qualified                      shift and go to state 203
    indexed_comp                   shift and go to state 119
    simple_name                    shift and go to state 153

state 129

    (203) relation -> simple_expression .
    (204) relation -> simple_expression . relational simple_expression
    (205) relation -> simple_expression . membership range
    (206) relation -> simple_expression . membership name
    (217) simple_expression -> simple_expression . adding term
    (207) relational -> . EQ
    (208) relational -> . NE
    (209) relational -> . LT
    (210) relational -> . LE
    (211) relational -> . GT
    (212) relational -> . GE
    (213) membership -> . IN
    (214) membership -> . NOT IN
    (220) adding -> . PLUS
    (221) adding -> . MINUS
    (222) adding -> . AMPERSAND

    AND             reduce using rule 203 (relation -> simple_expression .)
    OR              reduce using rule 203 (relation -> simple_expression .)
    XOR             reduce using rule 203 (relation -> simple_expression .)
    RPAREN          reduce using rule 203 (relation -> simple_expression .)
    COMMA           reduce using rule 203 (relation -> simple_expression .)
    SEMICOLON       reduce using rule 203 (relation -> simple_expression .)
    RANGE           reduce using rule 203 (relation -> simple_expression .)
    IS              reduce using rule 203 (relation -> simple_expression .)
    LOOP            reduce using rule 203 (relation -> simple_expression .)
    ARROW           reduce using rule 203 (relation -> simple_expression .)
    THEN            reduce using rule 203 (relation -> simple_expression .)
    DIGITS          reduce using rule 203 (relation -> simple_expression .)
    WITH            reduce using rule 203 (relation -> simple_expression .)
    |               reduce using rule 203 (relation -> simple_expression .)
    RENAMES         reduce using rule 203 (relation -> simple_expression .)
    IS_ASSIGNED     reduce using rule 203 (relation -> simple_expression .)
    EQ              shift and go to state 216
    NE              shift and go to state 210
    LT              shift and go to state 208
    LE              shift and go to state 205
    GT              shift and go to state 211
    GE              shift and go to state 206
    IN              shift and go to state 213
    NOT             shift and go to state 214
    PLUS            shift and go to state 212
    MINUS           shift and go to state 217
    AMPERSAND       shift and go to state 207

    adding                         shift and go to state 204
    membership                     shift and go to state 209
    relational                     shift and go to state 215

state 130

    (186) literal -> NULL .

    POW             reduce using rule 186 (literal -> NULL .)
    TIMES           reduce using rule 186 (literal -> NULL .)
    DIVIDE          reduce using rule 186 (literal -> NULL .)
    MOD             reduce using rule 186 (literal -> NULL .)
    REM             reduce using rule 186 (literal -> NULL .)
    EQ              reduce using rule 186 (literal -> NULL .)
    NE              reduce using rule 186 (literal -> NULL .)
    LT              reduce using rule 186 (literal -> NULL .)
    LE              reduce using rule 186 (literal -> NULL .)
    GT              reduce using rule 186 (literal -> NULL .)
    GE              reduce using rule 186 (literal -> NULL .)
    IN              reduce using rule 186 (literal -> NULL .)
    NOT             reduce using rule 186 (literal -> NULL .)
    PLUS            reduce using rule 186 (literal -> NULL .)
    MINUS           reduce using rule 186 (literal -> NULL .)
    AMPERSAND       reduce using rule 186 (literal -> NULL .)
    AND             reduce using rule 186 (literal -> NULL .)
    OR              reduce using rule 186 (literal -> NULL .)
    XOR             reduce using rule 186 (literal -> NULL .)
    SEMICOLON       reduce using rule 186 (literal -> NULL .)
    DOUBLEDOT       reduce using rule 186 (literal -> NULL .)
    RPAREN          reduce using rule 186 (literal -> NULL .)
    COMMA           reduce using rule 186 (literal -> NULL .)
    THEN            reduce using rule 186 (literal -> NULL .)
    WITH            reduce using rule 186 (literal -> NULL .)
    ARROW           reduce using rule 186 (literal -> NULL .)
    |               reduce using rule 186 (literal -> NULL .)
    IS              reduce using rule 186 (literal -> NULL .)
    LOOP            reduce using rule 186 (literal -> NULL .)
    RANGE           reduce using rule 186 (literal -> NULL .)
    DIGITS          reduce using rule 186 (literal -> NULL .)
    RENAMES         reduce using rule 186 (literal -> NULL .)
    IS_ASSIGNED     reduce using rule 186 (literal -> NULL .)


state 131

    (219) unary -> MINUS .

    NOT             reduce using rule 219 (unary -> MINUS .)
    ABS             reduce using rule 219 (unary -> MINUS .)
    NUMBER          reduce using rule 219 (unary -> MINUS .)
    NULL            reduce using rule 219 (unary -> MINUS .)
    NEW             reduce using rule 219 (unary -> MINUS .)
    LPAREN          reduce using rule 219 (unary -> MINUS .)
    CHARACTER       reduce using rule 219 (unary -> MINUS .)
    IDENTIFIER      reduce using rule 219 (unary -> MINUS .)
    STRING          reduce using rule 219 (unary -> MINUS .)


state 132

    (234) primary -> allocator .

    POW             reduce using rule 234 (primary -> allocator .)
    TIMES           reduce using rule 234 (primary -> allocator .)
    DIVIDE          reduce using rule 234 (primary -> allocator .)
    MOD             reduce using rule 234 (primary -> allocator .)
    REM             reduce using rule 234 (primary -> allocator .)
    EQ              reduce using rule 234 (primary -> allocator .)
    NE              reduce using rule 234 (primary -> allocator .)
    LT              reduce using rule 234 (primary -> allocator .)
    LE              reduce using rule 234 (primary -> allocator .)
    GT              reduce using rule 234 (primary -> allocator .)
    GE              reduce using rule 234 (primary -> allocator .)
    IN              reduce using rule 234 (primary -> allocator .)
    NOT             reduce using rule 234 (primary -> allocator .)
    PLUS            reduce using rule 234 (primary -> allocator .)
    MINUS           reduce using rule 234 (primary -> allocator .)
    AMPERSAND       reduce using rule 234 (primary -> allocator .)
    AND             reduce using rule 234 (primary -> allocator .)
    OR              reduce using rule 234 (primary -> allocator .)
    XOR             reduce using rule 234 (primary -> allocator .)
    THEN            reduce using rule 234 (primary -> allocator .)
    RPAREN          reduce using rule 234 (primary -> allocator .)
    COMMA           reduce using rule 234 (primary -> allocator .)
    DOUBLEDOT       reduce using rule 234 (primary -> allocator .)
    WITH            reduce using rule 234 (primary -> allocator .)
    ARROW           reduce using rule 234 (primary -> allocator .)
    |               reduce using rule 234 (primary -> allocator .)
    SEMICOLON       reduce using rule 234 (primary -> allocator .)
    IS              reduce using rule 234 (primary -> allocator .)
    LOOP            reduce using rule 234 (primary -> allocator .)
    RANGE           reduce using rule 234 (primary -> allocator .)
    DIGITS          reduce using rule 234 (primary -> allocator .)
    RENAMES         reduce using rule 234 (primary -> allocator .)
    IS_ASSIGNED     reduce using rule 234 (primary -> allocator .)


state 133

    (7) pragma_arg -> simple_name . ARROW expression
    (153) name -> simple_name .

    ARROW           shift and go to state 218
    TICK            reduce using rule 153 (name -> simple_name .)
    LPAREN          reduce using rule 153 (name -> simple_name .)
    DOT             reduce using rule 153 (name -> simple_name .)
    POW             reduce using rule 153 (name -> simple_name .)
    TIMES           reduce using rule 153 (name -> simple_name .)
    DIVIDE          reduce using rule 153 (name -> simple_name .)
    MOD             reduce using rule 153 (name -> simple_name .)
    REM             reduce using rule 153 (name -> simple_name .)
    EQ              reduce using rule 153 (name -> simple_name .)
    NE              reduce using rule 153 (name -> simple_name .)
    LT              reduce using rule 153 (name -> simple_name .)
    LE              reduce using rule 153 (name -> simple_name .)
    GT              reduce using rule 153 (name -> simple_name .)
    GE              reduce using rule 153 (name -> simple_name .)
    IN              reduce using rule 153 (name -> simple_name .)
    NOT             reduce using rule 153 (name -> simple_name .)
    PLUS            reduce using rule 153 (name -> simple_name .)
    MINUS           reduce using rule 153 (name -> simple_name .)
    AMPERSAND       reduce using rule 153 (name -> simple_name .)
    AND             reduce using rule 153 (name -> simple_name .)
    OR              reduce using rule 153 (name -> simple_name .)
    XOR             reduce using rule 153 (name -> simple_name .)
    RPAREN          reduce using rule 153 (name -> simple_name .)
    COMMA           reduce using rule 153 (name -> simple_name .)


state 134

    (218) unary -> PLUS .

    NOT             reduce using rule 218 (unary -> PLUS .)
    ABS             reduce using rule 218 (unary -> PLUS .)
    NUMBER          reduce using rule 218 (unary -> PLUS .)
    NULL            reduce using rule 218 (unary -> PLUS .)
    NEW             reduce using rule 218 (unary -> PLUS .)
    LPAREN          reduce using rule 218 (unary -> PLUS .)
    CHARACTER       reduce using rule 218 (unary -> PLUS .)
    IDENTIFIER      reduce using rule 218 (unary -> PLUS .)
    STRING          reduce using rule 218 (unary -> PLUS .)


state 135

    (233) primary -> literal .

    POW             reduce using rule 233 (primary -> literal .)
    TIMES           reduce using rule 233 (primary -> literal .)
    DIVIDE          reduce using rule 233 (primary -> literal .)
    MOD             reduce using rule 233 (primary -> literal .)
    REM             reduce using rule 233 (primary -> literal .)
    EQ              reduce using rule 233 (primary -> literal .)
    NE              reduce using rule 233 (primary -> literal .)
    LT              reduce using rule 233 (primary -> literal .)
    LE              reduce using rule 233 (primary -> literal .)
    GT              reduce using rule 233 (primary -> literal .)
    GE              reduce using rule 233 (primary -> literal .)
    IN              reduce using rule 233 (primary -> literal .)
    NOT             reduce using rule 233 (primary -> literal .)
    PLUS            reduce using rule 233 (primary -> literal .)
    MINUS           reduce using rule 233 (primary -> literal .)
    AMPERSAND       reduce using rule 233 (primary -> literal .)
    AND             reduce using rule 233 (primary -> literal .)
    OR              reduce using rule 233 (primary -> literal .)
    XOR             reduce using rule 233 (primary -> literal .)
    THEN            reduce using rule 233 (primary -> literal .)
    RPAREN          reduce using rule 233 (primary -> literal .)
    COMMA           reduce using rule 233 (primary -> literal .)
    DOUBLEDOT       reduce using rule 233 (primary -> literal .)
    WITH            reduce using rule 233 (primary -> literal .)
    ARROW           reduce using rule 233 (primary -> literal .)
    |               reduce using rule 233 (primary -> literal .)
    SEMICOLON       reduce using rule 233 (primary -> literal .)
    IS              reduce using rule 233 (primary -> literal .)
    LOOP            reduce using rule 233 (primary -> literal .)
    RANGE           reduce using rule 233 (primary -> literal .)
    DIGITS          reduce using rule 233 (primary -> literal .)
    RENAMES         reduce using rule 233 (primary -> literal .)
    IS_ASSIGNED     reduce using rule 233 (primary -> literal .)


state 136

    (223) term -> factor .

    TIMES           reduce using rule 223 (term -> factor .)
    DIVIDE          reduce using rule 223 (term -> factor .)
    MOD             reduce using rule 223 (term -> factor .)
    REM             reduce using rule 223 (term -> factor .)
    EQ              reduce using rule 223 (term -> factor .)
    NE              reduce using rule 223 (term -> factor .)
    LT              reduce using rule 223 (term -> factor .)
    LE              reduce using rule 223 (term -> factor .)
    GT              reduce using rule 223 (term -> factor .)
    GE              reduce using rule 223 (term -> factor .)
    IN              reduce using rule 223 (term -> factor .)
    NOT             reduce using rule 223 (term -> factor .)
    PLUS            reduce using rule 223 (term -> factor .)
    MINUS           reduce using rule 223 (term -> factor .)
    AMPERSAND       reduce using rule 223 (term -> factor .)
    AND             reduce using rule 223 (term -> factor .)
    OR              reduce using rule 223 (term -> factor .)
    XOR             reduce using rule 223 (term -> factor .)
    RANGE           reduce using rule 223 (term -> factor .)
    SEMICOLON       reduce using rule 223 (term -> factor .)
    DOUBLEDOT       reduce using rule 223 (term -> factor .)
    RPAREN          reduce using rule 223 (term -> factor .)
    COMMA           reduce using rule 223 (term -> factor .)
    ARROW           reduce using rule 223 (term -> factor .)
    |               reduce using rule 223 (term -> factor .)
    THEN            reduce using rule 223 (term -> factor .)
    IS              reduce using rule 223 (term -> factor .)
    WITH            reduce using rule 223 (term -> factor .)
    LOOP            reduce using rule 223 (term -> factor .)
    DIGITS          reduce using rule 223 (term -> factor .)
    RENAMES         reduce using rule 223 (term -> factor .)
    IS_ASSIGNED     reduce using rule 223 (term -> factor .)


state 137

    (167) operator_symbol -> STRING .

    SEMICOLON       reduce using rule 167 (operator_symbol -> STRING .)
    LPAREN          reduce using rule 167 (operator_symbol -> STRING .)
    DOT             reduce using rule 167 (operator_symbol -> STRING .)
    TICK            reduce using rule 167 (operator_symbol -> STRING .)
    RANGE           reduce using rule 167 (operator_symbol -> STRING .)
    POW             reduce using rule 167 (operator_symbol -> STRING .)
    TIMES           reduce using rule 167 (operator_symbol -> STRING .)
    DIVIDE          reduce using rule 167 (operator_symbol -> STRING .)
    MOD             reduce using rule 167 (operator_symbol -> STRING .)
    REM             reduce using rule 167 (operator_symbol -> STRING .)
    DOUBLEDOT       reduce using rule 167 (operator_symbol -> STRING .)
    EQ              reduce using rule 167 (operator_symbol -> STRING .)
    NE              reduce using rule 167 (operator_symbol -> STRING .)
    LT              reduce using rule 167 (operator_symbol -> STRING .)
    LE              reduce using rule 167 (operator_symbol -> STRING .)
    GT              reduce using rule 167 (operator_symbol -> STRING .)
    GE              reduce using rule 167 (operator_symbol -> STRING .)
    IN              reduce using rule 167 (operator_symbol -> STRING .)
    NOT             reduce using rule 167 (operator_symbol -> STRING .)
    PLUS            reduce using rule 167 (operator_symbol -> STRING .)
    MINUS           reduce using rule 167 (operator_symbol -> STRING .)
    AMPERSAND       reduce using rule 167 (operator_symbol -> STRING .)
    AND             reduce using rule 167 (operator_symbol -> STRING .)
    OR              reduce using rule 167 (operator_symbol -> STRING .)
    XOR             reduce using rule 167 (operator_symbol -> STRING .)
    RPAREN          reduce using rule 167 (operator_symbol -> STRING .)
    COMMA           reduce using rule 167 (operator_symbol -> STRING .)
    ARROW           reduce using rule 167 (operator_symbol -> STRING .)
    |               reduce using rule 167 (operator_symbol -> STRING .)
    WITH            reduce using rule 167 (operator_symbol -> STRING .)
    IS              reduce using rule 167 (operator_symbol -> STRING .)
    THEN            reduce using rule 167 (operator_symbol -> STRING .)
    LOOP            reduce using rule 167 (operator_symbol -> STRING .)
    DIGITS          reduce using rule 167 (operator_symbol -> STRING .)
    RENAMES         reduce using rule 167 (operator_symbol -> STRING .)
    IS_ASSIGNED     reduce using rule 167 (operator_symbol -> STRING .)
    WHEN            reduce using rule 167 (operator_symbol -> STRING .)


state 138

    (184) literal -> NUMBER .

    POW             reduce using rule 184 (literal -> NUMBER .)
    TIMES           reduce using rule 184 (literal -> NUMBER .)
    DIVIDE          reduce using rule 184 (literal -> NUMBER .)
    MOD             reduce using rule 184 (literal -> NUMBER .)
    REM             reduce using rule 184 (literal -> NUMBER .)
    EQ              reduce using rule 184 (literal -> NUMBER .)
    NE              reduce using rule 184 (literal -> NUMBER .)
    LT              reduce using rule 184 (literal -> NUMBER .)
    LE              reduce using rule 184 (literal -> NUMBER .)
    GT              reduce using rule 184 (literal -> NUMBER .)
    GE              reduce using rule 184 (literal -> NUMBER .)
    IN              reduce using rule 184 (literal -> NUMBER .)
    NOT             reduce using rule 184 (literal -> NUMBER .)
    PLUS            reduce using rule 184 (literal -> NUMBER .)
    MINUS           reduce using rule 184 (literal -> NUMBER .)
    AMPERSAND       reduce using rule 184 (literal -> NUMBER .)
    AND             reduce using rule 184 (literal -> NUMBER .)
    OR              reduce using rule 184 (literal -> NUMBER .)
    XOR             reduce using rule 184 (literal -> NUMBER .)
    SEMICOLON       reduce using rule 184 (literal -> NUMBER .)
    DOUBLEDOT       reduce using rule 184 (literal -> NUMBER .)
    RPAREN          reduce using rule 184 (literal -> NUMBER .)
    COMMA           reduce using rule 184 (literal -> NUMBER .)
    THEN            reduce using rule 184 (literal -> NUMBER .)
    WITH            reduce using rule 184 (literal -> NUMBER .)
    ARROW           reduce using rule 184 (literal -> NUMBER .)
    |               reduce using rule 184 (literal -> NUMBER .)
    IS              reduce using rule 184 (literal -> NUMBER .)
    LOOP            reduce using rule 184 (literal -> NUMBER .)
    RANGE           reduce using rule 184 (literal -> NUMBER .)
    DIGITS          reduce using rule 184 (literal -> NUMBER .)
    RENAMES         reduce using rule 184 (literal -> NUMBER .)
    IS_ASSIGNED     reduce using rule 184 (literal -> NUMBER .)


state 139

    (3) pragma -> PRAGMA simple_name LPAREN pragma_arg_s . RPAREN SEMICOLON
    (5) pragma_arg_s -> pragma_arg_s . COMMA pragma_arg

    RPAREN          shift and go to state 219
    COMMA           shift and go to state 220


state 140

    (231) factor -> ABS . primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    name                           shift and go to state 145
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 146
    primary                        shift and go to state 221
    used_char                      shift and go to state 143
    literal                        shift and go to state 135
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153

state 141

    (236) primary -> parenthesized_primary .

    POW             reduce using rule 236 (primary -> parenthesized_primary .)
    TIMES           reduce using rule 236 (primary -> parenthesized_primary .)
    DIVIDE          reduce using rule 236 (primary -> parenthesized_primary .)
    MOD             reduce using rule 236 (primary -> parenthesized_primary .)
    REM             reduce using rule 236 (primary -> parenthesized_primary .)
    EQ              reduce using rule 236 (primary -> parenthesized_primary .)
    NE              reduce using rule 236 (primary -> parenthesized_primary .)
    LT              reduce using rule 236 (primary -> parenthesized_primary .)
    LE              reduce using rule 236 (primary -> parenthesized_primary .)
    GT              reduce using rule 236 (primary -> parenthesized_primary .)
    GE              reduce using rule 236 (primary -> parenthesized_primary .)
    IN              reduce using rule 236 (primary -> parenthesized_primary .)
    NOT             reduce using rule 236 (primary -> parenthesized_primary .)
    PLUS            reduce using rule 236 (primary -> parenthesized_primary .)
    MINUS           reduce using rule 236 (primary -> parenthesized_primary .)
    AMPERSAND       reduce using rule 236 (primary -> parenthesized_primary .)
    AND             reduce using rule 236 (primary -> parenthesized_primary .)
    OR              reduce using rule 236 (primary -> parenthesized_primary .)
    XOR             reduce using rule 236 (primary -> parenthesized_primary .)
    THEN            reduce using rule 236 (primary -> parenthesized_primary .)
    RPAREN          reduce using rule 236 (primary -> parenthesized_primary .)
    COMMA           reduce using rule 236 (primary -> parenthesized_primary .)
    DOUBLEDOT       reduce using rule 236 (primary -> parenthesized_primary .)
    WITH            reduce using rule 236 (primary -> parenthesized_primary .)
    ARROW           reduce using rule 236 (primary -> parenthesized_primary .)
    |               reduce using rule 236 (primary -> parenthesized_primary .)
    SEMICOLON       reduce using rule 236 (primary -> parenthesized_primary .)
    IS              reduce using rule 236 (primary -> parenthesized_primary .)
    LOOP            reduce using rule 236 (primary -> parenthesized_primary .)
    RANGE           reduce using rule 236 (primary -> parenthesized_primary .)
    DIGITS          reduce using rule 236 (primary -> parenthesized_primary .)
    RENAMES         reduce using rule 236 (primary -> parenthesized_primary .)
    IS_ASSIGNED     reduce using rule 236 (primary -> parenthesized_primary .)


state 142

    (239) parenthesized_primary -> LPAREN . expression RPAREN
    (187) aggregate -> LPAREN . comp_assoc RPAREN
    (188) aggregate -> LPAREN . value_s_2 RPAREN
    (189) aggregate -> LPAREN . expression WITH value_s RPAREN
    (190) aggregate -> LPAREN . expression WITH NULL RECORD RPAREN
    (191) aggregate -> LPAREN . NULL RECORD RPAREN
    (195) expression -> . relation
    (196) expression -> . expression logical relation
    (197) expression -> . expression short_circuit relation
    (194) comp_assoc -> . choice_s ARROW expression
    (192) value_s_2 -> . value COMMA value
    (193) value_s_2 -> . value_s_2 COMMA value
    (203) relation -> . simple_expression
    (204) relation -> . simple_expression relational simple_expression
    (205) relation -> . simple_expression membership range
    (206) relation -> . simple_expression membership name
    (121) choice_s -> . choice
    (122) choice_s -> . choice_s | choice
    (171) value -> . expression
    (172) value -> . comp_assoc
    (173) value -> . discrete_with_range
    (174) value -> . error
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (123) choice -> . expression
    (124) choice -> . discrete_with_range
    (125) choice -> . OTHERS
    (126) discrete_with_range -> . name range_constraint
    (127) discrete_with_range -> . range
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (60) range -> . simple_expression DOUBLEDOT simple_expression
    (61) range -> . name TICK RANGE
    (62) range -> . name TICK RANGE LPAREN expression RPAREN
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN

    NULL            shift and go to state 224
    error           shift and go to state 233
    OTHERS          shift and go to state 222
    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137
    NUMBER          shift and go to state 138
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    relation                       shift and go to state 127
    simple_expression              shift and go to state 223
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    factor                         shift and go to state 136
    comp_assoc                     shift and go to state 226
    choice_s                       shift and go to state 225
    choice                         shift and go to state 227
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    value_s_2                      shift and go to state 228
    aggregate                      shift and go to state 126
    discrete_with_range            shift and go to state 229
    term                           shift and go to state 144
    name                           shift and go to state 230
    operator_symbol                shift and go to state 146
    value                          shift and go to state 231
    range                          shift and go to state 232
    expression                     shift and go to state 234

state 143

    (185) literal -> used_char .

    POW             reduce using rule 185 (literal -> used_char .)
    TIMES           reduce using rule 185 (literal -> used_char .)
    DIVIDE          reduce using rule 185 (literal -> used_char .)
    MOD             reduce using rule 185 (literal -> used_char .)
    REM             reduce using rule 185 (literal -> used_char .)
    EQ              reduce using rule 185 (literal -> used_char .)
    NE              reduce using rule 185 (literal -> used_char .)
    LT              reduce using rule 185 (literal -> used_char .)
    LE              reduce using rule 185 (literal -> used_char .)
    GT              reduce using rule 185 (literal -> used_char .)
    GE              reduce using rule 185 (literal -> used_char .)
    IN              reduce using rule 185 (literal -> used_char .)
    NOT             reduce using rule 185 (literal -> used_char .)
    PLUS            reduce using rule 185 (literal -> used_char .)
    MINUS           reduce using rule 185 (literal -> used_char .)
    AMPERSAND       reduce using rule 185 (literal -> used_char .)
    AND             reduce using rule 185 (literal -> used_char .)
    OR              reduce using rule 185 (literal -> used_char .)
    XOR             reduce using rule 185 (literal -> used_char .)
    SEMICOLON       reduce using rule 185 (literal -> used_char .)
    DOUBLEDOT       reduce using rule 185 (literal -> used_char .)
    RPAREN          reduce using rule 185 (literal -> used_char .)
    COMMA           reduce using rule 185 (literal -> used_char .)
    THEN            reduce using rule 185 (literal -> used_char .)
    WITH            reduce using rule 185 (literal -> used_char .)
    ARROW           reduce using rule 185 (literal -> used_char .)
    |               reduce using rule 185 (literal -> used_char .)
    IS              reduce using rule 185 (literal -> used_char .)
    LOOP            reduce using rule 185 (literal -> used_char .)
    RANGE           reduce using rule 185 (literal -> used_char .)
    DIGITS          reduce using rule 185 (literal -> used_char .)
    RENAMES         reduce using rule 185 (literal -> used_char .)
    IS_ASSIGNED     reduce using rule 185 (literal -> used_char .)


state 144

    (216) simple_expression -> term .
    (224) term -> term . multiplying factor
    (225) multiplying -> . TIMES
    (226) multiplying -> . DIVIDE
    (227) multiplying -> . MOD
    (228) multiplying -> . REM

    DOUBLEDOT       reduce using rule 216 (simple_expression -> term .)
    PLUS            reduce using rule 216 (simple_expression -> term .)
    MINUS           reduce using rule 216 (simple_expression -> term .)
    AMPERSAND       reduce using rule 216 (simple_expression -> term .)
    COMMA           reduce using rule 216 (simple_expression -> term .)
    ARROW           reduce using rule 216 (simple_expression -> term .)
    |               reduce using rule 216 (simple_expression -> term .)
    AND             reduce using rule 216 (simple_expression -> term .)
    OR              reduce using rule 216 (simple_expression -> term .)
    XOR             reduce using rule 216 (simple_expression -> term .)
    RPAREN          reduce using rule 216 (simple_expression -> term .)
    WITH            reduce using rule 216 (simple_expression -> term .)
    SEMICOLON       reduce using rule 216 (simple_expression -> term .)
    IS              reduce using rule 216 (simple_expression -> term .)
    THEN            reduce using rule 216 (simple_expression -> term .)
    LOOP            reduce using rule 216 (simple_expression -> term .)
    RANGE           reduce using rule 216 (simple_expression -> term .)
    DIGITS          reduce using rule 216 (simple_expression -> term .)
    RENAMES         reduce using rule 216 (simple_expression -> term .)
    IS_ASSIGNED     reduce using rule 216 (simple_expression -> term .)
    EQ              reduce using rule 216 (simple_expression -> term .)
    NE              reduce using rule 216 (simple_expression -> term .)
    LT              reduce using rule 216 (simple_expression -> term .)
    LE              reduce using rule 216 (simple_expression -> term .)
    GT              reduce using rule 216 (simple_expression -> term .)
    GE              reduce using rule 216 (simple_expression -> term .)
    IN              reduce using rule 216 (simple_expression -> term .)
    NOT             reduce using rule 216 (simple_expression -> term .)
    TIMES           shift and go to state 238
    DIVIDE          shift and go to state 236
    MOD             shift and go to state 239
    REM             shift and go to state 237

    multiplying                    shift and go to state 235

state 145

    (237) primary -> name .
    (240) qualified -> name . TICK parenthesized_primary
    (168) indexed_comp -> name . LPAREN value_s RPAREN
    (175) selected_comp -> name . DOT simple_name
    (176) selected_comp -> name . DOT used_char
    (177) selected_comp -> name . DOT operator_symbol
    (178) selected_comp -> name . DOT ALL
    (179) attribute -> name . TICK attribute_id

    POW             reduce using rule 237 (primary -> name .)
    TIMES           reduce using rule 237 (primary -> name .)
    DIVIDE          reduce using rule 237 (primary -> name .)
    MOD             reduce using rule 237 (primary -> name .)
    REM             reduce using rule 237 (primary -> name .)
    EQ              reduce using rule 237 (primary -> name .)
    NE              reduce using rule 237 (primary -> name .)
    LT              reduce using rule 237 (primary -> name .)
    LE              reduce using rule 237 (primary -> name .)
    GT              reduce using rule 237 (primary -> name .)
    GE              reduce using rule 237 (primary -> name .)
    IN              reduce using rule 237 (primary -> name .)
    NOT             reduce using rule 237 (primary -> name .)
    PLUS            reduce using rule 237 (primary -> name .)
    MINUS           reduce using rule 237 (primary -> name .)
    AMPERSAND       reduce using rule 237 (primary -> name .)
    AND             reduce using rule 237 (primary -> name .)
    OR              reduce using rule 237 (primary -> name .)
    XOR             reduce using rule 237 (primary -> name .)
    THEN            reduce using rule 237 (primary -> name .)
    RPAREN          reduce using rule 237 (primary -> name .)
    COMMA           reduce using rule 237 (primary -> name .)
    DOUBLEDOT       reduce using rule 237 (primary -> name .)
    WITH            reduce using rule 237 (primary -> name .)
    ARROW           reduce using rule 237 (primary -> name .)
    |               reduce using rule 237 (primary -> name .)
    SEMICOLON       reduce using rule 237 (primary -> name .)
    IS              reduce using rule 237 (primary -> name .)
    LOOP            reduce using rule 237 (primary -> name .)
    RANGE           reduce using rule 237 (primary -> name .)
    DIGITS          reduce using rule 237 (primary -> name .)
    RENAMES         reduce using rule 237 (primary -> name .)
    IS_ASSIGNED     reduce using rule 237 (primary -> name .)
    TICK            shift and go to state 241
    LPAREN          shift and go to state 240
    DOT             shift and go to state 242


state 146

    (157) name -> operator_symbol .

    IS_ASSIGNED     reduce using rule 157 (name -> operator_symbol .)
    SEMICOLON       reduce using rule 157 (name -> operator_symbol .)
    TICK            reduce using rule 157 (name -> operator_symbol .)
    LPAREN          reduce using rule 157 (name -> operator_symbol .)
    DOT             reduce using rule 157 (name -> operator_symbol .)
    RANGE           reduce using rule 157 (name -> operator_symbol .)
    POW             reduce using rule 157 (name -> operator_symbol .)
    TIMES           reduce using rule 157 (name -> operator_symbol .)
    DIVIDE          reduce using rule 157 (name -> operator_symbol .)
    MOD             reduce using rule 157 (name -> operator_symbol .)
    REM             reduce using rule 157 (name -> operator_symbol .)
    DOUBLEDOT       reduce using rule 157 (name -> operator_symbol .)
    EQ              reduce using rule 157 (name -> operator_symbol .)
    NE              reduce using rule 157 (name -> operator_symbol .)
    LT              reduce using rule 157 (name -> operator_symbol .)
    LE              reduce using rule 157 (name -> operator_symbol .)
    GT              reduce using rule 157 (name -> operator_symbol .)
    GE              reduce using rule 157 (name -> operator_symbol .)
    IN              reduce using rule 157 (name -> operator_symbol .)
    NOT             reduce using rule 157 (name -> operator_symbol .)
    PLUS            reduce using rule 157 (name -> operator_symbol .)
    MINUS           reduce using rule 157 (name -> operator_symbol .)
    AMPERSAND       reduce using rule 157 (name -> operator_symbol .)
    AND             reduce using rule 157 (name -> operator_symbol .)
    OR              reduce using rule 157 (name -> operator_symbol .)
    XOR             reduce using rule 157 (name -> operator_symbol .)
    RPAREN          reduce using rule 157 (name -> operator_symbol .)
    COMMA           reduce using rule 157 (name -> operator_symbol .)
    ARROW           reduce using rule 157 (name -> operator_symbol .)
    |               reduce using rule 157 (name -> operator_symbol .)
    IS              reduce using rule 157 (name -> operator_symbol .)
    RENAMES         reduce using rule 157 (name -> operator_symbol .)
    WHEN            reduce using rule 157 (name -> operator_symbol .)
    DIGITS          reduce using rule 157 (name -> operator_symbol .)
    WITH            reduce using rule 157 (name -> operator_symbol .)
    THEN            reduce using rule 157 (name -> operator_symbol .)
    LOOP            reduce using rule 157 (name -> operator_symbol .)


state 147

    (235) primary -> qualified .

    POW             reduce using rule 235 (primary -> qualified .)
    TIMES           reduce using rule 235 (primary -> qualified .)
    DIVIDE          reduce using rule 235 (primary -> qualified .)
    MOD             reduce using rule 235 (primary -> qualified .)
    REM             reduce using rule 235 (primary -> qualified .)
    EQ              reduce using rule 235 (primary -> qualified .)
    NE              reduce using rule 235 (primary -> qualified .)
    LT              reduce using rule 235 (primary -> qualified .)
    LE              reduce using rule 235 (primary -> qualified .)
    GT              reduce using rule 235 (primary -> qualified .)
    GE              reduce using rule 235 (primary -> qualified .)
    IN              reduce using rule 235 (primary -> qualified .)
    NOT             reduce using rule 235 (primary -> qualified .)
    PLUS            reduce using rule 235 (primary -> qualified .)
    MINUS           reduce using rule 235 (primary -> qualified .)
    AMPERSAND       reduce using rule 235 (primary -> qualified .)
    AND             reduce using rule 235 (primary -> qualified .)
    OR              reduce using rule 235 (primary -> qualified .)
    XOR             reduce using rule 235 (primary -> qualified .)
    THEN            reduce using rule 235 (primary -> qualified .)
    RPAREN          reduce using rule 235 (primary -> qualified .)
    COMMA           reduce using rule 235 (primary -> qualified .)
    DOUBLEDOT       reduce using rule 235 (primary -> qualified .)
    WITH            reduce using rule 235 (primary -> qualified .)
    ARROW           reduce using rule 235 (primary -> qualified .)
    |               reduce using rule 235 (primary -> qualified .)
    SEMICOLON       reduce using rule 235 (primary -> qualified .)
    IS              reduce using rule 235 (primary -> qualified .)
    LOOP            reduce using rule 235 (primary -> qualified .)
    RANGE           reduce using rule 235 (primary -> qualified .)
    DIGITS          reduce using rule 235 (primary -> qualified .)
    RENAMES         reduce using rule 235 (primary -> qualified .)
    IS_ASSIGNED     reduce using rule 235 (primary -> qualified .)


state 148

    (230) factor -> NOT . primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    name                           shift and go to state 145
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 146
    primary                        shift and go to state 243
    used_char                      shift and go to state 143
    literal                        shift and go to state 135
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153

state 149

    (6) pragma_arg -> expression .
    (196) expression -> expression . logical relation
    (197) expression -> expression . short_circuit relation
    (198) logical -> . AND
    (199) logical -> . OR
    (200) logical -> . XOR
    (201) short_circuit -> . AND THEN
    (202) short_circuit -> . OR ELSE

    RPAREN          reduce using rule 6 (pragma_arg -> expression .)
    COMMA           reduce using rule 6 (pragma_arg -> expression .)
    AND             shift and go to state 244
    OR              shift and go to state 248
    XOR             shift and go to state 245

    logical                        shift and go to state 246
    short_circuit                  shift and go to state 247

state 150

    (346) use_clause -> USE name_s . SEMICOLON
    (349) name_s -> name_s . COMMA name

    SEMICOLON       shift and go to state 250
    COMMA           shift and go to state 249


state 151

    (348) name_s -> name .
    (168) indexed_comp -> name . LPAREN value_s RPAREN
    (175) selected_comp -> name . DOT simple_name
    (176) selected_comp -> name . DOT used_char
    (177) selected_comp -> name . DOT operator_symbol
    (178) selected_comp -> name . DOT ALL
    (179) attribute -> name . TICK attribute_id

    SEMICOLON       reduce using rule 348 (name_s -> name .)
    COMMA           reduce using rule 348 (name_s -> name .)
    LPAREN          shift and go to state 240
    DOT             shift and go to state 242
    TICK            shift and go to state 251


state 152

    (347) use_clause -> USE TYPE . name_s SEMICOLON
    (348) name_s -> . name
    (349) name_s -> . name_s COMMA name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    name_s                         shift and go to state 252
    name                           shift and go to state 151
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 146
    indexed_comp                   shift and go to state 119
    simple_name                    shift and go to state 153

state 153

    (153) name -> simple_name .

    IS_ASSIGNED     reduce using rule 153 (name -> simple_name .)
    SEMICOLON       reduce using rule 153 (name -> simple_name .)
    TICK            reduce using rule 153 (name -> simple_name .)
    LPAREN          reduce using rule 153 (name -> simple_name .)
    DOT             reduce using rule 153 (name -> simple_name .)
    RANGE           reduce using rule 153 (name -> simple_name .)
    POW             reduce using rule 153 (name -> simple_name .)
    TIMES           reduce using rule 153 (name -> simple_name .)
    DIVIDE          reduce using rule 153 (name -> simple_name .)
    MOD             reduce using rule 153 (name -> simple_name .)
    REM             reduce using rule 153 (name -> simple_name .)
    DOUBLEDOT       reduce using rule 153 (name -> simple_name .)
    EQ              reduce using rule 153 (name -> simple_name .)
    NE              reduce using rule 153 (name -> simple_name .)
    LT              reduce using rule 153 (name -> simple_name .)
    LE              reduce using rule 153 (name -> simple_name .)
    GT              reduce using rule 153 (name -> simple_name .)
    GE              reduce using rule 153 (name -> simple_name .)
    IN              reduce using rule 153 (name -> simple_name .)
    NOT             reduce using rule 153 (name -> simple_name .)
    PLUS            reduce using rule 153 (name -> simple_name .)
    MINUS           reduce using rule 153 (name -> simple_name .)
    AMPERSAND       reduce using rule 153 (name -> simple_name .)
    AND             reduce using rule 153 (name -> simple_name .)
    OR              reduce using rule 153 (name -> simple_name .)
    XOR             reduce using rule 153 (name -> simple_name .)
    RPAREN          reduce using rule 153 (name -> simple_name .)
    COMMA           reduce using rule 153 (name -> simple_name .)
    ARROW           reduce using rule 153 (name -> simple_name .)
    |               reduce using rule 153 (name -> simple_name .)
    IS              reduce using rule 153 (name -> simple_name .)
    RENAMES         reduce using rule 153 (name -> simple_name .)
    WHEN            reduce using rule 153 (name -> simple_name .)
    DIGITS          reduce using rule 153 (name -> simple_name .)
    WITH            reduce using rule 153 (name -> simple_name .)
    THEN            reduce using rule 153 (name -> simple_name .)
    LOOP            reduce using rule 153 (name -> simple_name .)


state 154

    (446) subunit -> SEPARATE LPAREN compound_name . RPAREN subunit_body
    (163) compound_name -> compound_name . DOT simple_name

    RPAREN          shift and go to state 253
    DOT             shift and go to state 118


state 155

    (354) rename_unit -> subprog_spec renames SEMICOLON .

    PACKAGE         reduce using rule 354 (rename_unit -> subprog_spec renames SEMICOLON .)
    TASK            reduce using rule 354 (rename_unit -> subprog_spec renames SEMICOLON .)
    PROTECTED       reduce using rule 354 (rename_unit -> subprog_spec renames SEMICOLON .)
    error           reduce using rule 354 (rename_unit -> subprog_spec renames SEMICOLON .)
    USE             reduce using rule 354 (rename_unit -> subprog_spec renames SEMICOLON .)
    PRAGMA          reduce using rule 354 (rename_unit -> subprog_spec renames SEMICOLON .)
    TYPE            reduce using rule 354 (rename_unit -> subprog_spec renames SEMICOLON .)
    SUBTYPE         reduce using rule 354 (rename_unit -> subprog_spec renames SEMICOLON .)
    FOR             reduce using rule 354 (rename_unit -> subprog_spec renames SEMICOLON .)
    PROCEDURE       reduce using rule 354 (rename_unit -> subprog_spec renames SEMICOLON .)
    FUNCTION        reduce using rule 354 (rename_unit -> subprog_spec renames SEMICOLON .)
    GENERIC         reduce using rule 354 (rename_unit -> subprog_spec renames SEMICOLON .)
    IDENTIFIER      reduce using rule 354 (rename_unit -> subprog_spec renames SEMICOLON .)
    BEGIN           reduce using rule 354 (rename_unit -> subprog_spec renames SEMICOLON .)
    PRIVATE         reduce using rule 354 (rename_unit -> subprog_spec renames SEMICOLON .)
    END             reduce using rule 354 (rename_unit -> subprog_spec renames SEMICOLON .)
    WITH            reduce using rule 354 (rename_unit -> subprog_spec renames SEMICOLON .)
    SEPARATE        reduce using rule 354 (rename_unit -> subprog_spec renames SEMICOLON .)
    $end            reduce using rule 354 (rename_unit -> subprog_spec renames SEMICOLON .)


state 156

    (357) renames -> RENAMES name .
    (168) indexed_comp -> name . LPAREN value_s RPAREN
    (175) selected_comp -> name . DOT simple_name
    (176) selected_comp -> name . DOT used_char
    (177) selected_comp -> name . DOT operator_symbol
    (178) selected_comp -> name . DOT ALL
    (179) attribute -> name . TICK attribute_id

    SEMICOLON       reduce using rule 357 (renames -> RENAMES name .)
    LPAREN          shift and go to state 240
    DOT             shift and go to state 242
    TICK            shift and go to state 251


state 157

    (499) generic_inst -> NEW . name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    name                           shift and go to state 254
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 146
    indexed_comp                   shift and go to state 119
    simple_name                    shift and go to state 153

state 158

    (497) generic_subp_inst -> subprog_spec IS generic_inst .

    SEMICOLON       reduce using rule 497 (generic_subp_inst -> subprog_spec IS generic_inst .)


state 159

    (340) pkg_body -> PACKAGE BODY compound_name . IS decl_part body_opt END c_id_opt SEMICOLON
    (163) compound_name -> compound_name . DOT simple_name

    IS              shift and go to state 255
    DOT             shift and go to state 118


state 160

    (353) rename_unit -> PACKAGE compound_name renames . SEMICOLON

    SEMICOLON       shift and go to state 256


state 161

    (335) pkg_spec -> PACKAGE compound_name IS . decl_item_s private_part END c_id_opt
    (498) generic_pkg_inst -> PACKAGE compound_name IS . generic_inst
    (137) decl_item_s -> .
    (138) decl_item_s -> . decl_item_s1
    (499) generic_inst -> . NEW name
    (139) decl_item_s1 -> . decl_item
    (140) decl_item_s1 -> . decl_item_s1 decl_item
    (141) decl_item -> . decl
    (142) decl_item -> . use_clause
    (143) decl_item -> . rep_spec
    (144) decl_item -> . pragma
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error SEMICOLON
    (346) use_clause -> . USE name_s SEMICOLON
    (347) use_clause -> . USE TYPE name_s SEMICOLON
    (500) rep_spec -> . attrib_def
    (501) rep_spec -> . record_type_spec
    (502) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (23) object_decl -> . def_id_s COLON object_qualifier_opt object_subtype_def init_opt SEMICOLON
    (35) number_decl -> . def_id_s COLON CONSTANT IS_ASSIGNED expression SEMICOLON
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion SEMICOLON
    (48) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind SEMICOLON
    (310) subprog_decl -> . subprog_spec SEMICOLON
    (311) subprog_decl -> . generic_subp_inst SEMICOLON
    (312) subprog_decl -> . subprog_spec_is_push ABSTRACT SEMICOLON
    (333) pkg_decl -> . pkg_spec SEMICOLON
    (334) pkg_decl -> . generic_pkg_inst SEMICOLON
    (358) task_decl -> . task_spec SEMICOLON
    (366) prot_decl -> . prot_spec SEMICOLON
    (455) exception_decl -> . def_id_s COLON EXCEPTION SEMICOLON
    (350) rename_decl -> . def_id_s COLON object_qualifier_opt subtype_ind renames SEMICOLON
    (351) rename_decl -> . def_id_s COLON EXCEPTION renames SEMICOLON
    (352) rename_decl -> . rename_unit
    (467) generic_decl -> . generic_formal_part subprog_spec SEMICOLON
    (468) generic_decl -> . generic_formal_part pkg_spec SEMICOLON
    (451) body_stub -> . TASK BODY simple_name IS SEPARATE SEMICOLON
    (452) body_stub -> . PACKAGE BODY compound_name IS SEPARATE SEMICOLON
    (453) body_stub -> . subprog_spec IS SEPARATE SEMICOLON
    (454) body_stub -> . PROTECTED BODY simple_name IS SEPARATE SEMICOLON
    (503) attrib_def -> . FOR mark USE expression SEMICOLON
    (504) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD SEMICOLON
    (509) address_spec -> . FOR mark USE AT expression SEMICOLON
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s COMMA def_id
    (313) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (314) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (315) subprog_spec -> . FUNCTION designator
    (497) generic_subp_inst -> . subprog_spec IS generic_inst
    (330) subprog_spec_is_push -> . subprog_spec IS
    (335) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (498) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (359) task_spec -> . TASK simple_name task_def
    (360) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (367) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (368) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (353) rename_unit -> . PACKAGE compound_name renames SEMICOLON
    (354) rename_unit -> . subprog_spec renames SEMICOLON
    (355) rename_unit -> . generic_formal_part PACKAGE compound_name renames SEMICOLON
    (356) rename_unit -> . generic_formal_part subprog_spec renames SEMICOLON
    (469) generic_formal_part -> . GENERIC
    (470) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    PRIVATE         reduce using rule 137 (decl_item_s -> .)
    END             reduce using rule 137 (decl_item_s -> .)
    NEW             shift and go to state 157
    error           shift and go to state 85
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 87
    SUBTYPE         shift and go to state 91
    TASK            shift and go to state 262
    PACKAGE         shift and go to state 263
    PROTECTED       shift and go to state 259
    FOR             shift and go to state 70
    PROCEDURE       shift and go to state 30
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 79

    decl                           shift and go to state 57
    task_decl                      shift and go to state 67
    subtype_decl                   shift and go to state 68
    generic_inst                   shift and go to state 257
    rep_spec                       shift and go to state 89
    decl_item_s1                   shift and go to state 258
    exception_decl                 shift and go to state 92
    address_spec                   shift and go to state 59
    decl_item                      shift and go to state 260
    subprog_spec_is_push           shift and go to state 264
    prot_decl                      shift and go to state 62
    record_type_spec               shift and go to state 75
    generic_decl                   shift and go to state 76
    attrib_def                     shift and go to state 77
    subprog_spec                   shift and go to state 265
    def_id_s                       shift and go to state 95
    task_spec                      shift and go to state 72
    object_decl                    shift and go to state 71
    body_stub                      shift and go to state 81
    generic_subp_inst              shift and go to state 28
    def_id                         shift and go to state 96
    rename_decl                    shift and go to state 97
    type_decl                      shift and go to state 63
    rename_unit                    shift and go to state 98
    generic_formal_part            shift and go to state 33
    pkg_decl                       shift and go to state 64
    prot_spec                      shift and go to state 83
    use_clause                     shift and go to state 73
    generic_pkg_inst               shift and go to state 34
    subprog_decl                   shift and go to state 65
    decl_item_s                    shift and go to state 261
    pragma                         shift and go to state 82
    pkg_spec                       shift and go to state 37
    number_decl                    shift and go to state 100

state 162

    (319) formal_part_opt -> formal_part .

    WHEN            reduce using rule 319 (formal_part_opt -> formal_part .)
    RETURN          reduce using rule 319 (formal_part_opt -> formal_part .)
    SEMICOLON       reduce using rule 319 (formal_part_opt -> formal_part .)
    IS              reduce using rule 319 (formal_part_opt -> formal_part .)
    RENAMES         reduce using rule 319 (formal_part_opt -> formal_part .)
    DO              reduce using rule 319 (formal_part_opt -> formal_part .)


state 163

    (313) subprog_spec -> PROCEDURE compound_name formal_part_opt .

    SEMICOLON       reduce using rule 313 (subprog_spec -> PROCEDURE compound_name formal_part_opt .)
    IS              reduce using rule 313 (subprog_spec -> PROCEDURE compound_name formal_part_opt .)
    RENAMES         reduce using rule 313 (subprog_spec -> PROCEDURE compound_name formal_part_opt .)


state 164

    (320) formal_part -> LPAREN . param_s RPAREN
    (321) param_s -> . param
    (322) param_s -> . param_s SEMICOLON param
    (323) param -> . def_id_s COLON mode mark init_opt
    (324) param -> . error
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s COMMA def_id
    (26) def_id -> . IDENTIFIER

    error           shift and go to state 108
    IDENTIFIER      shift and go to state 79

    param_s                        shift and go to state 267
    param                          shift and go to state 266
    def_id                         shift and go to state 96
    def_id_s                       shift and go to state 104

state 165

    (382) prot_body -> PROTECTED BODY . simple_name IS prot_op_body_s END id_opt SEMICOLON
    (454) body_stub -> PROTECTED BODY . simple_name IS SEPARATE SEMICOLON
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 40

    simple_name                    shift and go to state 268

state 166

    (367) prot_spec -> PROTECTED IDENTIFIER . prot_def
    (369) prot_def -> . IS prot_op_decl_s prot_private_opt END id_opt

    IS              shift and go to state 269

    prot_def                       shift and go to state 270

state 167

    (368) prot_spec -> PROTECTED TYPE . simple_name discrim_part_opt prot_def
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 40

    simple_name                    shift and go to state 271

state 168

    (298) block_body -> BEGIN . handled_stmt_s
    (299) handled_stmt_s -> . statement_s except_handler_part_opt
    (243) statement_s -> . statement
    (244) statement_s -> . statement_s statement
    (245) statement -> . unlabeled
    (246) statement -> . label statement
    (247) unlabeled -> . simple_stmt
    (248) unlabeled -> . compound_stmt
    (249) unlabeled -> . pragma
    (268) label -> . LLB IDENTIFIER RLB
    (250) simple_stmt -> . NULL_stmt
    (251) simple_stmt -> . assign_stmt
    (252) simple_stmt -> . exit_stmt
    (253) simple_stmt -> . return_stmt
    (254) simple_stmt -> . goto_stmt
    (255) simple_stmt -> . procedure_call
    (256) simple_stmt -> . delay_stmt
    (257) simple_stmt -> . abort_stmt
    (258) simple_stmt -> . raise_stmt
    (259) simple_stmt -> . code_stmt
    (260) simple_stmt -> . requeue_stmt
    (261) simple_stmt -> . error SEMICOLON
    (262) compound_stmt -> . if_stmt
    (263) compound_stmt -> . case_stmt
    (264) compound_stmt -> . loop_stmt
    (265) compound_stmt -> . block
    (266) compound_stmt -> . accept_stmt
    (267) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (269) NULL_stmt -> . NULL SEMICOLON
    (270) assign_stmt -> . name IS_ASSIGNED expression SEMICOLON
    (302) exit_stmt -> . EXIT name_opt when_opt SEMICOLON
    (307) return_stmt -> . RETURN SEMICOLON
    (308) return_stmt -> . RETURN expression SEMICOLON
    (309) goto_stmt -> . GOTO name SEMICOLON
    (332) procedure_call -> . name SEMICOLON
    (404) delay_stmt -> . DELAY expression SEMICOLON
    (405) delay_stmt -> . DELAY UNTIL expression SEMICOLON
    (425) abort_stmt -> . ABORT name_s SEMICOLON
    (464) raise_stmt -> . RAISE name_opt SEMICOLON
    (510) code_stmt -> . qualified SEMICOLON
    (465) requeue_stmt -> . REQUEUE name SEMICOLON
    (466) requeue_stmt -> . REQUEUE name WITH ABORT SEMICOLON
    (271) if_stmt -> . IF cond_clause else_opt END IF SEMICOLON
    (278) case_stmt -> . case_hdr alternative_s END CASE SEMICOLON
    (283) loop_stmt -> . label_opt iteration basic_loop id_opt SEMICOLON
    (295) block -> . label_opt block_decl block_body END id_opt SEMICOLON
    (399) accept_stmt -> . accept_hdr SEMICOLON
    (400) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt SEMICOLON
    (406) select_stmt -> . select_wait
    (407) select_stmt -> . async_select
    (408) select_stmt -> . timed_entry_call
    (409) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (240) qualified -> . name TICK parenthesized_primary
    (279) case_hdr -> . CASE expression IS
    (284) label_opt -> .
    (285) label_opt -> . IDENTIFIER COLON
    (401) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (410) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON
    (420) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON
    (421) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON
    (422) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    LLB             shift and go to state 289
    error           shift and go to state 309
    PRAGMA          shift and go to state 4
    NULL            shift and go to state 311
    EXIT            shift and go to state 308
    RETURN          shift and go to state 295
    GOTO            shift and go to state 276
    DELAY           shift and go to state 272
    ABORT           shift and go to state 282
    RAISE           shift and go to state 306
    REQUEUE         shift and go to state 298
    IF              shift and go to state 317
    CASE            shift and go to state 297
    WHILE           reduce using rule 284 (label_opt -> .)
    DECLARE         reduce using rule 284 (label_opt -> .)
    FOR             reduce using rule 284 (label_opt -> .)
    LOOP            reduce using rule 284 (label_opt -> .)
    BEGIN           reduce using rule 284 (label_opt -> .)
    IDENTIFIER      shift and go to state 300
    ACCEPT          shift and go to state 284
    SELECT          shift and go to state 286
    STRING          shift and go to state 137

    indexed_comp                   shift and go to state 119
    accept_stmt                    shift and go to state 283
    label_opt                      shift and go to state 275
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 316
    abort_stmt                     shift and go to state 310
    return_stmt                    shift and go to state 294
    procedure_call                 shift and go to state 285
    label                          shift and go to state 288
    statement_s                    shift and go to state 312
    simple_name                    shift and go to state 153
    code_stmt                      shift and go to state 313
    handled_stmt_s                 shift and go to state 296
    case_stmt                      shift and go to state 287
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 146
    assign_stmt                    shift and go to state 320
    exit_stmt                      shift and go to state 315
    select_stmt                    shift and go to state 274
    statement                      shift and go to state 299
    compound_stmt                  shift and go to state 290
    case_hdr                       shift and go to state 292
    delay_stmt                     shift and go to state 301
    unlabeled                      shift and go to state 314
    simple_stmt                    shift and go to state 277
    loop_stmt                      shift and go to state 278
    qualified                      shift and go to state 279
    pragma                         shift and go to state 303
    async_select                   shift and go to state 273
    requeue_stmt                   shift and go to state 304
    raise_stmt                     shift and go to state 305
    name                           shift and go to state 281
    if_stmt                        shift and go to state 280
    accept_hdr                     shift and go to state 302
    cond_entry_call                shift and go to state 318
    timed_entry_call               shift and go to state 307
    goto_stmt                      shift and go to state 291
    NULL_stmt                      shift and go to state 319
    block                          shift and go to state 293

state 169

    (331) subprog_body -> subprog_spec_is_push decl_part block_body . END id_opt SEMICOLON

    END             shift and go to state 321


state 170

    (503) attrib_def -> FOR mark . USE expression SEMICOLON
    (504) record_type_spec -> FOR mark . USE RECORD align_opt comp_loc_s END RECORD SEMICOLON
    (509) address_spec -> FOR mark . USE AT expression SEMICOLON
    (159) mark -> mark . TICK attribute_id
    (160) mark -> mark . DOT simple_name

    USE             shift and go to state 322
    TICK            shift and go to state 323
    DOT             shift and go to state 324


state 171

    (158) mark -> simple_name .

    TICK            reduce using rule 158 (mark -> simple_name .)
    DOT             reduce using rule 158 (mark -> simple_name .)
    IS_ASSIGNED     reduce using rule 158 (mark -> simple_name .)
    SEMICOLON       reduce using rule 158 (mark -> simple_name .)
    RPAREN          reduce using rule 158 (mark -> simple_name .)
    USE             reduce using rule 158 (mark -> simple_name .)
    AT              reduce using rule 158 (mark -> simple_name .)


state 172

    (358) task_decl -> task_spec SEMICOLON .

    PACKAGE         reduce using rule 358 (task_decl -> task_spec SEMICOLON .)
    TASK            reduce using rule 358 (task_decl -> task_spec SEMICOLON .)
    PROTECTED       reduce using rule 358 (task_decl -> task_spec SEMICOLON .)
    error           reduce using rule 358 (task_decl -> task_spec SEMICOLON .)
    USE             reduce using rule 358 (task_decl -> task_spec SEMICOLON .)
    PRAGMA          reduce using rule 358 (task_decl -> task_spec SEMICOLON .)
    TYPE            reduce using rule 358 (task_decl -> task_spec SEMICOLON .)
    SUBTYPE         reduce using rule 358 (task_decl -> task_spec SEMICOLON .)
    FOR             reduce using rule 358 (task_decl -> task_spec SEMICOLON .)
    PROCEDURE       reduce using rule 358 (task_decl -> task_spec SEMICOLON .)
    FUNCTION        reduce using rule 358 (task_decl -> task_spec SEMICOLON .)
    GENERIC         reduce using rule 358 (task_decl -> task_spec SEMICOLON .)
    IDENTIFIER      reduce using rule 358 (task_decl -> task_spec SEMICOLON .)
    BEGIN           reduce using rule 358 (task_decl -> task_spec SEMICOLON .)
    END             reduce using rule 358 (task_decl -> task_spec SEMICOLON .)
    PRIVATE         reduce using rule 358 (task_decl -> task_spec SEMICOLON .)


state 173

    (365) task_body -> TASK BODY . simple_name IS decl_part block_body END id_opt SEMICOLON
    (451) body_stub -> TASK BODY . simple_name IS SEPARATE SEMICOLON
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 40

    simple_name                    shift and go to state 325

state 174

    (360) task_spec -> TASK TYPE . simple_name discrim_part_opt task_def
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 40

    simple_name                    shift and go to state 326

state 175

    (359) task_spec -> TASK simple_name . task_def
    (361) task_def -> .
    (362) task_def -> . IS entry_decl_s rep_spec_s task_private_opt END id_opt

    SEMICOLON       reduce using rule 361 (task_def -> .)
    IS              shift and go to state 327

    task_def                       shift and go to state 328

state 176

    (146) decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .

    PACKAGE         reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    TASK            reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    PROTECTED       reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    error           reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    USE             reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    PRAGMA          reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    TYPE            reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    SUBTYPE         reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    FOR             reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    PROCEDURE       reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    FUNCTION        reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    GENERIC         reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    IDENTIFIER      reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    BEGIN           reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)
    END             reduce using rule 146 (decl_item_or_body_s1 -> decl_item_or_body_s1 decl_item_or_body .)


state 177

    (340) pkg_body -> PACKAGE BODY . compound_name IS decl_part body_opt END c_id_opt SEMICOLON
    (452) body_stub -> PACKAGE BODY . compound_name IS SEPARATE SEMICOLON
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name DOT simple_name
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 40

    compound_name                  shift and go to state 329
    simple_name                    shift and go to state 41

state 178

    (335) pkg_spec -> PACKAGE compound_name . IS decl_item_s private_part END c_id_opt
    (498) generic_pkg_inst -> PACKAGE compound_name . IS generic_inst
    (353) rename_unit -> PACKAGE compound_name . renames SEMICOLON
    (163) compound_name -> compound_name . DOT simple_name
    (357) renames -> . RENAMES name

    IS              shift and go to state 161
    DOT             shift and go to state 118
    RENAMES         shift and go to state 51

    renames                        shift and go to state 160

state 179

    (366) prot_decl -> prot_spec SEMICOLON .

    error           reduce using rule 366 (prot_decl -> prot_spec SEMICOLON .)
    USE             reduce using rule 366 (prot_decl -> prot_spec SEMICOLON .)
    PRAGMA          reduce using rule 366 (prot_decl -> prot_spec SEMICOLON .)
    TYPE            reduce using rule 366 (prot_decl -> prot_spec SEMICOLON .)
    SUBTYPE         reduce using rule 366 (prot_decl -> prot_spec SEMICOLON .)
    TASK            reduce using rule 366 (prot_decl -> prot_spec SEMICOLON .)
    PACKAGE         reduce using rule 366 (prot_decl -> prot_spec SEMICOLON .)
    PROTECTED       reduce using rule 366 (prot_decl -> prot_spec SEMICOLON .)
    FOR             reduce using rule 366 (prot_decl -> prot_spec SEMICOLON .)
    PROCEDURE       reduce using rule 366 (prot_decl -> prot_spec SEMICOLON .)
    FUNCTION        reduce using rule 366 (prot_decl -> prot_spec SEMICOLON .)
    GENERIC         reduce using rule 366 (prot_decl -> prot_spec SEMICOLON .)
    IDENTIFIER      reduce using rule 366 (prot_decl -> prot_spec SEMICOLON .)
    END             reduce using rule 366 (prot_decl -> prot_spec SEMICOLON .)
    BEGIN           reduce using rule 366 (prot_decl -> prot_spec SEMICOLON .)
    PRIVATE         reduce using rule 366 (prot_decl -> prot_spec SEMICOLON .)


state 180

    (22) decl -> error SEMICOLON .

    PACKAGE         reduce using rule 22 (decl -> error SEMICOLON .)
    TASK            reduce using rule 22 (decl -> error SEMICOLON .)
    PROTECTED       reduce using rule 22 (decl -> error SEMICOLON .)
    error           reduce using rule 22 (decl -> error SEMICOLON .)
    USE             reduce using rule 22 (decl -> error SEMICOLON .)
    PRAGMA          reduce using rule 22 (decl -> error SEMICOLON .)
    TYPE            reduce using rule 22 (decl -> error SEMICOLON .)
    SUBTYPE         reduce using rule 22 (decl -> error SEMICOLON .)
    FOR             reduce using rule 22 (decl -> error SEMICOLON .)
    PROCEDURE       reduce using rule 22 (decl -> error SEMICOLON .)
    FUNCTION        reduce using rule 22 (decl -> error SEMICOLON .)
    GENERIC         reduce using rule 22 (decl -> error SEMICOLON .)
    IDENTIFIER      reduce using rule 22 (decl -> error SEMICOLON .)
    BEGIN           reduce using rule 22 (decl -> error SEMICOLON .)
    END             reduce using rule 22 (decl -> error SEMICOLON .)
    PRIVATE         reduce using rule 22 (decl -> error SEMICOLON .)


state 181

    (36) type_decl -> TYPE IDENTIFIER . discrim_part_opt type_completion SEMICOLON
    (37) discrim_part_opt -> .
    (38) discrim_part_opt -> . discrim_part
    (39) discrim_part_opt -> . LPAREN BOX RPAREN
    (110) discrim_part -> . LPAREN discrim_spec_s RPAREN

    IS              reduce using rule 37 (discrim_part_opt -> .)
    SEMICOLON       reduce using rule 37 (discrim_part_opt -> .)
    LPAREN          shift and go to state 331

    discrim_part_opt               shift and go to state 330
    discrim_part                   shift and go to state 332

state 182

    (312) subprog_decl -> subprog_spec_is_push ABSTRACT SEMICOLON .

    PRIVATE         reduce using rule 312 (subprog_decl -> subprog_spec_is_push ABSTRACT SEMICOLON .)
    WITH            reduce using rule 312 (subprog_decl -> subprog_spec_is_push ABSTRACT SEMICOLON .)
    PACKAGE         reduce using rule 312 (subprog_decl -> subprog_spec_is_push ABSTRACT SEMICOLON .)
    SEPARATE        reduce using rule 312 (subprog_decl -> subprog_spec_is_push ABSTRACT SEMICOLON .)
    PROCEDURE       reduce using rule 312 (subprog_decl -> subprog_spec_is_push ABSTRACT SEMICOLON .)
    FUNCTION        reduce using rule 312 (subprog_decl -> subprog_spec_is_push ABSTRACT SEMICOLON .)
    GENERIC         reduce using rule 312 (subprog_decl -> subprog_spec_is_push ABSTRACT SEMICOLON .)
    $end            reduce using rule 312 (subprog_decl -> subprog_spec_is_push ABSTRACT SEMICOLON .)
    error           reduce using rule 312 (subprog_decl -> subprog_spec_is_push ABSTRACT SEMICOLON .)
    USE             reduce using rule 312 (subprog_decl -> subprog_spec_is_push ABSTRACT SEMICOLON .)
    PRAGMA          reduce using rule 312 (subprog_decl -> subprog_spec_is_push ABSTRACT SEMICOLON .)
    TYPE            reduce using rule 312 (subprog_decl -> subprog_spec_is_push ABSTRACT SEMICOLON .)
    SUBTYPE         reduce using rule 312 (subprog_decl -> subprog_spec_is_push ABSTRACT SEMICOLON .)
    TASK            reduce using rule 312 (subprog_decl -> subprog_spec_is_push ABSTRACT SEMICOLON .)
    PROTECTED       reduce using rule 312 (subprog_decl -> subprog_spec_is_push ABSTRACT SEMICOLON .)
    FOR             reduce using rule 312 (subprog_decl -> subprog_spec_is_push ABSTRACT SEMICOLON .)
    IDENTIFIER      reduce using rule 312 (subprog_decl -> subprog_spec_is_push ABSTRACT SEMICOLON .)
    END             reduce using rule 312 (subprog_decl -> subprog_spec_is_push ABSTRACT SEMICOLON .)
    BEGIN           reduce using rule 312 (subprog_decl -> subprog_spec_is_push ABSTRACT SEMICOLON .)


state 183

    (48) subtype_decl -> SUBTYPE IDENTIFIER . IS subtype_ind SEMICOLON

    IS              shift and go to state 333


state 184

    (330) subprog_spec_is_push -> subprog_spec IS .
    (453) body_stub -> subprog_spec IS . SEPARATE SEMICOLON
    (497) generic_subp_inst -> subprog_spec IS . generic_inst
    (499) generic_inst -> . NEW name

    ABSTRACT        reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    PACKAGE         reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    TASK            reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    PROTECTED       reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    error           reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    USE             reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    PRAGMA          reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    TYPE            reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    SUBTYPE         reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    FOR             reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    PROCEDURE       reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    FUNCTION        reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    GENERIC         reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    IDENTIFIER      reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    BEGIN           reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    SEPARATE        shift and go to state 334
    NEW             shift and go to state 157

    generic_inst                   shift and go to state 158

state 185

    (23) object_decl -> def_id_s COLON . object_qualifier_opt object_subtype_def init_opt SEMICOLON
    (35) number_decl -> def_id_s COLON . CONSTANT IS_ASSIGNED expression SEMICOLON
    (455) exception_decl -> def_id_s COLON . EXCEPTION SEMICOLON
    (350) rename_decl -> def_id_s COLON . object_qualifier_opt subtype_ind renames SEMICOLON
    (351) rename_decl -> def_id_s COLON . EXCEPTION renames SEMICOLON
    (27) object_qualifier_opt -> .
    (28) object_qualifier_opt -> . ALIASED
    (29) object_qualifier_opt -> . CONSTANT
    (30) object_qualifier_opt -> . ALIASED CONSTANT

    CONSTANT        shift and go to state 335
    EXCEPTION       shift and go to state 336
    ARRAY           reduce using rule 27 (object_qualifier_opt -> .)
    IDENTIFIER      reduce using rule 27 (object_qualifier_opt -> .)
    STRING          reduce using rule 27 (object_qualifier_opt -> .)
    ALIASED         shift and go to state 337

    object_qualifier_opt           shift and go to state 338

state 186

    (25) def_id_s -> def_id_s COMMA . def_id
    (26) def_id -> . IDENTIFIER

    IDENTIFIER      shift and go to state 79

    def_id                         shift and go to state 339

state 187

    (474) generic_formal -> WITH FUNCTION . designator formal_part_opt RETURN name subp_default SEMICOLON
    (316) designator -> . compound_name
    (317) designator -> . STRING
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name DOT simple_name
    (161) simple_name -> . IDENTIFIER

    STRING          shift and go to state 114
    IDENTIFIER      shift and go to state 40

    designator                     shift and go to state 340
    compound_name                  shift and go to state 113
    simple_name                    shift and go to state 41

state 188

    (475) generic_formal -> WITH PACKAGE . simple_name IS NEW name LPAREN BOX RPAREN SEMICOLON
    (476) generic_formal -> WITH PACKAGE . simple_name IS NEW name SEMICOLON
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 40

    simple_name                    shift and go to state 341

state 189

    (473) generic_formal -> WITH PROCEDURE . simple_name formal_part_opt subp_default SEMICOLON
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 40

    simple_name                    shift and go to state 342

state 190

    (471) generic_formal -> param SEMICOLON .

    PACKAGE         reduce using rule 471 (generic_formal -> param SEMICOLON .)
    PROCEDURE       reduce using rule 471 (generic_formal -> param SEMICOLON .)
    FUNCTION        reduce using rule 471 (generic_formal -> param SEMICOLON .)
    TYPE            reduce using rule 471 (generic_formal -> param SEMICOLON .)
    WITH            reduce using rule 471 (generic_formal -> param SEMICOLON .)
    error           reduce using rule 471 (generic_formal -> param SEMICOLON .)
    USE             reduce using rule 471 (generic_formal -> param SEMICOLON .)
    IDENTIFIER      reduce using rule 471 (generic_formal -> param SEMICOLON .)


state 191

    (467) generic_decl -> generic_formal_part subprog_spec SEMICOLON .

    PACKAGE         reduce using rule 467 (generic_decl -> generic_formal_part subprog_spec SEMICOLON .)
    TASK            reduce using rule 467 (generic_decl -> generic_formal_part subprog_spec SEMICOLON .)
    PROTECTED       reduce using rule 467 (generic_decl -> generic_formal_part subprog_spec SEMICOLON .)
    error           reduce using rule 467 (generic_decl -> generic_formal_part subprog_spec SEMICOLON .)
    USE             reduce using rule 467 (generic_decl -> generic_formal_part subprog_spec SEMICOLON .)
    PRAGMA          reduce using rule 467 (generic_decl -> generic_formal_part subprog_spec SEMICOLON .)
    TYPE            reduce using rule 467 (generic_decl -> generic_formal_part subprog_spec SEMICOLON .)
    SUBTYPE         reduce using rule 467 (generic_decl -> generic_formal_part subprog_spec SEMICOLON .)
    FOR             reduce using rule 467 (generic_decl -> generic_formal_part subprog_spec SEMICOLON .)
    PROCEDURE       reduce using rule 467 (generic_decl -> generic_formal_part subprog_spec SEMICOLON .)
    FUNCTION        reduce using rule 467 (generic_decl -> generic_formal_part subprog_spec SEMICOLON .)
    GENERIC         reduce using rule 467 (generic_decl -> generic_formal_part subprog_spec SEMICOLON .)
    IDENTIFIER      reduce using rule 467 (generic_decl -> generic_formal_part subprog_spec SEMICOLON .)
    BEGIN           reduce using rule 467 (generic_decl -> generic_formal_part subprog_spec SEMICOLON .)
    PRIVATE         reduce using rule 467 (generic_decl -> generic_formal_part subprog_spec SEMICOLON .)
    WITH            reduce using rule 467 (generic_decl -> generic_formal_part subprog_spec SEMICOLON .)
    SEPARATE        reduce using rule 467 (generic_decl -> generic_formal_part subprog_spec SEMICOLON .)
    $end            reduce using rule 467 (generic_decl -> generic_formal_part subprog_spec SEMICOLON .)
    END             reduce using rule 467 (generic_decl -> generic_formal_part subprog_spec SEMICOLON .)


state 192

    (356) rename_unit -> generic_formal_part subprog_spec renames . SEMICOLON

    SEMICOLON       shift and go to state 343


state 193

    (323) param -> def_id_s COLON . mode mark init_opt
    (325) mode -> .
    (326) mode -> . IN
    (327) mode -> . OUT
    (328) mode -> . IN OUT
    (329) mode -> . ACCESS

    IDENTIFIER      reduce using rule 325 (mode -> .)
    IN              shift and go to state 345
    OUT             shift and go to state 346
    ACCESS          shift and go to state 344

    mode                           shift and go to state 347

state 194

    (355) rename_unit -> generic_formal_part PACKAGE compound_name . renames SEMICOLON
    (335) pkg_spec -> PACKAGE compound_name . IS decl_item_s private_part END c_id_opt
    (163) compound_name -> compound_name . DOT simple_name
    (357) renames -> . RENAMES name

    IS              shift and go to state 349
    DOT             shift and go to state 118
    RENAMES         shift and go to state 51

    renames                        shift and go to state 348

state 195

    (468) generic_decl -> generic_formal_part pkg_spec SEMICOLON .

    PACKAGE         reduce using rule 468 (generic_decl -> generic_formal_part pkg_spec SEMICOLON .)
    TASK            reduce using rule 468 (generic_decl -> generic_formal_part pkg_spec SEMICOLON .)
    PROTECTED       reduce using rule 468 (generic_decl -> generic_formal_part pkg_spec SEMICOLON .)
    error           reduce using rule 468 (generic_decl -> generic_formal_part pkg_spec SEMICOLON .)
    USE             reduce using rule 468 (generic_decl -> generic_formal_part pkg_spec SEMICOLON .)
    PRAGMA          reduce using rule 468 (generic_decl -> generic_formal_part pkg_spec SEMICOLON .)
    TYPE            reduce using rule 468 (generic_decl -> generic_formal_part pkg_spec SEMICOLON .)
    SUBTYPE         reduce using rule 468 (generic_decl -> generic_formal_part pkg_spec SEMICOLON .)
    FOR             reduce using rule 468 (generic_decl -> generic_formal_part pkg_spec SEMICOLON .)
    PROCEDURE       reduce using rule 468 (generic_decl -> generic_formal_part pkg_spec SEMICOLON .)
    FUNCTION        reduce using rule 468 (generic_decl -> generic_formal_part pkg_spec SEMICOLON .)
    GENERIC         reduce using rule 468 (generic_decl -> generic_formal_part pkg_spec SEMICOLON .)
    IDENTIFIER      reduce using rule 468 (generic_decl -> generic_formal_part pkg_spec SEMICOLON .)
    BEGIN           reduce using rule 468 (generic_decl -> generic_formal_part pkg_spec SEMICOLON .)
    PRIVATE         reduce using rule 468 (generic_decl -> generic_formal_part pkg_spec SEMICOLON .)
    WITH            reduce using rule 468 (generic_decl -> generic_formal_part pkg_spec SEMICOLON .)
    SEPARATE        reduce using rule 468 (generic_decl -> generic_formal_part pkg_spec SEMICOLON .)
    $end            reduce using rule 468 (generic_decl -> generic_formal_part pkg_spec SEMICOLON .)
    END             reduce using rule 468 (generic_decl -> generic_formal_part pkg_spec SEMICOLON .)


state 196

    (472) generic_formal -> TYPE simple_name . generic_discrim_part_opt IS generic_type_def SEMICOLON
    (478) generic_discrim_part_opt -> .
    (479) generic_discrim_part_opt -> . discrim_part
    (480) generic_discrim_part_opt -> . LPAREN BOX RPAREN
    (110) discrim_part -> . LPAREN discrim_spec_s RPAREN

    IS              reduce using rule 478 (generic_discrim_part_opt -> .)
    LPAREN          shift and go to state 351

    generic_discrim_part_opt       shift and go to state 350
    discrim_part                   shift and go to state 352

state 197

    (314) subprog_spec -> FUNCTION designator formal_part_opt . RETURN name

    RETURN          shift and go to state 353


state 198

    (165) c_name_list -> c_name_list COMMA compound_name .
    (163) compound_name -> compound_name . DOT simple_name

    SEMICOLON       reduce using rule 165 (c_name_list -> c_name_list COMMA compound_name .)
    COMMA           reduce using rule 165 (c_name_list -> c_name_list COMMA compound_name .)
    DOT             shift and go to state 118


state 199

    (163) compound_name -> compound_name DOT simple_name .

    IS              reduce using rule 163 (compound_name -> compound_name DOT simple_name .)
    DOT             reduce using rule 163 (compound_name -> compound_name DOT simple_name .)
    SEMICOLON       reduce using rule 163 (compound_name -> compound_name DOT simple_name .)
    COMMA           reduce using rule 163 (compound_name -> compound_name DOT simple_name .)
    RENAMES         reduce using rule 163 (compound_name -> compound_name DOT simple_name .)
    LPAREN          reduce using rule 163 (compound_name -> compound_name DOT simple_name .)
    RETURN          reduce using rule 163 (compound_name -> compound_name DOT simple_name .)
    RPAREN          reduce using rule 163 (compound_name -> compound_name DOT simple_name .)


state 200

    (232) factor -> primary POW . primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    name                           shift and go to state 145
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 146
    primary                        shift and go to state 354
    used_char                      shift and go to state 143
    literal                        shift and go to state 135
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153

state 201

    (215) simple_expression -> unary term .
    (224) term -> term . multiplying factor
    (225) multiplying -> . TIMES
    (226) multiplying -> . DIVIDE
    (227) multiplying -> . MOD
    (228) multiplying -> . REM

    DOUBLEDOT       reduce using rule 215 (simple_expression -> unary term .)
    PLUS            reduce using rule 215 (simple_expression -> unary term .)
    MINUS           reduce using rule 215 (simple_expression -> unary term .)
    AMPERSAND       reduce using rule 215 (simple_expression -> unary term .)
    COMMA           reduce using rule 215 (simple_expression -> unary term .)
    ARROW           reduce using rule 215 (simple_expression -> unary term .)
    |               reduce using rule 215 (simple_expression -> unary term .)
    AND             reduce using rule 215 (simple_expression -> unary term .)
    OR              reduce using rule 215 (simple_expression -> unary term .)
    XOR             reduce using rule 215 (simple_expression -> unary term .)
    RPAREN          reduce using rule 215 (simple_expression -> unary term .)
    WITH            reduce using rule 215 (simple_expression -> unary term .)
    SEMICOLON       reduce using rule 215 (simple_expression -> unary term .)
    IS              reduce using rule 215 (simple_expression -> unary term .)
    THEN            reduce using rule 215 (simple_expression -> unary term .)
    LOOP            reduce using rule 215 (simple_expression -> unary term .)
    RANGE           reduce using rule 215 (simple_expression -> unary term .)
    DIGITS          reduce using rule 215 (simple_expression -> unary term .)
    RENAMES         reduce using rule 215 (simple_expression -> unary term .)
    IS_ASSIGNED     reduce using rule 215 (simple_expression -> unary term .)
    EQ              reduce using rule 215 (simple_expression -> unary term .)
    NE              reduce using rule 215 (simple_expression -> unary term .)
    LT              reduce using rule 215 (simple_expression -> unary term .)
    LE              reduce using rule 215 (simple_expression -> unary term .)
    GT              reduce using rule 215 (simple_expression -> unary term .)
    GE              reduce using rule 215 (simple_expression -> unary term .)
    IN              reduce using rule 215 (simple_expression -> unary term .)
    NOT             reduce using rule 215 (simple_expression -> unary term .)
    TIMES           shift and go to state 238
    DIVIDE          shift and go to state 236
    MOD             shift and go to state 239
    REM             shift and go to state 237

    multiplying                    shift and go to state 235

state 202

    (241) allocator -> NEW name .
    (240) qualified -> name . TICK parenthesized_primary
    (168) indexed_comp -> name . LPAREN value_s RPAREN
    (175) selected_comp -> name . DOT simple_name
    (176) selected_comp -> name . DOT used_char
    (177) selected_comp -> name . DOT operator_symbol
    (178) selected_comp -> name . DOT ALL
    (179) attribute -> name . TICK attribute_id

    POW             reduce using rule 241 (allocator -> NEW name .)
    TIMES           reduce using rule 241 (allocator -> NEW name .)
    DIVIDE          reduce using rule 241 (allocator -> NEW name .)
    MOD             reduce using rule 241 (allocator -> NEW name .)
    REM             reduce using rule 241 (allocator -> NEW name .)
    EQ              reduce using rule 241 (allocator -> NEW name .)
    NE              reduce using rule 241 (allocator -> NEW name .)
    LT              reduce using rule 241 (allocator -> NEW name .)
    LE              reduce using rule 241 (allocator -> NEW name .)
    GT              reduce using rule 241 (allocator -> NEW name .)
    GE              reduce using rule 241 (allocator -> NEW name .)
    IN              reduce using rule 241 (allocator -> NEW name .)
    NOT             reduce using rule 241 (allocator -> NEW name .)
    PLUS            reduce using rule 241 (allocator -> NEW name .)
    MINUS           reduce using rule 241 (allocator -> NEW name .)
    AMPERSAND       reduce using rule 241 (allocator -> NEW name .)
    AND             reduce using rule 241 (allocator -> NEW name .)
    OR              reduce using rule 241 (allocator -> NEW name .)
    XOR             reduce using rule 241 (allocator -> NEW name .)
    RPAREN          reduce using rule 241 (allocator -> NEW name .)
    COMMA           reduce using rule 241 (allocator -> NEW name .)
    WITH            reduce using rule 241 (allocator -> NEW name .)
    ARROW           reduce using rule 241 (allocator -> NEW name .)
    |               reduce using rule 241 (allocator -> NEW name .)
    SEMICOLON       reduce using rule 241 (allocator -> NEW name .)
    IS              reduce using rule 241 (allocator -> NEW name .)
    THEN            reduce using rule 241 (allocator -> NEW name .)
    LOOP            reduce using rule 241 (allocator -> NEW name .)
    RANGE           reduce using rule 241 (allocator -> NEW name .)
    DIGITS          reduce using rule 241 (allocator -> NEW name .)
    RENAMES         reduce using rule 241 (allocator -> NEW name .)
    IS_ASSIGNED     reduce using rule 241 (allocator -> NEW name .)
    DOUBLEDOT       reduce using rule 241 (allocator -> NEW name .)
    TICK            shift and go to state 241
    LPAREN          shift and go to state 240
    DOT             shift and go to state 242


state 203

    (242) allocator -> NEW qualified .

    POW             reduce using rule 242 (allocator -> NEW qualified .)
    TIMES           reduce using rule 242 (allocator -> NEW qualified .)
    DIVIDE          reduce using rule 242 (allocator -> NEW qualified .)
    MOD             reduce using rule 242 (allocator -> NEW qualified .)
    REM             reduce using rule 242 (allocator -> NEW qualified .)
    EQ              reduce using rule 242 (allocator -> NEW qualified .)
    NE              reduce using rule 242 (allocator -> NEW qualified .)
    LT              reduce using rule 242 (allocator -> NEW qualified .)
    LE              reduce using rule 242 (allocator -> NEW qualified .)
    GT              reduce using rule 242 (allocator -> NEW qualified .)
    GE              reduce using rule 242 (allocator -> NEW qualified .)
    IN              reduce using rule 242 (allocator -> NEW qualified .)
    NOT             reduce using rule 242 (allocator -> NEW qualified .)
    PLUS            reduce using rule 242 (allocator -> NEW qualified .)
    MINUS           reduce using rule 242 (allocator -> NEW qualified .)
    AMPERSAND       reduce using rule 242 (allocator -> NEW qualified .)
    AND             reduce using rule 242 (allocator -> NEW qualified .)
    OR              reduce using rule 242 (allocator -> NEW qualified .)
    XOR             reduce using rule 242 (allocator -> NEW qualified .)
    RPAREN          reduce using rule 242 (allocator -> NEW qualified .)
    COMMA           reduce using rule 242 (allocator -> NEW qualified .)
    WITH            reduce using rule 242 (allocator -> NEW qualified .)
    ARROW           reduce using rule 242 (allocator -> NEW qualified .)
    |               reduce using rule 242 (allocator -> NEW qualified .)
    SEMICOLON       reduce using rule 242 (allocator -> NEW qualified .)
    IS              reduce using rule 242 (allocator -> NEW qualified .)
    THEN            reduce using rule 242 (allocator -> NEW qualified .)
    LOOP            reduce using rule 242 (allocator -> NEW qualified .)
    RANGE           reduce using rule 242 (allocator -> NEW qualified .)
    DIGITS          reduce using rule 242 (allocator -> NEW qualified .)
    RENAMES         reduce using rule 242 (allocator -> NEW qualified .)
    IS_ASSIGNED     reduce using rule 242 (allocator -> NEW qualified .)
    DOUBLEDOT       reduce using rule 242 (allocator -> NEW qualified .)


state 204

    (217) simple_expression -> simple_expression adding . term
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    factor                         shift and go to state 136
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    term                           shift and go to state 355
    name                           shift and go to state 145
    operator_symbol                shift and go to state 146

state 205

    (210) relational -> LE .

    PLUS            reduce using rule 210 (relational -> LE .)
    MINUS           reduce using rule 210 (relational -> LE .)
    NOT             reduce using rule 210 (relational -> LE .)
    ABS             reduce using rule 210 (relational -> LE .)
    NUMBER          reduce using rule 210 (relational -> LE .)
    NULL            reduce using rule 210 (relational -> LE .)
    NEW             reduce using rule 210 (relational -> LE .)
    LPAREN          reduce using rule 210 (relational -> LE .)
    CHARACTER       reduce using rule 210 (relational -> LE .)
    IDENTIFIER      reduce using rule 210 (relational -> LE .)
    STRING          reduce using rule 210 (relational -> LE .)


state 206

    (212) relational -> GE .

    PLUS            reduce using rule 212 (relational -> GE .)
    MINUS           reduce using rule 212 (relational -> GE .)
    NOT             reduce using rule 212 (relational -> GE .)
    ABS             reduce using rule 212 (relational -> GE .)
    NUMBER          reduce using rule 212 (relational -> GE .)
    NULL            reduce using rule 212 (relational -> GE .)
    NEW             reduce using rule 212 (relational -> GE .)
    LPAREN          reduce using rule 212 (relational -> GE .)
    CHARACTER       reduce using rule 212 (relational -> GE .)
    IDENTIFIER      reduce using rule 212 (relational -> GE .)
    STRING          reduce using rule 212 (relational -> GE .)


state 207

    (222) adding -> AMPERSAND .

    NOT             reduce using rule 222 (adding -> AMPERSAND .)
    ABS             reduce using rule 222 (adding -> AMPERSAND .)
    NUMBER          reduce using rule 222 (adding -> AMPERSAND .)
    NULL            reduce using rule 222 (adding -> AMPERSAND .)
    NEW             reduce using rule 222 (adding -> AMPERSAND .)
    LPAREN          reduce using rule 222 (adding -> AMPERSAND .)
    CHARACTER       reduce using rule 222 (adding -> AMPERSAND .)
    IDENTIFIER      reduce using rule 222 (adding -> AMPERSAND .)
    STRING          reduce using rule 222 (adding -> AMPERSAND .)


state 208

    (209) relational -> LT .

    PLUS            reduce using rule 209 (relational -> LT .)
    MINUS           reduce using rule 209 (relational -> LT .)
    NOT             reduce using rule 209 (relational -> LT .)
    ABS             reduce using rule 209 (relational -> LT .)
    NUMBER          reduce using rule 209 (relational -> LT .)
    NULL            reduce using rule 209 (relational -> LT .)
    NEW             reduce using rule 209 (relational -> LT .)
    LPAREN          reduce using rule 209 (relational -> LT .)
    CHARACTER       reduce using rule 209 (relational -> LT .)
    IDENTIFIER      reduce using rule 209 (relational -> LT .)
    STRING          reduce using rule 209 (relational -> LT .)


state 209

    (205) relation -> simple_expression membership . range
    (206) relation -> simple_expression membership . name
    (60) range -> . simple_expression DOUBLEDOT simple_expression
    (61) range -> . name TICK RANGE
    (62) range -> . name TICK RANGE LPAREN expression RPAREN
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN

    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137
    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    simple_expression              shift and go to state 356
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    factor                         shift and go to state 136
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    term                           shift and go to state 144
    name                           shift and go to state 357
    operator_symbol                shift and go to state 146
    range                          shift and go to state 358

state 210

    (208) relational -> NE .

    PLUS            reduce using rule 208 (relational -> NE .)
    MINUS           reduce using rule 208 (relational -> NE .)
    NOT             reduce using rule 208 (relational -> NE .)
    ABS             reduce using rule 208 (relational -> NE .)
    NUMBER          reduce using rule 208 (relational -> NE .)
    NULL            reduce using rule 208 (relational -> NE .)
    NEW             reduce using rule 208 (relational -> NE .)
    LPAREN          reduce using rule 208 (relational -> NE .)
    CHARACTER       reduce using rule 208 (relational -> NE .)
    IDENTIFIER      reduce using rule 208 (relational -> NE .)
    STRING          reduce using rule 208 (relational -> NE .)


state 211

    (211) relational -> GT .

    PLUS            reduce using rule 211 (relational -> GT .)
    MINUS           reduce using rule 211 (relational -> GT .)
    NOT             reduce using rule 211 (relational -> GT .)
    ABS             reduce using rule 211 (relational -> GT .)
    NUMBER          reduce using rule 211 (relational -> GT .)
    NULL            reduce using rule 211 (relational -> GT .)
    NEW             reduce using rule 211 (relational -> GT .)
    LPAREN          reduce using rule 211 (relational -> GT .)
    CHARACTER       reduce using rule 211 (relational -> GT .)
    IDENTIFIER      reduce using rule 211 (relational -> GT .)
    STRING          reduce using rule 211 (relational -> GT .)


state 212

    (220) adding -> PLUS .

    NOT             reduce using rule 220 (adding -> PLUS .)
    ABS             reduce using rule 220 (adding -> PLUS .)
    NUMBER          reduce using rule 220 (adding -> PLUS .)
    NULL            reduce using rule 220 (adding -> PLUS .)
    NEW             reduce using rule 220 (adding -> PLUS .)
    LPAREN          reduce using rule 220 (adding -> PLUS .)
    CHARACTER       reduce using rule 220 (adding -> PLUS .)
    IDENTIFIER      reduce using rule 220 (adding -> PLUS .)
    STRING          reduce using rule 220 (adding -> PLUS .)


state 213

    (213) membership -> IN .

    IDENTIFIER      reduce using rule 213 (membership -> IN .)
    STRING          reduce using rule 213 (membership -> IN .)
    PLUS            reduce using rule 213 (membership -> IN .)
    MINUS           reduce using rule 213 (membership -> IN .)
    NOT             reduce using rule 213 (membership -> IN .)
    ABS             reduce using rule 213 (membership -> IN .)
    NUMBER          reduce using rule 213 (membership -> IN .)
    NULL            reduce using rule 213 (membership -> IN .)
    NEW             reduce using rule 213 (membership -> IN .)
    LPAREN          reduce using rule 213 (membership -> IN .)
    CHARACTER       reduce using rule 213 (membership -> IN .)


state 214

    (214) membership -> NOT . IN

    IN              shift and go to state 359


state 215

    (204) relation -> simple_expression relational . simple_expression
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    simple_expression              shift and go to state 360
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    factor                         shift and go to state 136
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    term                           shift and go to state 144
    name                           shift and go to state 145
    operator_symbol                shift and go to state 146

state 216

    (207) relational -> EQ .

    PLUS            reduce using rule 207 (relational -> EQ .)
    MINUS           reduce using rule 207 (relational -> EQ .)
    NOT             reduce using rule 207 (relational -> EQ .)
    ABS             reduce using rule 207 (relational -> EQ .)
    NUMBER          reduce using rule 207 (relational -> EQ .)
    NULL            reduce using rule 207 (relational -> EQ .)
    NEW             reduce using rule 207 (relational -> EQ .)
    LPAREN          reduce using rule 207 (relational -> EQ .)
    CHARACTER       reduce using rule 207 (relational -> EQ .)
    IDENTIFIER      reduce using rule 207 (relational -> EQ .)
    STRING          reduce using rule 207 (relational -> EQ .)


state 217

    (221) adding -> MINUS .

    NOT             reduce using rule 221 (adding -> MINUS .)
    ABS             reduce using rule 221 (adding -> MINUS .)
    NUMBER          reduce using rule 221 (adding -> MINUS .)
    NULL            reduce using rule 221 (adding -> MINUS .)
    NEW             reduce using rule 221 (adding -> MINUS .)
    LPAREN          reduce using rule 221 (adding -> MINUS .)
    CHARACTER       reduce using rule 221 (adding -> MINUS .)
    IDENTIFIER      reduce using rule 221 (adding -> MINUS .)
    STRING          reduce using rule 221 (adding -> MINUS .)


state 218

    (7) pragma_arg -> simple_name ARROW . expression
    (195) expression -> . relation
    (196) expression -> . expression logical relation
    (197) expression -> . expression short_circuit relation
    (203) relation -> . simple_expression
    (204) relation -> . simple_expression relational simple_expression
    (205) relation -> . simple_expression membership range
    (206) relation -> . simple_expression membership name
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    relation                       shift and go to state 127
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    factor                         shift and go to state 136
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    term                           shift and go to state 144
    name                           shift and go to state 145
    operator_symbol                shift and go to state 146
    expression                     shift and go to state 361

state 219

    (3) pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 362


state 220

    (5) pragma_arg_s -> pragma_arg_s COMMA . pragma_arg
    (6) pragma_arg -> . expression
    (7) pragma_arg -> . simple_name ARROW expression
    (195) expression -> . relation
    (196) expression -> . expression logical relation
    (197) expression -> . expression short_circuit relation
    (161) simple_name -> . IDENTIFIER
    (203) relation -> . simple_expression
    (204) relation -> . simple_expression relational simple_expression
    (205) relation -> . simple_expression membership range
    (206) relation -> . simple_expression membership name
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 40
    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122
    STRING          shift and go to state 137

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    pragma_arg                     shift and go to state 363
    unary                          shift and go to state 125
    relation                       shift and go to state 127
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 133
    literal                        shift and go to state 135
    factor                         shift and go to state 136
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    used_char                      shift and go to state 143
    term                           shift and go to state 144
    name                           shift and go to state 145
    operator_symbol                shift and go to state 146
    expression                     shift and go to state 149

state 221

    (231) factor -> ABS primary .

    TIMES           reduce using rule 231 (factor -> ABS primary .)
    DIVIDE          reduce using rule 231 (factor -> ABS primary .)
    MOD             reduce using rule 231 (factor -> ABS primary .)
    REM             reduce using rule 231 (factor -> ABS primary .)
    DOUBLEDOT       reduce using rule 231 (factor -> ABS primary .)
    EQ              reduce using rule 231 (factor -> ABS primary .)
    NE              reduce using rule 231 (factor -> ABS primary .)
    LT              reduce using rule 231 (factor -> ABS primary .)
    LE              reduce using rule 231 (factor -> ABS primary .)
    GT              reduce using rule 231 (factor -> ABS primary .)
    GE              reduce using rule 231 (factor -> ABS primary .)
    IN              reduce using rule 231 (factor -> ABS primary .)
    NOT             reduce using rule 231 (factor -> ABS primary .)
    PLUS            reduce using rule 231 (factor -> ABS primary .)
    MINUS           reduce using rule 231 (factor -> ABS primary .)
    AMPERSAND       reduce using rule 231 (factor -> ABS primary .)
    AND             reduce using rule 231 (factor -> ABS primary .)
    OR              reduce using rule 231 (factor -> ABS primary .)
    XOR             reduce using rule 231 (factor -> ABS primary .)
    RPAREN          reduce using rule 231 (factor -> ABS primary .)
    COMMA           reduce using rule 231 (factor -> ABS primary .)
    ARROW           reduce using rule 231 (factor -> ABS primary .)
    |               reduce using rule 231 (factor -> ABS primary .)
    DIGITS          reduce using rule 231 (factor -> ABS primary .)
    RANGE           reduce using rule 231 (factor -> ABS primary .)
    SEMICOLON       reduce using rule 231 (factor -> ABS primary .)
    IS              reduce using rule 231 (factor -> ABS primary .)
    THEN            reduce using rule 231 (factor -> ABS primary .)
    LOOP            reduce using rule 231 (factor -> ABS primary .)
    WITH            reduce using rule 231 (factor -> ABS primary .)
    RENAMES         reduce using rule 231 (factor -> ABS primary .)
    IS_ASSIGNED     reduce using rule 231 (factor -> ABS primary .)


state 222

    (125) choice -> OTHERS .

    ARROW           reduce using rule 125 (choice -> OTHERS .)
    |               reduce using rule 125 (choice -> OTHERS .)


state 223

    (203) relation -> simple_expression .
    (204) relation -> simple_expression . relational simple_expression
    (205) relation -> simple_expression . membership range
    (206) relation -> simple_expression . membership name
    (217) simple_expression -> simple_expression . adding term
    (60) range -> simple_expression . DOUBLEDOT simple_expression
    (207) relational -> . EQ
    (208) relational -> . NE
    (209) relational -> . LT
    (210) relational -> . LE
    (211) relational -> . GT
    (212) relational -> . GE
    (213) membership -> . IN
    (214) membership -> . NOT IN
    (220) adding -> . PLUS
    (221) adding -> . MINUS
    (222) adding -> . AMPERSAND

    RPAREN          reduce using rule 203 (relation -> simple_expression .)
    WITH            reduce using rule 203 (relation -> simple_expression .)
    AND             reduce using rule 203 (relation -> simple_expression .)
    OR              reduce using rule 203 (relation -> simple_expression .)
    XOR             reduce using rule 203 (relation -> simple_expression .)
    COMMA           reduce using rule 203 (relation -> simple_expression .)
    ARROW           reduce using rule 203 (relation -> simple_expression .)
    |               reduce using rule 203 (relation -> simple_expression .)
    DOUBLEDOT       shift and go to state 364
    EQ              shift and go to state 216
    NE              shift and go to state 210
    LT              shift and go to state 208
    LE              shift and go to state 205
    GT              shift and go to state 211
    GE              shift and go to state 206
    IN              shift and go to state 213
    NOT             shift and go to state 214
    PLUS            shift and go to state 212
    MINUS           shift and go to state 217
    AMPERSAND       shift and go to state 207

    adding                         shift and go to state 204
    membership                     shift and go to state 209
    relational                     shift and go to state 215

state 224

    (191) aggregate -> LPAREN NULL . RECORD RPAREN
    (186) literal -> NULL .

    RECORD          shift and go to state 365
    POW             reduce using rule 186 (literal -> NULL .)
    TIMES           reduce using rule 186 (literal -> NULL .)
    DIVIDE          reduce using rule 186 (literal -> NULL .)
    MOD             reduce using rule 186 (literal -> NULL .)
    REM             reduce using rule 186 (literal -> NULL .)
    DOUBLEDOT       reduce using rule 186 (literal -> NULL .)
    EQ              reduce using rule 186 (literal -> NULL .)
    NE              reduce using rule 186 (literal -> NULL .)
    LT              reduce using rule 186 (literal -> NULL .)
    LE              reduce using rule 186 (literal -> NULL .)
    GT              reduce using rule 186 (literal -> NULL .)
    GE              reduce using rule 186 (literal -> NULL .)
    IN              reduce using rule 186 (literal -> NULL .)
    NOT             reduce using rule 186 (literal -> NULL .)
    PLUS            reduce using rule 186 (literal -> NULL .)
    MINUS           reduce using rule 186 (literal -> NULL .)
    AMPERSAND       reduce using rule 186 (literal -> NULL .)
    RPAREN          reduce using rule 186 (literal -> NULL .)
    WITH            reduce using rule 186 (literal -> NULL .)
    AND             reduce using rule 186 (literal -> NULL .)
    OR              reduce using rule 186 (literal -> NULL .)
    XOR             reduce using rule 186 (literal -> NULL .)
    COMMA           reduce using rule 186 (literal -> NULL .)
    ARROW           reduce using rule 186 (literal -> NULL .)
    |               reduce using rule 186 (literal -> NULL .)


state 225

    (194) comp_assoc -> choice_s . ARROW expression
    (122) choice_s -> choice_s . | choice

    ARROW           shift and go to state 367
    |               shift and go to state 366


state 226

    (187) aggregate -> LPAREN comp_assoc . RPAREN
    (172) value -> comp_assoc .

    RPAREN          shift and go to state 368
    COMMA           reduce using rule 172 (value -> comp_assoc .)


state 227

    (121) choice_s -> choice .

    ARROW           reduce using rule 121 (choice_s -> choice .)
    |               reduce using rule 121 (choice_s -> choice .)


state 228

    (188) aggregate -> LPAREN value_s_2 . RPAREN
    (193) value_s_2 -> value_s_2 . COMMA value

    RPAREN          shift and go to state 370
    COMMA           shift and go to state 369


state 229

    (173) value -> discrete_with_range .
    (124) choice -> discrete_with_range .

    RPAREN          reduce using rule 173 (value -> discrete_with_range .)
    COMMA           reduce using rule 173 (value -> discrete_with_range .)
    ARROW           reduce using rule 124 (choice -> discrete_with_range .)
    |               reduce using rule 124 (choice -> discrete_with_range .)


state 230

    (126) discrete_with_range -> name . range_constraint
    (61) range -> name . TICK RANGE
    (62) range -> name . TICK RANGE LPAREN expression RPAREN
    (168) indexed_comp -> name . LPAREN value_s RPAREN
    (175) selected_comp -> name . DOT simple_name
    (176) selected_comp -> name . DOT used_char
    (177) selected_comp -> name . DOT operator_symbol
    (178) selected_comp -> name . DOT ALL
    (179) attribute -> name . TICK attribute_id
    (237) primary -> name .
    (240) qualified -> name . TICK parenthesized_primary
    (59) range_constraint -> . RANGE range

    TICK            shift and go to state 373
    LPAREN          shift and go to state 240
    DOT             shift and go to state 242
    POW             reduce using rule 237 (primary -> name .)
    TIMES           reduce using rule 237 (primary -> name .)
    DIVIDE          reduce using rule 237 (primary -> name .)
    MOD             reduce using rule 237 (primary -> name .)
    REM             reduce using rule 237 (primary -> name .)
    DOUBLEDOT       reduce using rule 237 (primary -> name .)
    EQ              reduce using rule 237 (primary -> name .)
    NE              reduce using rule 237 (primary -> name .)
    LT              reduce using rule 237 (primary -> name .)
    LE              reduce using rule 237 (primary -> name .)
    GT              reduce using rule 237 (primary -> name .)
    GE              reduce using rule 237 (primary -> name .)
    IN              reduce using rule 237 (primary -> name .)
    NOT             reduce using rule 237 (primary -> name .)
    PLUS            reduce using rule 237 (primary -> name .)
    MINUS           reduce using rule 237 (primary -> name .)
    AMPERSAND       reduce using rule 237 (primary -> name .)
    AND             reduce using rule 237 (primary -> name .)
    OR              reduce using rule 237 (primary -> name .)
    XOR             reduce using rule 237 (primary -> name .)
    RPAREN          reduce using rule 237 (primary -> name .)
    COMMA           reduce using rule 237 (primary -> name .)
    ARROW           reduce using rule 237 (primary -> name .)
    |               reduce using rule 237 (primary -> name .)
    WITH            reduce using rule 237 (primary -> name .)
    RANGE           shift and go to state 371

    range_constraint               shift and go to state 372

state 231

    (192) value_s_2 -> value . COMMA value

    COMMA           shift and go to state 374


state 232

    (127) discrete_with_range -> range .

    ARROW           reduce using rule 127 (discrete_with_range -> range .)
    |               reduce using rule 127 (discrete_with_range -> range .)
    RPAREN          reduce using rule 127 (discrete_with_range -> range .)
    COMMA           reduce using rule 127 (discrete_with_range -> range .)


state 233

    (174) value -> error .

    RPAREN          reduce using rule 174 (value -> error .)
    COMMA           reduce using rule 174 (value -> error .)


state 234

    (239) parenthesized_primary -> LPAREN expression . RPAREN
    (189) aggregate -> LPAREN expression . WITH value_s RPAREN
    (190) aggregate -> LPAREN expression . WITH NULL RECORD RPAREN
    (196) expression -> expression . logical relation
    (197) expression -> expression . short_circuit relation
    (171) value -> expression .
    (123) choice -> expression .
    (198) logical -> . AND
    (199) logical -> . OR
    (200) logical -> . XOR
    (201) short_circuit -> . AND THEN
    (202) short_circuit -> . OR ELSE

    RPAREN          shift and go to state 375
    WITH            shift and go to state 376
    COMMA           reduce using rule 171 (value -> expression .)
    ARROW           reduce using rule 123 (choice -> expression .)
    |               reduce using rule 123 (choice -> expression .)
    AND             shift and go to state 244
    OR              shift and go to state 248
    XOR             shift and go to state 245

    logical                        shift and go to state 246
    short_circuit                  shift and go to state 247

state 235

    (224) term -> term multiplying . factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    name                           shift and go to state 145
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 146
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    literal                        shift and go to state 135
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    factor                         shift and go to state 377
    aggregate                      shift and go to state 126
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153

state 236

    (226) multiplying -> DIVIDE .

    NOT             reduce using rule 226 (multiplying -> DIVIDE .)
    ABS             reduce using rule 226 (multiplying -> DIVIDE .)
    NUMBER          reduce using rule 226 (multiplying -> DIVIDE .)
    NULL            reduce using rule 226 (multiplying -> DIVIDE .)
    NEW             reduce using rule 226 (multiplying -> DIVIDE .)
    LPAREN          reduce using rule 226 (multiplying -> DIVIDE .)
    CHARACTER       reduce using rule 226 (multiplying -> DIVIDE .)
    IDENTIFIER      reduce using rule 226 (multiplying -> DIVIDE .)
    STRING          reduce using rule 226 (multiplying -> DIVIDE .)


state 237

    (228) multiplying -> REM .

    NOT             reduce using rule 228 (multiplying -> REM .)
    ABS             reduce using rule 228 (multiplying -> REM .)
    NUMBER          reduce using rule 228 (multiplying -> REM .)
    NULL            reduce using rule 228 (multiplying -> REM .)
    NEW             reduce using rule 228 (multiplying -> REM .)
    LPAREN          reduce using rule 228 (multiplying -> REM .)
    CHARACTER       reduce using rule 228 (multiplying -> REM .)
    IDENTIFIER      reduce using rule 228 (multiplying -> REM .)
    STRING          reduce using rule 228 (multiplying -> REM .)


state 238

    (225) multiplying -> TIMES .

    NOT             reduce using rule 225 (multiplying -> TIMES .)
    ABS             reduce using rule 225 (multiplying -> TIMES .)
    NUMBER          reduce using rule 225 (multiplying -> TIMES .)
    NULL            reduce using rule 225 (multiplying -> TIMES .)
    NEW             reduce using rule 225 (multiplying -> TIMES .)
    LPAREN          reduce using rule 225 (multiplying -> TIMES .)
    CHARACTER       reduce using rule 225 (multiplying -> TIMES .)
    IDENTIFIER      reduce using rule 225 (multiplying -> TIMES .)
    STRING          reduce using rule 225 (multiplying -> TIMES .)


state 239

    (227) multiplying -> MOD .

    NOT             reduce using rule 227 (multiplying -> MOD .)
    ABS             reduce using rule 227 (multiplying -> MOD .)
    NUMBER          reduce using rule 227 (multiplying -> MOD .)
    NULL            reduce using rule 227 (multiplying -> MOD .)
    NEW             reduce using rule 227 (multiplying -> MOD .)
    LPAREN          reduce using rule 227 (multiplying -> MOD .)
    CHARACTER       reduce using rule 227 (multiplying -> MOD .)
    IDENTIFIER      reduce using rule 227 (multiplying -> MOD .)
    STRING          reduce using rule 227 (multiplying -> MOD .)


state 240

    (168) indexed_comp -> name LPAREN . value_s RPAREN
    (169) value_s -> . value
    (170) value_s -> . value_s COMMA value
    (171) value -> . expression
    (172) value -> . comp_assoc
    (173) value -> . discrete_with_range
    (174) value -> . error
    (195) expression -> . relation
    (196) expression -> . expression logical relation
    (197) expression -> . expression short_circuit relation
    (194) comp_assoc -> . choice_s ARROW expression
    (126) discrete_with_range -> . name range_constraint
    (127) discrete_with_range -> . range
    (203) relation -> . simple_expression
    (204) relation -> . simple_expression relational simple_expression
    (205) relation -> . simple_expression membership range
    (206) relation -> . simple_expression membership name
    (121) choice_s -> . choice
    (122) choice_s -> . choice_s | choice
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (60) range -> . simple_expression DOUBLEDOT simple_expression
    (61) range -> . name TICK RANGE
    (62) range -> . name TICK RANGE LPAREN expression RPAREN
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (123) choice -> . expression
    (124) choice -> . discrete_with_range
    (125) choice -> . OTHERS
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN

    error           shift and go to state 233
    OTHERS          shift and go to state 222
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137
    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    relation                       shift and go to state 127
    value_s                        shift and go to state 381
    simple_expression              shift and go to state 379
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    choice_s                       shift and go to state 225
    comp_assoc                     shift and go to state 380
    factor                         shift and go to state 136
    choice                         shift and go to state 227
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    discrete_with_range            shift and go to state 229
    term                           shift and go to state 144
    name                           shift and go to state 230
    operator_symbol                shift and go to state 146
    value                          shift and go to state 378
    range                          shift and go to state 232
    expression                     shift and go to state 382

state 241

    (240) qualified -> name TICK . parenthesized_primary
    (179) attribute -> name TICK . attribute_id
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (180) attribute_id -> . IDENTIFIER
    (181) attribute_id -> . DIGITS
    (182) attribute_id -> . DELTA
    (183) attribute_id -> . ACCESS
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN

    LPAREN          shift and go to state 142
    IDENTIFIER      shift and go to state 384
    DIGITS          shift and go to state 383
    DELTA           shift and go to state 387
    ACCESS          shift and go to state 385

    attribute_id                   shift and go to state 386
    aggregate                      shift and go to state 126
    parenthesized_primary          shift and go to state 388

state 242

    (175) selected_comp -> name DOT . simple_name
    (176) selected_comp -> name DOT . used_char
    (177) selected_comp -> name DOT . operator_symbol
    (178) selected_comp -> name DOT . ALL
    (161) simple_name -> . IDENTIFIER
    (166) used_char -> . CHARACTER
    (167) operator_symbol -> . STRING

    ALL             shift and go to state 389
    IDENTIFIER      shift and go to state 40
    CHARACTER       shift and go to state 122
    STRING          shift and go to state 137

    used_char                      shift and go to state 391
    operator_symbol                shift and go to state 390
    simple_name                    shift and go to state 392

state 243

    (230) factor -> NOT primary .

    TIMES           reduce using rule 230 (factor -> NOT primary .)
    DIVIDE          reduce using rule 230 (factor -> NOT primary .)
    MOD             reduce using rule 230 (factor -> NOT primary .)
    REM             reduce using rule 230 (factor -> NOT primary .)
    DOUBLEDOT       reduce using rule 230 (factor -> NOT primary .)
    EQ              reduce using rule 230 (factor -> NOT primary .)
    NE              reduce using rule 230 (factor -> NOT primary .)
    LT              reduce using rule 230 (factor -> NOT primary .)
    LE              reduce using rule 230 (factor -> NOT primary .)
    GT              reduce using rule 230 (factor -> NOT primary .)
    GE              reduce using rule 230 (factor -> NOT primary .)
    IN              reduce using rule 230 (factor -> NOT primary .)
    NOT             reduce using rule 230 (factor -> NOT primary .)
    PLUS            reduce using rule 230 (factor -> NOT primary .)
    MINUS           reduce using rule 230 (factor -> NOT primary .)
    AMPERSAND       reduce using rule 230 (factor -> NOT primary .)
    AND             reduce using rule 230 (factor -> NOT primary .)
    OR              reduce using rule 230 (factor -> NOT primary .)
    XOR             reduce using rule 230 (factor -> NOT primary .)
    RPAREN          reduce using rule 230 (factor -> NOT primary .)
    COMMA           reduce using rule 230 (factor -> NOT primary .)
    ARROW           reduce using rule 230 (factor -> NOT primary .)
    |               reduce using rule 230 (factor -> NOT primary .)
    DIGITS          reduce using rule 230 (factor -> NOT primary .)
    RANGE           reduce using rule 230 (factor -> NOT primary .)
    SEMICOLON       reduce using rule 230 (factor -> NOT primary .)
    IS              reduce using rule 230 (factor -> NOT primary .)
    THEN            reduce using rule 230 (factor -> NOT primary .)
    LOOP            reduce using rule 230 (factor -> NOT primary .)
    WITH            reduce using rule 230 (factor -> NOT primary .)
    RENAMES         reduce using rule 230 (factor -> NOT primary .)
    IS_ASSIGNED     reduce using rule 230 (factor -> NOT primary .)


state 244

    (198) logical -> AND .
    (201) short_circuit -> AND . THEN

    PLUS            reduce using rule 198 (logical -> AND .)
    MINUS           reduce using rule 198 (logical -> AND .)
    NOT             reduce using rule 198 (logical -> AND .)
    ABS             reduce using rule 198 (logical -> AND .)
    NUMBER          reduce using rule 198 (logical -> AND .)
    NULL            reduce using rule 198 (logical -> AND .)
    NEW             reduce using rule 198 (logical -> AND .)
    LPAREN          reduce using rule 198 (logical -> AND .)
    CHARACTER       reduce using rule 198 (logical -> AND .)
    IDENTIFIER      reduce using rule 198 (logical -> AND .)
    STRING          reduce using rule 198 (logical -> AND .)
    THEN            shift and go to state 393


state 245

    (200) logical -> XOR .

    PLUS            reduce using rule 200 (logical -> XOR .)
    MINUS           reduce using rule 200 (logical -> XOR .)
    NOT             reduce using rule 200 (logical -> XOR .)
    ABS             reduce using rule 200 (logical -> XOR .)
    NUMBER          reduce using rule 200 (logical -> XOR .)
    NULL            reduce using rule 200 (logical -> XOR .)
    NEW             reduce using rule 200 (logical -> XOR .)
    LPAREN          reduce using rule 200 (logical -> XOR .)
    CHARACTER       reduce using rule 200 (logical -> XOR .)
    IDENTIFIER      reduce using rule 200 (logical -> XOR .)
    STRING          reduce using rule 200 (logical -> XOR .)


state 246

    (196) expression -> expression logical . relation
    (203) relation -> . simple_expression
    (204) relation -> . simple_expression relational simple_expression
    (205) relation -> . simple_expression membership range
    (206) relation -> . simple_expression membership name
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    relation                       shift and go to state 394
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    factor                         shift and go to state 136
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    term                           shift and go to state 144
    name                           shift and go to state 145
    operator_symbol                shift and go to state 146

state 247

    (197) expression -> expression short_circuit . relation
    (203) relation -> . simple_expression
    (204) relation -> . simple_expression relational simple_expression
    (205) relation -> . simple_expression membership range
    (206) relation -> . simple_expression membership name
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    relation                       shift and go to state 395
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    factor                         shift and go to state 136
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    term                           shift and go to state 144
    name                           shift and go to state 145
    operator_symbol                shift and go to state 146

state 248

    (199) logical -> OR .
    (202) short_circuit -> OR . ELSE

    PLUS            reduce using rule 199 (logical -> OR .)
    MINUS           reduce using rule 199 (logical -> OR .)
    NOT             reduce using rule 199 (logical -> OR .)
    ABS             reduce using rule 199 (logical -> OR .)
    NUMBER          reduce using rule 199 (logical -> OR .)
    NULL            reduce using rule 199 (logical -> OR .)
    NEW             reduce using rule 199 (logical -> OR .)
    LPAREN          reduce using rule 199 (logical -> OR .)
    CHARACTER       reduce using rule 199 (logical -> OR .)
    IDENTIFIER      reduce using rule 199 (logical -> OR .)
    STRING          reduce using rule 199 (logical -> OR .)
    ELSE            shift and go to state 396


state 249

    (349) name_s -> name_s COMMA . name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    name                           shift and go to state 397
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 146
    indexed_comp                   shift and go to state 119
    simple_name                    shift and go to state 153

state 250

    (346) use_clause -> USE name_s SEMICOLON .

    error           reduce using rule 346 (use_clause -> USE name_s SEMICOLON .)
    USE             reduce using rule 346 (use_clause -> USE name_s SEMICOLON .)
    PRAGMA          reduce using rule 346 (use_clause -> USE name_s SEMICOLON .)
    TYPE            reduce using rule 346 (use_clause -> USE name_s SEMICOLON .)
    SUBTYPE         reduce using rule 346 (use_clause -> USE name_s SEMICOLON .)
    TASK            reduce using rule 346 (use_clause -> USE name_s SEMICOLON .)
    PACKAGE         reduce using rule 346 (use_clause -> USE name_s SEMICOLON .)
    PROTECTED       reduce using rule 346 (use_clause -> USE name_s SEMICOLON .)
    FOR             reduce using rule 346 (use_clause -> USE name_s SEMICOLON .)
    PROCEDURE       reduce using rule 346 (use_clause -> USE name_s SEMICOLON .)
    FUNCTION        reduce using rule 346 (use_clause -> USE name_s SEMICOLON .)
    GENERIC         reduce using rule 346 (use_clause -> USE name_s SEMICOLON .)
    IDENTIFIER      reduce using rule 346 (use_clause -> USE name_s SEMICOLON .)
    END             reduce using rule 346 (use_clause -> USE name_s SEMICOLON .)
    PRIVATE         reduce using rule 346 (use_clause -> USE name_s SEMICOLON .)
    WITH            reduce using rule 346 (use_clause -> USE name_s SEMICOLON .)
    SEPARATE        reduce using rule 346 (use_clause -> USE name_s SEMICOLON .)
    BEGIN           reduce using rule 346 (use_clause -> USE name_s SEMICOLON .)


state 251

    (179) attribute -> name TICK . attribute_id
    (180) attribute_id -> . IDENTIFIER
    (181) attribute_id -> . DIGITS
    (182) attribute_id -> . DELTA
    (183) attribute_id -> . ACCESS

    IDENTIFIER      shift and go to state 384
    DIGITS          shift and go to state 383
    DELTA           shift and go to state 387
    ACCESS          shift and go to state 385

    attribute_id                   shift and go to state 386

state 252

    (347) use_clause -> USE TYPE name_s . SEMICOLON
    (349) name_s -> name_s . COMMA name

    SEMICOLON       shift and go to state 398
    COMMA           shift and go to state 249


state 253

    (446) subunit -> SEPARATE LPAREN compound_name RPAREN . subunit_body
    (447) subunit_body -> . subprog_body
    (448) subunit_body -> . pkg_body
    (449) subunit_body -> . task_body
    (450) subunit_body -> . prot_body
    (331) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt SEMICOLON
    (340) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt SEMICOLON
    (365) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt SEMICOLON
    (382) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt SEMICOLON
    (330) subprog_spec_is_push -> . subprog_spec IS
    (313) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (314) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (315) subprog_spec -> . FUNCTION designator

    PACKAGE         shift and go to state 405
    TASK            shift and go to state 403
    PROTECTED       shift and go to state 401
    PROCEDURE       shift and go to state 30
    FUNCTION        shift and go to state 36

    subprog_body                   shift and go to state 399
    subprog_spec_is_push           shift and go to state 406
    prot_body                      shift and go to state 407
    pkg_body                       shift and go to state 408
    task_body                      shift and go to state 400
    subprog_spec                   shift and go to state 404
    subunit_body                   shift and go to state 402

state 254

    (499) generic_inst -> NEW name .
    (168) indexed_comp -> name . LPAREN value_s RPAREN
    (175) selected_comp -> name . DOT simple_name
    (176) selected_comp -> name . DOT used_char
    (177) selected_comp -> name . DOT operator_symbol
    (178) selected_comp -> name . DOT ALL
    (179) attribute -> name . TICK attribute_id

    SEMICOLON       reduce using rule 499 (generic_inst -> NEW name .)
    LPAREN          shift and go to state 240
    DOT             shift and go to state 242
    TICK            shift and go to state 251


state 255

    (340) pkg_body -> PACKAGE BODY compound_name IS . decl_part body_opt END c_id_opt SEMICOLON
    (135) decl_part -> .
    (136) decl_part -> . decl_item_or_body_s1
    (145) decl_item_or_body_s1 -> . decl_item_or_body
    (146) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (147) decl_item_or_body -> . body
    (148) decl_item_or_body -> . decl_item
    (149) body -> . subprog_body
    (150) body -> . pkg_body
    (151) body -> . task_body
    (152) body -> . prot_body
    (141) decl_item -> . decl
    (142) decl_item -> . use_clause
    (143) decl_item -> . rep_spec
    (144) decl_item -> . pragma
    (331) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt SEMICOLON
    (340) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt SEMICOLON
    (365) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt SEMICOLON
    (382) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt SEMICOLON
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error SEMICOLON
    (346) use_clause -> . USE name_s SEMICOLON
    (347) use_clause -> . USE TYPE name_s SEMICOLON
    (500) rep_spec -> . attrib_def
    (501) rep_spec -> . record_type_spec
    (502) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (330) subprog_spec_is_push -> . subprog_spec IS
    (23) object_decl -> . def_id_s COLON object_qualifier_opt object_subtype_def init_opt SEMICOLON
    (35) number_decl -> . def_id_s COLON CONSTANT IS_ASSIGNED expression SEMICOLON
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion SEMICOLON
    (48) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind SEMICOLON
    (310) subprog_decl -> . subprog_spec SEMICOLON
    (311) subprog_decl -> . generic_subp_inst SEMICOLON
    (312) subprog_decl -> . subprog_spec_is_push ABSTRACT SEMICOLON
    (333) pkg_decl -> . pkg_spec SEMICOLON
    (334) pkg_decl -> . generic_pkg_inst SEMICOLON
    (358) task_decl -> . task_spec SEMICOLON
    (366) prot_decl -> . prot_spec SEMICOLON
    (455) exception_decl -> . def_id_s COLON EXCEPTION SEMICOLON
    (350) rename_decl -> . def_id_s COLON object_qualifier_opt subtype_ind renames SEMICOLON
    (351) rename_decl -> . def_id_s COLON EXCEPTION renames SEMICOLON
    (352) rename_decl -> . rename_unit
    (467) generic_decl -> . generic_formal_part subprog_spec SEMICOLON
    (468) generic_decl -> . generic_formal_part pkg_spec SEMICOLON
    (451) body_stub -> . TASK BODY simple_name IS SEPARATE SEMICOLON
    (452) body_stub -> . PACKAGE BODY compound_name IS SEPARATE SEMICOLON
    (453) body_stub -> . subprog_spec IS SEPARATE SEMICOLON
    (454) body_stub -> . PROTECTED BODY simple_name IS SEPARATE SEMICOLON
    (503) attrib_def -> . FOR mark USE expression SEMICOLON
    (504) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD SEMICOLON
    (509) address_spec -> . FOR mark USE AT expression SEMICOLON
    (313) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (314) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (315) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s COMMA def_id
    (497) generic_subp_inst -> . subprog_spec IS generic_inst
    (335) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (498) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (359) task_spec -> . TASK simple_name task_def
    (360) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (367) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (368) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (353) rename_unit -> . PACKAGE compound_name renames SEMICOLON
    (354) rename_unit -> . subprog_spec renames SEMICOLON
    (355) rename_unit -> . generic_formal_part PACKAGE compound_name renames SEMICOLON
    (356) rename_unit -> . generic_formal_part subprog_spec renames SEMICOLON
    (469) generic_formal_part -> . GENERIC
    (470) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    BEGIN           reduce using rule 135 (decl_part -> .)
    END             reduce using rule 135 (decl_part -> .)
    PACKAGE         shift and go to state 80
    TASK            shift and go to state 74
    PROTECTED       shift and go to state 58
    error           shift and go to state 85
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 87
    SUBTYPE         shift and go to state 91
    FOR             shift and go to state 70
    PROCEDURE       shift and go to state 30
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 79

    decl                           shift and go to state 57
    subprog_body                   shift and go to state 66
    task_decl                      shift and go to state 67
    type_decl                      shift and go to state 63
    rep_spec                       shift and go to state 89
    task_body                      shift and go to state 90
    subtype_decl                   shift and go to state 68
    exception_decl                 shift and go to state 92
    address_spec                   shift and go to state 59
    subprog_spec_is_push           shift and go to state 93
    decl_part                      shift and go to state 409
    prot_decl                      shift and go to state 62
    record_type_spec               shift and go to state 75
    generic_decl                   shift and go to state 76
    def_id                         shift and go to state 96
    attrib_def                     shift and go to state 77
    subprog_spec                   shift and go to state 94
    def_id_s                       shift and go to state 95
    decl_item_or_body_s1           shift and go to state 78
    decl_item                      shift and go to state 60
    task_spec                      shift and go to state 72
    body                           shift and go to state 69
    object_decl                    shift and go to state 71
    body_stub                      shift and go to state 81
    pkg_spec                       shift and go to state 37
    rename_decl                    shift and go to state 97
    generic_subp_inst              shift and go to state 28
    pragma                         shift and go to state 82
    rename_unit                    shift and go to state 98
    subprog_decl                   shift and go to state 65
    pkg_decl                       shift and go to state 64
    prot_spec                      shift and go to state 83
    generic_formal_part            shift and go to state 33
    prot_body                      shift and go to state 99
    use_clause                     shift and go to state 73
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 84
    decl_item_or_body              shift and go to state 86
    number_decl                    shift and go to state 100

state 256

    (353) rename_unit -> PACKAGE compound_name renames SEMICOLON .

    PACKAGE         reduce using rule 353 (rename_unit -> PACKAGE compound_name renames SEMICOLON .)
    TASK            reduce using rule 353 (rename_unit -> PACKAGE compound_name renames SEMICOLON .)
    PROTECTED       reduce using rule 353 (rename_unit -> PACKAGE compound_name renames SEMICOLON .)
    error           reduce using rule 353 (rename_unit -> PACKAGE compound_name renames SEMICOLON .)
    USE             reduce using rule 353 (rename_unit -> PACKAGE compound_name renames SEMICOLON .)
    PRAGMA          reduce using rule 353 (rename_unit -> PACKAGE compound_name renames SEMICOLON .)
    TYPE            reduce using rule 353 (rename_unit -> PACKAGE compound_name renames SEMICOLON .)
    SUBTYPE         reduce using rule 353 (rename_unit -> PACKAGE compound_name renames SEMICOLON .)
    FOR             reduce using rule 353 (rename_unit -> PACKAGE compound_name renames SEMICOLON .)
    PROCEDURE       reduce using rule 353 (rename_unit -> PACKAGE compound_name renames SEMICOLON .)
    FUNCTION        reduce using rule 353 (rename_unit -> PACKAGE compound_name renames SEMICOLON .)
    GENERIC         reduce using rule 353 (rename_unit -> PACKAGE compound_name renames SEMICOLON .)
    IDENTIFIER      reduce using rule 353 (rename_unit -> PACKAGE compound_name renames SEMICOLON .)
    BEGIN           reduce using rule 353 (rename_unit -> PACKAGE compound_name renames SEMICOLON .)
    PRIVATE         reduce using rule 353 (rename_unit -> PACKAGE compound_name renames SEMICOLON .)
    END             reduce using rule 353 (rename_unit -> PACKAGE compound_name renames SEMICOLON .)
    WITH            reduce using rule 353 (rename_unit -> PACKAGE compound_name renames SEMICOLON .)
    SEPARATE        reduce using rule 353 (rename_unit -> PACKAGE compound_name renames SEMICOLON .)
    $end            reduce using rule 353 (rename_unit -> PACKAGE compound_name renames SEMICOLON .)


state 257

    (498) generic_pkg_inst -> PACKAGE compound_name IS generic_inst .

    SEMICOLON       reduce using rule 498 (generic_pkg_inst -> PACKAGE compound_name IS generic_inst .)


state 258

    (138) decl_item_s -> decl_item_s1 .
    (140) decl_item_s1 -> decl_item_s1 . decl_item
    (141) decl_item -> . decl
    (142) decl_item -> . use_clause
    (143) decl_item -> . rep_spec
    (144) decl_item -> . pragma
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error SEMICOLON
    (346) use_clause -> . USE name_s SEMICOLON
    (347) use_clause -> . USE TYPE name_s SEMICOLON
    (500) rep_spec -> . attrib_def
    (501) rep_spec -> . record_type_spec
    (502) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (23) object_decl -> . def_id_s COLON object_qualifier_opt object_subtype_def init_opt SEMICOLON
    (35) number_decl -> . def_id_s COLON CONSTANT IS_ASSIGNED expression SEMICOLON
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion SEMICOLON
    (48) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind SEMICOLON
    (310) subprog_decl -> . subprog_spec SEMICOLON
    (311) subprog_decl -> . generic_subp_inst SEMICOLON
    (312) subprog_decl -> . subprog_spec_is_push ABSTRACT SEMICOLON
    (333) pkg_decl -> . pkg_spec SEMICOLON
    (334) pkg_decl -> . generic_pkg_inst SEMICOLON
    (358) task_decl -> . task_spec SEMICOLON
    (366) prot_decl -> . prot_spec SEMICOLON
    (455) exception_decl -> . def_id_s COLON EXCEPTION SEMICOLON
    (350) rename_decl -> . def_id_s COLON object_qualifier_opt subtype_ind renames SEMICOLON
    (351) rename_decl -> . def_id_s COLON EXCEPTION renames SEMICOLON
    (352) rename_decl -> . rename_unit
    (467) generic_decl -> . generic_formal_part subprog_spec SEMICOLON
    (468) generic_decl -> . generic_formal_part pkg_spec SEMICOLON
    (451) body_stub -> . TASK BODY simple_name IS SEPARATE SEMICOLON
    (452) body_stub -> . PACKAGE BODY compound_name IS SEPARATE SEMICOLON
    (453) body_stub -> . subprog_spec IS SEPARATE SEMICOLON
    (454) body_stub -> . PROTECTED BODY simple_name IS SEPARATE SEMICOLON
    (503) attrib_def -> . FOR mark USE expression SEMICOLON
    (504) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD SEMICOLON
    (509) address_spec -> . FOR mark USE AT expression SEMICOLON
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s COMMA def_id
    (313) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (314) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (315) subprog_spec -> . FUNCTION designator
    (497) generic_subp_inst -> . subprog_spec IS generic_inst
    (330) subprog_spec_is_push -> . subprog_spec IS
    (335) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (498) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (359) task_spec -> . TASK simple_name task_def
    (360) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (367) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (368) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (353) rename_unit -> . PACKAGE compound_name renames SEMICOLON
    (354) rename_unit -> . subprog_spec renames SEMICOLON
    (355) rename_unit -> . generic_formal_part PACKAGE compound_name renames SEMICOLON
    (356) rename_unit -> . generic_formal_part subprog_spec renames SEMICOLON
    (469) generic_formal_part -> . GENERIC
    (470) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    PRIVATE         reduce using rule 138 (decl_item_s -> decl_item_s1 .)
    END             reduce using rule 138 (decl_item_s -> decl_item_s1 .)
    error           shift and go to state 85
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 87
    SUBTYPE         shift and go to state 91
    TASK            shift and go to state 262
    PACKAGE         shift and go to state 263
    PROTECTED       shift and go to state 259
    FOR             shift and go to state 70
    PROCEDURE       shift and go to state 30
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 79

    decl                           shift and go to state 57
    task_decl                      shift and go to state 67
    subtype_decl                   shift and go to state 68
    rep_spec                       shift and go to state 89
    exception_decl                 shift and go to state 92
    address_spec                   shift and go to state 59
    decl_item                      shift and go to state 410
    subprog_spec_is_push           shift and go to state 264
    prot_decl                      shift and go to state 62
    record_type_spec               shift and go to state 75
    generic_decl                   shift and go to state 76
    attrib_def                     shift and go to state 77
    subprog_spec                   shift and go to state 265
    def_id_s                       shift and go to state 95
    task_spec                      shift and go to state 72
    object_decl                    shift and go to state 71
    body_stub                      shift and go to state 81
    generic_subp_inst              shift and go to state 28
    def_id                         shift and go to state 96
    rename_decl                    shift and go to state 97
    type_decl                      shift and go to state 63
    rename_unit                    shift and go to state 98
    pkg_decl                       shift and go to state 64
    prot_spec                      shift and go to state 83
    generic_formal_part            shift and go to state 33
    use_clause                     shift and go to state 73
    generic_pkg_inst               shift and go to state 34
    subprog_decl                   shift and go to state 65
    pragma                         shift and go to state 82
    pkg_spec                       shift and go to state 37
    number_decl                    shift and go to state 100

state 259

    (454) body_stub -> PROTECTED . BODY simple_name IS SEPARATE SEMICOLON
    (367) prot_spec -> PROTECTED . IDENTIFIER prot_def
    (368) prot_spec -> PROTECTED . TYPE simple_name discrim_part_opt prot_def

    BODY            shift and go to state 411
    IDENTIFIER      shift and go to state 166
    TYPE            shift and go to state 167


state 260

    (139) decl_item_s1 -> decl_item .

    error           reduce using rule 139 (decl_item_s1 -> decl_item .)
    USE             reduce using rule 139 (decl_item_s1 -> decl_item .)
    PRAGMA          reduce using rule 139 (decl_item_s1 -> decl_item .)
    TYPE            reduce using rule 139 (decl_item_s1 -> decl_item .)
    SUBTYPE         reduce using rule 139 (decl_item_s1 -> decl_item .)
    TASK            reduce using rule 139 (decl_item_s1 -> decl_item .)
    PACKAGE         reduce using rule 139 (decl_item_s1 -> decl_item .)
    PROTECTED       reduce using rule 139 (decl_item_s1 -> decl_item .)
    FOR             reduce using rule 139 (decl_item_s1 -> decl_item .)
    PROCEDURE       reduce using rule 139 (decl_item_s1 -> decl_item .)
    FUNCTION        reduce using rule 139 (decl_item_s1 -> decl_item .)
    GENERIC         reduce using rule 139 (decl_item_s1 -> decl_item .)
    IDENTIFIER      reduce using rule 139 (decl_item_s1 -> decl_item .)
    PRIVATE         reduce using rule 139 (decl_item_s1 -> decl_item .)
    END             reduce using rule 139 (decl_item_s1 -> decl_item .)


state 261

    (335) pkg_spec -> PACKAGE compound_name IS decl_item_s . private_part END c_id_opt
    (336) private_part -> .
    (337) private_part -> . PRIVATE decl_item_s

    END             reduce using rule 336 (private_part -> .)
    PRIVATE         shift and go to state 412

    private_part                   shift and go to state 413

state 262

    (451) body_stub -> TASK . BODY simple_name IS SEPARATE SEMICOLON
    (359) task_spec -> TASK . simple_name task_def
    (360) task_spec -> TASK . TYPE simple_name discrim_part_opt task_def
    (161) simple_name -> . IDENTIFIER

    BODY            shift and go to state 414
    TYPE            shift and go to state 174
    IDENTIFIER      shift and go to state 40

    simple_name                    shift and go to state 175

state 263

    (452) body_stub -> PACKAGE . BODY compound_name IS SEPARATE SEMICOLON
    (335) pkg_spec -> PACKAGE . compound_name IS decl_item_s private_part END c_id_opt
    (498) generic_pkg_inst -> PACKAGE . compound_name IS generic_inst
    (353) rename_unit -> PACKAGE . compound_name renames SEMICOLON
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name DOT simple_name
    (161) simple_name -> . IDENTIFIER

    BODY            shift and go to state 415
    IDENTIFIER      shift and go to state 40

    simple_name                    shift and go to state 41
    compound_name                  shift and go to state 178

state 264

    (312) subprog_decl -> subprog_spec_is_push . ABSTRACT SEMICOLON

    ABSTRACT        shift and go to state 88


state 265

    (310) subprog_decl -> subprog_spec . SEMICOLON
    (453) body_stub -> subprog_spec . IS SEPARATE SEMICOLON
    (497) generic_subp_inst -> subprog_spec . IS generic_inst
    (330) subprog_spec_is_push -> subprog_spec . IS
    (354) rename_unit -> subprog_spec . renames SEMICOLON
    (357) renames -> . RENAMES name

    SEMICOLON       shift and go to state 49
    IS              shift and go to state 416
    RENAMES         shift and go to state 51

    renames                        shift and go to state 50

state 266

    (321) param_s -> param .

    RPAREN          reduce using rule 321 (param_s -> param .)
    SEMICOLON       reduce using rule 321 (param_s -> param .)


state 267

    (320) formal_part -> LPAREN param_s . RPAREN
    (322) param_s -> param_s . SEMICOLON param

    RPAREN          shift and go to state 418
    SEMICOLON       shift and go to state 417


state 268

    (382) prot_body -> PROTECTED BODY simple_name . IS prot_op_body_s END id_opt SEMICOLON
    (454) body_stub -> PROTECTED BODY simple_name . IS SEPARATE SEMICOLON

    IS              shift and go to state 419


state 269

    (369) prot_def -> IS . prot_op_decl_s prot_private_opt END id_opt
    (372) prot_op_decl_s -> .
    (373) prot_op_decl_s -> . prot_op_decl_s prot_op_decl

    PRIVATE         reduce using rule 372 (prot_op_decl_s -> .)
    ENTRY           reduce using rule 372 (prot_op_decl_s -> .)
    PROCEDURE       reduce using rule 372 (prot_op_decl_s -> .)
    FUNCTION        reduce using rule 372 (prot_op_decl_s -> .)
    PRAGMA          reduce using rule 372 (prot_op_decl_s -> .)
    FOR             reduce using rule 372 (prot_op_decl_s -> .)
    END             reduce using rule 372 (prot_op_decl_s -> .)

    prot_op_decl_s                 shift and go to state 420

state 270

    (367) prot_spec -> PROTECTED IDENTIFIER prot_def .

    SEMICOLON       reduce using rule 367 (prot_spec -> PROTECTED IDENTIFIER prot_def .)


state 271

    (368) prot_spec -> PROTECTED TYPE simple_name . discrim_part_opt prot_def
    (37) discrim_part_opt -> .
    (38) discrim_part_opt -> . discrim_part
    (39) discrim_part_opt -> . LPAREN BOX RPAREN
    (110) discrim_part -> . LPAREN discrim_spec_s RPAREN

    IS              reduce using rule 37 (discrim_part_opt -> .)
    LPAREN          shift and go to state 331

    discrim_part_opt               shift and go to state 421
    discrim_part                   shift and go to state 332

state 272

    (404) delay_stmt -> DELAY . expression SEMICOLON
    (405) delay_stmt -> DELAY . UNTIL expression SEMICOLON
    (195) expression -> . relation
    (196) expression -> . expression logical relation
    (197) expression -> . expression short_circuit relation
    (203) relation -> . simple_expression
    (204) relation -> . simple_expression relational simple_expression
    (205) relation -> . simple_expression membership range
    (206) relation -> . simple_expression membership name
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    UNTIL           shift and go to state 422
    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    relation                       shift and go to state 127
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    factor                         shift and go to state 136
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    term                           shift and go to state 144
    name                           shift and go to state 145
    operator_symbol                shift and go to state 146
    expression                     shift and go to state 423

state 273

    (407) select_stmt -> async_select .

    END             reduce using rule 407 (select_stmt -> async_select .)
    LLB             reduce using rule 407 (select_stmt -> async_select .)
    error           reduce using rule 407 (select_stmt -> async_select .)
    PRAGMA          reduce using rule 407 (select_stmt -> async_select .)
    NULL            reduce using rule 407 (select_stmt -> async_select .)
    EXIT            reduce using rule 407 (select_stmt -> async_select .)
    RETURN          reduce using rule 407 (select_stmt -> async_select .)
    GOTO            reduce using rule 407 (select_stmt -> async_select .)
    DELAY           reduce using rule 407 (select_stmt -> async_select .)
    ABORT           reduce using rule 407 (select_stmt -> async_select .)
    RAISE           reduce using rule 407 (select_stmt -> async_select .)
    REQUEUE         reduce using rule 407 (select_stmt -> async_select .)
    IF              reduce using rule 407 (select_stmt -> async_select .)
    CASE            reduce using rule 407 (select_stmt -> async_select .)
    IDENTIFIER      reduce using rule 407 (select_stmt -> async_select .)
    ACCEPT          reduce using rule 407 (select_stmt -> async_select .)
    SELECT          reduce using rule 407 (select_stmt -> async_select .)
    STRING          reduce using rule 407 (select_stmt -> async_select .)
    WHILE           reduce using rule 407 (select_stmt -> async_select .)
    DECLARE         reduce using rule 407 (select_stmt -> async_select .)
    FOR             reduce using rule 407 (select_stmt -> async_select .)
    LOOP            reduce using rule 407 (select_stmt -> async_select .)
    BEGIN           reduce using rule 407 (select_stmt -> async_select .)
    ELSE            reduce using rule 407 (select_stmt -> async_select .)
    ELSIF           reduce using rule 407 (select_stmt -> async_select .)
    WHEN            reduce using rule 407 (select_stmt -> async_select .)
    EXCEPTION       reduce using rule 407 (select_stmt -> async_select .)
    OR              reduce using rule 407 (select_stmt -> async_select .)
    THEN            reduce using rule 407 (select_stmt -> async_select .)


state 274

    (267) compound_stmt -> select_stmt .

    LLB             reduce using rule 267 (compound_stmt -> select_stmt .)
    error           reduce using rule 267 (compound_stmt -> select_stmt .)
    PRAGMA          reduce using rule 267 (compound_stmt -> select_stmt .)
    NULL            reduce using rule 267 (compound_stmt -> select_stmt .)
    EXIT            reduce using rule 267 (compound_stmt -> select_stmt .)
    RETURN          reduce using rule 267 (compound_stmt -> select_stmt .)
    GOTO            reduce using rule 267 (compound_stmt -> select_stmt .)
    DELAY           reduce using rule 267 (compound_stmt -> select_stmt .)
    ABORT           reduce using rule 267 (compound_stmt -> select_stmt .)
    RAISE           reduce using rule 267 (compound_stmt -> select_stmt .)
    REQUEUE         reduce using rule 267 (compound_stmt -> select_stmt .)
    IF              reduce using rule 267 (compound_stmt -> select_stmt .)
    CASE            reduce using rule 267 (compound_stmt -> select_stmt .)
    IDENTIFIER      reduce using rule 267 (compound_stmt -> select_stmt .)
    ACCEPT          reduce using rule 267 (compound_stmt -> select_stmt .)
    SELECT          reduce using rule 267 (compound_stmt -> select_stmt .)
    STRING          reduce using rule 267 (compound_stmt -> select_stmt .)
    WHILE           reduce using rule 267 (compound_stmt -> select_stmt .)
    DECLARE         reduce using rule 267 (compound_stmt -> select_stmt .)
    FOR             reduce using rule 267 (compound_stmt -> select_stmt .)
    LOOP            reduce using rule 267 (compound_stmt -> select_stmt .)
    BEGIN           reduce using rule 267 (compound_stmt -> select_stmt .)
    WHEN            reduce using rule 267 (compound_stmt -> select_stmt .)
    END             reduce using rule 267 (compound_stmt -> select_stmt .)
    OR              reduce using rule 267 (compound_stmt -> select_stmt .)
    ELSE            reduce using rule 267 (compound_stmt -> select_stmt .)
    ELSIF           reduce using rule 267 (compound_stmt -> select_stmt .)
    THEN            reduce using rule 267 (compound_stmt -> select_stmt .)
    EXCEPTION       reduce using rule 267 (compound_stmt -> select_stmt .)


state 275

    (283) loop_stmt -> label_opt . iteration basic_loop id_opt SEMICOLON
    (295) block -> label_opt . block_decl block_body END id_opt SEMICOLON
    (287) iteration -> .
    (288) iteration -> . WHILE condition
    (289) iteration -> . iter_part reverse_opt discrete_range
    (296) block_decl -> .
    (297) block_decl -> . DECLARE decl_part
    (286) iter_part -> . FOR IDENTIFIER IN

    LOOP            reduce using rule 287 (iteration -> .)
    WHILE           shift and go to state 428
    BEGIN           reduce using rule 296 (block_decl -> .)
    DECLARE         shift and go to state 429
    FOR             shift and go to state 425

    iter_part                      shift and go to state 424
    block_decl                     shift and go to state 427
    iteration                      shift and go to state 426

state 276

    (309) goto_stmt -> GOTO . name SEMICOLON
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    name                           shift and go to state 430
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 146
    indexed_comp                   shift and go to state 119
    simple_name                    shift and go to state 153

state 277

    (247) unlabeled -> simple_stmt .

    LLB             reduce using rule 247 (unlabeled -> simple_stmt .)
    error           reduce using rule 247 (unlabeled -> simple_stmt .)
    PRAGMA          reduce using rule 247 (unlabeled -> simple_stmt .)
    NULL            reduce using rule 247 (unlabeled -> simple_stmt .)
    EXIT            reduce using rule 247 (unlabeled -> simple_stmt .)
    RETURN          reduce using rule 247 (unlabeled -> simple_stmt .)
    GOTO            reduce using rule 247 (unlabeled -> simple_stmt .)
    DELAY           reduce using rule 247 (unlabeled -> simple_stmt .)
    ABORT           reduce using rule 247 (unlabeled -> simple_stmt .)
    RAISE           reduce using rule 247 (unlabeled -> simple_stmt .)
    REQUEUE         reduce using rule 247 (unlabeled -> simple_stmt .)
    IF              reduce using rule 247 (unlabeled -> simple_stmt .)
    CASE            reduce using rule 247 (unlabeled -> simple_stmt .)
    IDENTIFIER      reduce using rule 247 (unlabeled -> simple_stmt .)
    ACCEPT          reduce using rule 247 (unlabeled -> simple_stmt .)
    SELECT          reduce using rule 247 (unlabeled -> simple_stmt .)
    STRING          reduce using rule 247 (unlabeled -> simple_stmt .)
    WHILE           reduce using rule 247 (unlabeled -> simple_stmt .)
    DECLARE         reduce using rule 247 (unlabeled -> simple_stmt .)
    FOR             reduce using rule 247 (unlabeled -> simple_stmt .)
    LOOP            reduce using rule 247 (unlabeled -> simple_stmt .)
    BEGIN           reduce using rule 247 (unlabeled -> simple_stmt .)
    ELSE            reduce using rule 247 (unlabeled -> simple_stmt .)
    ELSIF           reduce using rule 247 (unlabeled -> simple_stmt .)
    END             reduce using rule 247 (unlabeled -> simple_stmt .)
    WHEN            reduce using rule 247 (unlabeled -> simple_stmt .)
    EXCEPTION       reduce using rule 247 (unlabeled -> simple_stmt .)
    OR              reduce using rule 247 (unlabeled -> simple_stmt .)
    THEN            reduce using rule 247 (unlabeled -> simple_stmt .)


state 278

    (264) compound_stmt -> loop_stmt .

    LLB             reduce using rule 264 (compound_stmt -> loop_stmt .)
    error           reduce using rule 264 (compound_stmt -> loop_stmt .)
    PRAGMA          reduce using rule 264 (compound_stmt -> loop_stmt .)
    NULL            reduce using rule 264 (compound_stmt -> loop_stmt .)
    EXIT            reduce using rule 264 (compound_stmt -> loop_stmt .)
    RETURN          reduce using rule 264 (compound_stmt -> loop_stmt .)
    GOTO            reduce using rule 264 (compound_stmt -> loop_stmt .)
    DELAY           reduce using rule 264 (compound_stmt -> loop_stmt .)
    ABORT           reduce using rule 264 (compound_stmt -> loop_stmt .)
    RAISE           reduce using rule 264 (compound_stmt -> loop_stmt .)
    REQUEUE         reduce using rule 264 (compound_stmt -> loop_stmt .)
    IF              reduce using rule 264 (compound_stmt -> loop_stmt .)
    CASE            reduce using rule 264 (compound_stmt -> loop_stmt .)
    IDENTIFIER      reduce using rule 264 (compound_stmt -> loop_stmt .)
    ACCEPT          reduce using rule 264 (compound_stmt -> loop_stmt .)
    SELECT          reduce using rule 264 (compound_stmt -> loop_stmt .)
    STRING          reduce using rule 264 (compound_stmt -> loop_stmt .)
    WHILE           reduce using rule 264 (compound_stmt -> loop_stmt .)
    DECLARE         reduce using rule 264 (compound_stmt -> loop_stmt .)
    FOR             reduce using rule 264 (compound_stmt -> loop_stmt .)
    LOOP            reduce using rule 264 (compound_stmt -> loop_stmt .)
    BEGIN           reduce using rule 264 (compound_stmt -> loop_stmt .)
    WHEN            reduce using rule 264 (compound_stmt -> loop_stmt .)
    END             reduce using rule 264 (compound_stmt -> loop_stmt .)
    OR              reduce using rule 264 (compound_stmt -> loop_stmt .)
    ELSE            reduce using rule 264 (compound_stmt -> loop_stmt .)
    ELSIF           reduce using rule 264 (compound_stmt -> loop_stmt .)
    THEN            reduce using rule 264 (compound_stmt -> loop_stmt .)
    EXCEPTION       reduce using rule 264 (compound_stmt -> loop_stmt .)


state 279

    (510) code_stmt -> qualified . SEMICOLON

    SEMICOLON       shift and go to state 431


state 280

    (262) compound_stmt -> if_stmt .

    LLB             reduce using rule 262 (compound_stmt -> if_stmt .)
    error           reduce using rule 262 (compound_stmt -> if_stmt .)
    PRAGMA          reduce using rule 262 (compound_stmt -> if_stmt .)
    NULL            reduce using rule 262 (compound_stmt -> if_stmt .)
    EXIT            reduce using rule 262 (compound_stmt -> if_stmt .)
    RETURN          reduce using rule 262 (compound_stmt -> if_stmt .)
    GOTO            reduce using rule 262 (compound_stmt -> if_stmt .)
    DELAY           reduce using rule 262 (compound_stmt -> if_stmt .)
    ABORT           reduce using rule 262 (compound_stmt -> if_stmt .)
    RAISE           reduce using rule 262 (compound_stmt -> if_stmt .)
    REQUEUE         reduce using rule 262 (compound_stmt -> if_stmt .)
    IF              reduce using rule 262 (compound_stmt -> if_stmt .)
    CASE            reduce using rule 262 (compound_stmt -> if_stmt .)
    IDENTIFIER      reduce using rule 262 (compound_stmt -> if_stmt .)
    ACCEPT          reduce using rule 262 (compound_stmt -> if_stmt .)
    SELECT          reduce using rule 262 (compound_stmt -> if_stmt .)
    STRING          reduce using rule 262 (compound_stmt -> if_stmt .)
    WHILE           reduce using rule 262 (compound_stmt -> if_stmt .)
    DECLARE         reduce using rule 262 (compound_stmt -> if_stmt .)
    FOR             reduce using rule 262 (compound_stmt -> if_stmt .)
    LOOP            reduce using rule 262 (compound_stmt -> if_stmt .)
    BEGIN           reduce using rule 262 (compound_stmt -> if_stmt .)
    WHEN            reduce using rule 262 (compound_stmt -> if_stmt .)
    END             reduce using rule 262 (compound_stmt -> if_stmt .)
    OR              reduce using rule 262 (compound_stmt -> if_stmt .)
    ELSE            reduce using rule 262 (compound_stmt -> if_stmt .)
    ELSIF           reduce using rule 262 (compound_stmt -> if_stmt .)
    THEN            reduce using rule 262 (compound_stmt -> if_stmt .)
    EXCEPTION       reduce using rule 262 (compound_stmt -> if_stmt .)


state 281

    (270) assign_stmt -> name . IS_ASSIGNED expression SEMICOLON
    (332) procedure_call -> name . SEMICOLON
    (240) qualified -> name . TICK parenthesized_primary
    (168) indexed_comp -> name . LPAREN value_s RPAREN
    (175) selected_comp -> name . DOT simple_name
    (176) selected_comp -> name . DOT used_char
    (177) selected_comp -> name . DOT operator_symbol
    (178) selected_comp -> name . DOT ALL
    (179) attribute -> name . TICK attribute_id

    IS_ASSIGNED     shift and go to state 432
    SEMICOLON       shift and go to state 433
    TICK            shift and go to state 241
    LPAREN          shift and go to state 240
    DOT             shift and go to state 242


state 282

    (425) abort_stmt -> ABORT . name_s SEMICOLON
    (348) name_s -> . name
    (349) name_s -> . name_s COMMA name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    name_s                         shift and go to state 434
    name                           shift and go to state 151
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 146
    indexed_comp                   shift and go to state 119
    simple_name                    shift and go to state 153

state 283

    (266) compound_stmt -> accept_stmt .

    LLB             reduce using rule 266 (compound_stmt -> accept_stmt .)
    error           reduce using rule 266 (compound_stmt -> accept_stmt .)
    PRAGMA          reduce using rule 266 (compound_stmt -> accept_stmt .)
    NULL            reduce using rule 266 (compound_stmt -> accept_stmt .)
    EXIT            reduce using rule 266 (compound_stmt -> accept_stmt .)
    RETURN          reduce using rule 266 (compound_stmt -> accept_stmt .)
    GOTO            reduce using rule 266 (compound_stmt -> accept_stmt .)
    DELAY           reduce using rule 266 (compound_stmt -> accept_stmt .)
    ABORT           reduce using rule 266 (compound_stmt -> accept_stmt .)
    RAISE           reduce using rule 266 (compound_stmt -> accept_stmt .)
    REQUEUE         reduce using rule 266 (compound_stmt -> accept_stmt .)
    IF              reduce using rule 266 (compound_stmt -> accept_stmt .)
    CASE            reduce using rule 266 (compound_stmt -> accept_stmt .)
    IDENTIFIER      reduce using rule 266 (compound_stmt -> accept_stmt .)
    ACCEPT          reduce using rule 266 (compound_stmt -> accept_stmt .)
    SELECT          reduce using rule 266 (compound_stmt -> accept_stmt .)
    STRING          reduce using rule 266 (compound_stmt -> accept_stmt .)
    WHILE           reduce using rule 266 (compound_stmt -> accept_stmt .)
    DECLARE         reduce using rule 266 (compound_stmt -> accept_stmt .)
    FOR             reduce using rule 266 (compound_stmt -> accept_stmt .)
    LOOP            reduce using rule 266 (compound_stmt -> accept_stmt .)
    BEGIN           reduce using rule 266 (compound_stmt -> accept_stmt .)
    WHEN            reduce using rule 266 (compound_stmt -> accept_stmt .)
    END             reduce using rule 266 (compound_stmt -> accept_stmt .)
    OR              reduce using rule 266 (compound_stmt -> accept_stmt .)
    ELSE            reduce using rule 266 (compound_stmt -> accept_stmt .)
    ELSIF           reduce using rule 266 (compound_stmt -> accept_stmt .)
    THEN            reduce using rule 266 (compound_stmt -> accept_stmt .)
    EXCEPTION       reduce using rule 266 (compound_stmt -> accept_stmt .)


state 284

    (401) accept_hdr -> ACCEPT . entry_name formal_part_opt
    (402) entry_name -> . simple_name
    (403) entry_name -> . entry_name LPAREN expression RPAREN
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 40

    entry_name                     shift and go to state 435
    simple_name                    shift and go to state 436

state 285

    (255) simple_stmt -> procedure_call .

    EXCEPTION       reduce using rule 255 (simple_stmt -> procedure_call .)
    LLB             reduce using rule 255 (simple_stmt -> procedure_call .)
    error           reduce using rule 255 (simple_stmt -> procedure_call .)
    PRAGMA          reduce using rule 255 (simple_stmt -> procedure_call .)
    NULL            reduce using rule 255 (simple_stmt -> procedure_call .)
    EXIT            reduce using rule 255 (simple_stmt -> procedure_call .)
    RETURN          reduce using rule 255 (simple_stmt -> procedure_call .)
    GOTO            reduce using rule 255 (simple_stmt -> procedure_call .)
    DELAY           reduce using rule 255 (simple_stmt -> procedure_call .)
    ABORT           reduce using rule 255 (simple_stmt -> procedure_call .)
    RAISE           reduce using rule 255 (simple_stmt -> procedure_call .)
    REQUEUE         reduce using rule 255 (simple_stmt -> procedure_call .)
    IF              reduce using rule 255 (simple_stmt -> procedure_call .)
    CASE            reduce using rule 255 (simple_stmt -> procedure_call .)
    IDENTIFIER      reduce using rule 255 (simple_stmt -> procedure_call .)
    ACCEPT          reduce using rule 255 (simple_stmt -> procedure_call .)
    SELECT          reduce using rule 255 (simple_stmt -> procedure_call .)
    STRING          reduce using rule 255 (simple_stmt -> procedure_call .)
    WHILE           reduce using rule 255 (simple_stmt -> procedure_call .)
    DECLARE         reduce using rule 255 (simple_stmt -> procedure_call .)
    FOR             reduce using rule 255 (simple_stmt -> procedure_call .)
    LOOP            reduce using rule 255 (simple_stmt -> procedure_call .)
    BEGIN           reduce using rule 255 (simple_stmt -> procedure_call .)
    END             reduce using rule 255 (simple_stmt -> procedure_call .)
    OR              reduce using rule 255 (simple_stmt -> procedure_call .)
    ELSE            reduce using rule 255 (simple_stmt -> procedure_call .)
    ELSIF           reduce using rule 255 (simple_stmt -> procedure_call .)
    THEN            reduce using rule 255 (simple_stmt -> procedure_call .)
    WHEN            reduce using rule 255 (simple_stmt -> procedure_call .)


state 286

    (410) select_wait -> SELECT . guarded_select_alt or_select else_opt END SELECT SEMICOLON
    (420) async_select -> SELECT . delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON
    (421) timed_entry_call -> SELECT . entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON
    (422) cond_entry_call -> SELECT . entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON
    (411) guarded_select_alt -> . select_alt
    (412) guarded_select_alt -> . WHEN condition ARROW select_alt
    (418) delay_or_entry_alt -> . delay_stmt stmts_opt
    (419) delay_or_entry_alt -> . entry_call stmts_opt
    (398) entry_call -> . procedure_call
    (415) select_alt -> . accept_stmt stmts_opt
    (416) select_alt -> . delay_stmt stmts_opt
    (417) select_alt -> . TERMINATE SEMICOLON
    (404) delay_stmt -> . DELAY expression SEMICOLON
    (405) delay_stmt -> . DELAY UNTIL expression SEMICOLON
    (332) procedure_call -> . name SEMICOLON
    (399) accept_stmt -> . accept_hdr SEMICOLON
    (400) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt SEMICOLON
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (401) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    WHEN            shift and go to state 440
    TERMINATE       shift and go to state 445
    DELAY           shift and go to state 272
    ACCEPT          shift and go to state 284
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    accept_stmt                    shift and go to state 437
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    entry_call                     shift and go to state 438
    delay_or_entry_alt             shift and go to state 439
    indexed_comp                   shift and go to state 119
    simple_name                    shift and go to state 153
    guarded_select_alt             shift and go to state 441
    select_alt                     shift and go to state 442
    delay_stmt                     shift and go to state 443
    accept_hdr                     shift and go to state 302
    name                           shift and go to state 444
    operator_symbol                shift and go to state 146
    procedure_call                 shift and go to state 446

state 287

    (263) compound_stmt -> case_stmt .

    LLB             reduce using rule 263 (compound_stmt -> case_stmt .)
    error           reduce using rule 263 (compound_stmt -> case_stmt .)
    PRAGMA          reduce using rule 263 (compound_stmt -> case_stmt .)
    NULL            reduce using rule 263 (compound_stmt -> case_stmt .)
    EXIT            reduce using rule 263 (compound_stmt -> case_stmt .)
    RETURN          reduce using rule 263 (compound_stmt -> case_stmt .)
    GOTO            reduce using rule 263 (compound_stmt -> case_stmt .)
    DELAY           reduce using rule 263 (compound_stmt -> case_stmt .)
    ABORT           reduce using rule 263 (compound_stmt -> case_stmt .)
    RAISE           reduce using rule 263 (compound_stmt -> case_stmt .)
    REQUEUE         reduce using rule 263 (compound_stmt -> case_stmt .)
    IF              reduce using rule 263 (compound_stmt -> case_stmt .)
    CASE            reduce using rule 263 (compound_stmt -> case_stmt .)
    IDENTIFIER      reduce using rule 263 (compound_stmt -> case_stmt .)
    ACCEPT          reduce using rule 263 (compound_stmt -> case_stmt .)
    SELECT          reduce using rule 263 (compound_stmt -> case_stmt .)
    STRING          reduce using rule 263 (compound_stmt -> case_stmt .)
    WHILE           reduce using rule 263 (compound_stmt -> case_stmt .)
    DECLARE         reduce using rule 263 (compound_stmt -> case_stmt .)
    FOR             reduce using rule 263 (compound_stmt -> case_stmt .)
    LOOP            reduce using rule 263 (compound_stmt -> case_stmt .)
    BEGIN           reduce using rule 263 (compound_stmt -> case_stmt .)
    WHEN            reduce using rule 263 (compound_stmt -> case_stmt .)
    END             reduce using rule 263 (compound_stmt -> case_stmt .)
    OR              reduce using rule 263 (compound_stmt -> case_stmt .)
    ELSE            reduce using rule 263 (compound_stmt -> case_stmt .)
    ELSIF           reduce using rule 263 (compound_stmt -> case_stmt .)
    THEN            reduce using rule 263 (compound_stmt -> case_stmt .)
    EXCEPTION       reduce using rule 263 (compound_stmt -> case_stmt .)


state 288

    (246) statement -> label . statement
    (245) statement -> . unlabeled
    (246) statement -> . label statement
    (247) unlabeled -> . simple_stmt
    (248) unlabeled -> . compound_stmt
    (249) unlabeled -> . pragma
    (268) label -> . LLB IDENTIFIER RLB
    (250) simple_stmt -> . NULL_stmt
    (251) simple_stmt -> . assign_stmt
    (252) simple_stmt -> . exit_stmt
    (253) simple_stmt -> . return_stmt
    (254) simple_stmt -> . goto_stmt
    (255) simple_stmt -> . procedure_call
    (256) simple_stmt -> . delay_stmt
    (257) simple_stmt -> . abort_stmt
    (258) simple_stmt -> . raise_stmt
    (259) simple_stmt -> . code_stmt
    (260) simple_stmt -> . requeue_stmt
    (261) simple_stmt -> . error SEMICOLON
    (262) compound_stmt -> . if_stmt
    (263) compound_stmt -> . case_stmt
    (264) compound_stmt -> . loop_stmt
    (265) compound_stmt -> . block
    (266) compound_stmt -> . accept_stmt
    (267) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (269) NULL_stmt -> . NULL SEMICOLON
    (270) assign_stmt -> . name IS_ASSIGNED expression SEMICOLON
    (302) exit_stmt -> . EXIT name_opt when_opt SEMICOLON
    (307) return_stmt -> . RETURN SEMICOLON
    (308) return_stmt -> . RETURN expression SEMICOLON
    (309) goto_stmt -> . GOTO name SEMICOLON
    (332) procedure_call -> . name SEMICOLON
    (404) delay_stmt -> . DELAY expression SEMICOLON
    (405) delay_stmt -> . DELAY UNTIL expression SEMICOLON
    (425) abort_stmt -> . ABORT name_s SEMICOLON
    (464) raise_stmt -> . RAISE name_opt SEMICOLON
    (510) code_stmt -> . qualified SEMICOLON
    (465) requeue_stmt -> . REQUEUE name SEMICOLON
    (466) requeue_stmt -> . REQUEUE name WITH ABORT SEMICOLON
    (271) if_stmt -> . IF cond_clause else_opt END IF SEMICOLON
    (278) case_stmt -> . case_hdr alternative_s END CASE SEMICOLON
    (283) loop_stmt -> . label_opt iteration basic_loop id_opt SEMICOLON
    (295) block -> . label_opt block_decl block_body END id_opt SEMICOLON
    (399) accept_stmt -> . accept_hdr SEMICOLON
    (400) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt SEMICOLON
    (406) select_stmt -> . select_wait
    (407) select_stmt -> . async_select
    (408) select_stmt -> . timed_entry_call
    (409) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (240) qualified -> . name TICK parenthesized_primary
    (279) case_hdr -> . CASE expression IS
    (284) label_opt -> .
    (285) label_opt -> . IDENTIFIER COLON
    (401) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (410) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON
    (420) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON
    (421) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON
    (422) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    LLB             shift and go to state 289
    error           shift and go to state 309
    PRAGMA          shift and go to state 4
    NULL            shift and go to state 311
    EXIT            shift and go to state 308
    RETURN          shift and go to state 295
    GOTO            shift and go to state 276
    DELAY           shift and go to state 272
    ABORT           shift and go to state 282
    RAISE           shift and go to state 306
    REQUEUE         shift and go to state 298
    IF              shift and go to state 317
    CASE            shift and go to state 297
    WHILE           reduce using rule 284 (label_opt -> .)
    DECLARE         reduce using rule 284 (label_opt -> .)
    FOR             reduce using rule 284 (label_opt -> .)
    LOOP            reduce using rule 284 (label_opt -> .)
    BEGIN           reduce using rule 284 (label_opt -> .)
    IDENTIFIER      shift and go to state 300
    ACCEPT          shift and go to state 284
    SELECT          shift and go to state 286
    STRING          shift and go to state 137

    indexed_comp                   shift and go to state 119
    accept_stmt                    shift and go to state 283
    label_opt                      shift and go to state 275
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 316
    abort_stmt                     shift and go to state 310
    return_stmt                    shift and go to state 294
    procedure_call                 shift and go to state 285
    assign_stmt                    shift and go to state 320
    accept_hdr                     shift and go to state 302
    simple_name                    shift and go to state 153
    code_stmt                      shift and go to state 313
    case_stmt                      shift and go to state 287
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 146
    label                          shift and go to state 288
    exit_stmt                      shift and go to state 315
    select_stmt                    shift and go to state 274
    statement                      shift and go to state 447
    compound_stmt                  shift and go to state 290
    case_hdr                       shift and go to state 292
    delay_stmt                     shift and go to state 301
    unlabeled                      shift and go to state 314
    simple_stmt                    shift and go to state 277
    loop_stmt                      shift and go to state 278
    qualified                      shift and go to state 279
    pragma                         shift and go to state 303
    async_select                   shift and go to state 273
    requeue_stmt                   shift and go to state 304
    raise_stmt                     shift and go to state 305
    name                           shift and go to state 281
    if_stmt                        shift and go to state 280
    cond_entry_call                shift and go to state 318
    timed_entry_call               shift and go to state 307
    goto_stmt                      shift and go to state 291
    NULL_stmt                      shift and go to state 319
    block                          shift and go to state 293

state 289

    (268) label -> LLB . IDENTIFIER RLB

    IDENTIFIER      shift and go to state 448


state 290

    (248) unlabeled -> compound_stmt .

    LLB             reduce using rule 248 (unlabeled -> compound_stmt .)
    error           reduce using rule 248 (unlabeled -> compound_stmt .)
    PRAGMA          reduce using rule 248 (unlabeled -> compound_stmt .)
    NULL            reduce using rule 248 (unlabeled -> compound_stmt .)
    EXIT            reduce using rule 248 (unlabeled -> compound_stmt .)
    RETURN          reduce using rule 248 (unlabeled -> compound_stmt .)
    GOTO            reduce using rule 248 (unlabeled -> compound_stmt .)
    DELAY           reduce using rule 248 (unlabeled -> compound_stmt .)
    ABORT           reduce using rule 248 (unlabeled -> compound_stmt .)
    RAISE           reduce using rule 248 (unlabeled -> compound_stmt .)
    REQUEUE         reduce using rule 248 (unlabeled -> compound_stmt .)
    IF              reduce using rule 248 (unlabeled -> compound_stmt .)
    CASE            reduce using rule 248 (unlabeled -> compound_stmt .)
    IDENTIFIER      reduce using rule 248 (unlabeled -> compound_stmt .)
    ACCEPT          reduce using rule 248 (unlabeled -> compound_stmt .)
    SELECT          reduce using rule 248 (unlabeled -> compound_stmt .)
    STRING          reduce using rule 248 (unlabeled -> compound_stmt .)
    WHILE           reduce using rule 248 (unlabeled -> compound_stmt .)
    DECLARE         reduce using rule 248 (unlabeled -> compound_stmt .)
    FOR             reduce using rule 248 (unlabeled -> compound_stmt .)
    LOOP            reduce using rule 248 (unlabeled -> compound_stmt .)
    BEGIN           reduce using rule 248 (unlabeled -> compound_stmt .)
    ELSE            reduce using rule 248 (unlabeled -> compound_stmt .)
    ELSIF           reduce using rule 248 (unlabeled -> compound_stmt .)
    END             reduce using rule 248 (unlabeled -> compound_stmt .)
    WHEN            reduce using rule 248 (unlabeled -> compound_stmt .)
    EXCEPTION       reduce using rule 248 (unlabeled -> compound_stmt .)
    OR              reduce using rule 248 (unlabeled -> compound_stmt .)
    THEN            reduce using rule 248 (unlabeled -> compound_stmt .)


state 291

    (254) simple_stmt -> goto_stmt .

    EXCEPTION       reduce using rule 254 (simple_stmt -> goto_stmt .)
    LLB             reduce using rule 254 (simple_stmt -> goto_stmt .)
    error           reduce using rule 254 (simple_stmt -> goto_stmt .)
    PRAGMA          reduce using rule 254 (simple_stmt -> goto_stmt .)
    NULL            reduce using rule 254 (simple_stmt -> goto_stmt .)
    EXIT            reduce using rule 254 (simple_stmt -> goto_stmt .)
    RETURN          reduce using rule 254 (simple_stmt -> goto_stmt .)
    GOTO            reduce using rule 254 (simple_stmt -> goto_stmt .)
    DELAY           reduce using rule 254 (simple_stmt -> goto_stmt .)
    ABORT           reduce using rule 254 (simple_stmt -> goto_stmt .)
    RAISE           reduce using rule 254 (simple_stmt -> goto_stmt .)
    REQUEUE         reduce using rule 254 (simple_stmt -> goto_stmt .)
    IF              reduce using rule 254 (simple_stmt -> goto_stmt .)
    CASE            reduce using rule 254 (simple_stmt -> goto_stmt .)
    IDENTIFIER      reduce using rule 254 (simple_stmt -> goto_stmt .)
    ACCEPT          reduce using rule 254 (simple_stmt -> goto_stmt .)
    SELECT          reduce using rule 254 (simple_stmt -> goto_stmt .)
    STRING          reduce using rule 254 (simple_stmt -> goto_stmt .)
    WHILE           reduce using rule 254 (simple_stmt -> goto_stmt .)
    DECLARE         reduce using rule 254 (simple_stmt -> goto_stmt .)
    FOR             reduce using rule 254 (simple_stmt -> goto_stmt .)
    LOOP            reduce using rule 254 (simple_stmt -> goto_stmt .)
    BEGIN           reduce using rule 254 (simple_stmt -> goto_stmt .)
    END             reduce using rule 254 (simple_stmt -> goto_stmt .)
    OR              reduce using rule 254 (simple_stmt -> goto_stmt .)
    ELSE            reduce using rule 254 (simple_stmt -> goto_stmt .)
    ELSIF           reduce using rule 254 (simple_stmt -> goto_stmt .)
    THEN            reduce using rule 254 (simple_stmt -> goto_stmt .)
    WHEN            reduce using rule 254 (simple_stmt -> goto_stmt .)


state 292

    (278) case_stmt -> case_hdr . alternative_s END CASE SEMICOLON
    (280) alternative_s -> .
    (281) alternative_s -> . alternative_s alternative

    END             reduce using rule 280 (alternative_s -> .)
    WHEN            reduce using rule 280 (alternative_s -> .)

    alternative_s                  shift and go to state 449

state 293

    (265) compound_stmt -> block .

    LLB             reduce using rule 265 (compound_stmt -> block .)
    error           reduce using rule 265 (compound_stmt -> block .)
    PRAGMA          reduce using rule 265 (compound_stmt -> block .)
    NULL            reduce using rule 265 (compound_stmt -> block .)
    EXIT            reduce using rule 265 (compound_stmt -> block .)
    RETURN          reduce using rule 265 (compound_stmt -> block .)
    GOTO            reduce using rule 265 (compound_stmt -> block .)
    DELAY           reduce using rule 265 (compound_stmt -> block .)
    ABORT           reduce using rule 265 (compound_stmt -> block .)
    RAISE           reduce using rule 265 (compound_stmt -> block .)
    REQUEUE         reduce using rule 265 (compound_stmt -> block .)
    IF              reduce using rule 265 (compound_stmt -> block .)
    CASE            reduce using rule 265 (compound_stmt -> block .)
    IDENTIFIER      reduce using rule 265 (compound_stmt -> block .)
    ACCEPT          reduce using rule 265 (compound_stmt -> block .)
    SELECT          reduce using rule 265 (compound_stmt -> block .)
    STRING          reduce using rule 265 (compound_stmt -> block .)
    WHILE           reduce using rule 265 (compound_stmt -> block .)
    DECLARE         reduce using rule 265 (compound_stmt -> block .)
    FOR             reduce using rule 265 (compound_stmt -> block .)
    LOOP            reduce using rule 265 (compound_stmt -> block .)
    BEGIN           reduce using rule 265 (compound_stmt -> block .)
    WHEN            reduce using rule 265 (compound_stmt -> block .)
    END             reduce using rule 265 (compound_stmt -> block .)
    OR              reduce using rule 265 (compound_stmt -> block .)
    ELSE            reduce using rule 265 (compound_stmt -> block .)
    ELSIF           reduce using rule 265 (compound_stmt -> block .)
    THEN            reduce using rule 265 (compound_stmt -> block .)
    EXCEPTION       reduce using rule 265 (compound_stmt -> block .)


state 294

    (253) simple_stmt -> return_stmt .

    EXCEPTION       reduce using rule 253 (simple_stmt -> return_stmt .)
    LLB             reduce using rule 253 (simple_stmt -> return_stmt .)
    error           reduce using rule 253 (simple_stmt -> return_stmt .)
    PRAGMA          reduce using rule 253 (simple_stmt -> return_stmt .)
    NULL            reduce using rule 253 (simple_stmt -> return_stmt .)
    EXIT            reduce using rule 253 (simple_stmt -> return_stmt .)
    RETURN          reduce using rule 253 (simple_stmt -> return_stmt .)
    GOTO            reduce using rule 253 (simple_stmt -> return_stmt .)
    DELAY           reduce using rule 253 (simple_stmt -> return_stmt .)
    ABORT           reduce using rule 253 (simple_stmt -> return_stmt .)
    RAISE           reduce using rule 253 (simple_stmt -> return_stmt .)
    REQUEUE         reduce using rule 253 (simple_stmt -> return_stmt .)
    IF              reduce using rule 253 (simple_stmt -> return_stmt .)
    CASE            reduce using rule 253 (simple_stmt -> return_stmt .)
    IDENTIFIER      reduce using rule 253 (simple_stmt -> return_stmt .)
    ACCEPT          reduce using rule 253 (simple_stmt -> return_stmt .)
    SELECT          reduce using rule 253 (simple_stmt -> return_stmt .)
    STRING          reduce using rule 253 (simple_stmt -> return_stmt .)
    WHILE           reduce using rule 253 (simple_stmt -> return_stmt .)
    DECLARE         reduce using rule 253 (simple_stmt -> return_stmt .)
    FOR             reduce using rule 253 (simple_stmt -> return_stmt .)
    LOOP            reduce using rule 253 (simple_stmt -> return_stmt .)
    BEGIN           reduce using rule 253 (simple_stmt -> return_stmt .)
    END             reduce using rule 253 (simple_stmt -> return_stmt .)
    OR              reduce using rule 253 (simple_stmt -> return_stmt .)
    ELSE            reduce using rule 253 (simple_stmt -> return_stmt .)
    ELSIF           reduce using rule 253 (simple_stmt -> return_stmt .)
    THEN            reduce using rule 253 (simple_stmt -> return_stmt .)
    WHEN            reduce using rule 253 (simple_stmt -> return_stmt .)


state 295

    (307) return_stmt -> RETURN . SEMICOLON
    (308) return_stmt -> RETURN . expression SEMICOLON
    (195) expression -> . relation
    (196) expression -> . expression logical relation
    (197) expression -> . expression short_circuit relation
    (203) relation -> . simple_expression
    (204) relation -> . simple_expression relational simple_expression
    (205) relation -> . simple_expression membership range
    (206) relation -> . simple_expression membership name
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    SEMICOLON       shift and go to state 450
    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    relation                       shift and go to state 127
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    factor                         shift and go to state 136
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    term                           shift and go to state 144
    name                           shift and go to state 145
    operator_symbol                shift and go to state 146
    expression                     shift and go to state 451

state 296

    (298) block_body -> BEGIN handled_stmt_s .

    END             reduce using rule 298 (block_body -> BEGIN handled_stmt_s .)


state 297

    (279) case_hdr -> CASE . expression IS
    (195) expression -> . relation
    (196) expression -> . expression logical relation
    (197) expression -> . expression short_circuit relation
    (203) relation -> . simple_expression
    (204) relation -> . simple_expression relational simple_expression
    (205) relation -> . simple_expression membership range
    (206) relation -> . simple_expression membership name
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    relation                       shift and go to state 127
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    factor                         shift and go to state 136
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    term                           shift and go to state 144
    name                           shift and go to state 145
    operator_symbol                shift and go to state 146
    expression                     shift and go to state 452

state 298

    (465) requeue_stmt -> REQUEUE . name SEMICOLON
    (466) requeue_stmt -> REQUEUE . name WITH ABORT SEMICOLON
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    name                           shift and go to state 453
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 146
    indexed_comp                   shift and go to state 119
    simple_name                    shift and go to state 153

state 299

    (243) statement_s -> statement .

    LLB             reduce using rule 243 (statement_s -> statement .)
    error           reduce using rule 243 (statement_s -> statement .)
    PRAGMA          reduce using rule 243 (statement_s -> statement .)
    NULL            reduce using rule 243 (statement_s -> statement .)
    EXIT            reduce using rule 243 (statement_s -> statement .)
    RETURN          reduce using rule 243 (statement_s -> statement .)
    GOTO            reduce using rule 243 (statement_s -> statement .)
    DELAY           reduce using rule 243 (statement_s -> statement .)
    ABORT           reduce using rule 243 (statement_s -> statement .)
    RAISE           reduce using rule 243 (statement_s -> statement .)
    REQUEUE         reduce using rule 243 (statement_s -> statement .)
    IF              reduce using rule 243 (statement_s -> statement .)
    CASE            reduce using rule 243 (statement_s -> statement .)
    IDENTIFIER      reduce using rule 243 (statement_s -> statement .)
    ACCEPT          reduce using rule 243 (statement_s -> statement .)
    SELECT          reduce using rule 243 (statement_s -> statement .)
    STRING          reduce using rule 243 (statement_s -> statement .)
    WHILE           reduce using rule 243 (statement_s -> statement .)
    DECLARE         reduce using rule 243 (statement_s -> statement .)
    FOR             reduce using rule 243 (statement_s -> statement .)
    LOOP            reduce using rule 243 (statement_s -> statement .)
    BEGIN           reduce using rule 243 (statement_s -> statement .)
    ELSE            reduce using rule 243 (statement_s -> statement .)
    ELSIF           reduce using rule 243 (statement_s -> statement .)
    END             reduce using rule 243 (statement_s -> statement .)
    WHEN            reduce using rule 243 (statement_s -> statement .)
    OR              reduce using rule 243 (statement_s -> statement .)
    EXCEPTION       reduce using rule 243 (statement_s -> statement .)
    THEN            reduce using rule 243 (statement_s -> statement .)


state 300

    (285) label_opt -> IDENTIFIER . COLON
    (161) simple_name -> IDENTIFIER .

    COLON           shift and go to state 454
    IS_ASSIGNED     reduce using rule 161 (simple_name -> IDENTIFIER .)
    SEMICOLON       reduce using rule 161 (simple_name -> IDENTIFIER .)
    TICK            reduce using rule 161 (simple_name -> IDENTIFIER .)
    LPAREN          reduce using rule 161 (simple_name -> IDENTIFIER .)
    DOT             reduce using rule 161 (simple_name -> IDENTIFIER .)


state 301

    (256) simple_stmt -> delay_stmt .

    EXCEPTION       reduce using rule 256 (simple_stmt -> delay_stmt .)
    LLB             reduce using rule 256 (simple_stmt -> delay_stmt .)
    error           reduce using rule 256 (simple_stmt -> delay_stmt .)
    PRAGMA          reduce using rule 256 (simple_stmt -> delay_stmt .)
    NULL            reduce using rule 256 (simple_stmt -> delay_stmt .)
    EXIT            reduce using rule 256 (simple_stmt -> delay_stmt .)
    RETURN          reduce using rule 256 (simple_stmt -> delay_stmt .)
    GOTO            reduce using rule 256 (simple_stmt -> delay_stmt .)
    DELAY           reduce using rule 256 (simple_stmt -> delay_stmt .)
    ABORT           reduce using rule 256 (simple_stmt -> delay_stmt .)
    RAISE           reduce using rule 256 (simple_stmt -> delay_stmt .)
    REQUEUE         reduce using rule 256 (simple_stmt -> delay_stmt .)
    IF              reduce using rule 256 (simple_stmt -> delay_stmt .)
    CASE            reduce using rule 256 (simple_stmt -> delay_stmt .)
    IDENTIFIER      reduce using rule 256 (simple_stmt -> delay_stmt .)
    ACCEPT          reduce using rule 256 (simple_stmt -> delay_stmt .)
    SELECT          reduce using rule 256 (simple_stmt -> delay_stmt .)
    STRING          reduce using rule 256 (simple_stmt -> delay_stmt .)
    WHILE           reduce using rule 256 (simple_stmt -> delay_stmt .)
    DECLARE         reduce using rule 256 (simple_stmt -> delay_stmt .)
    FOR             reduce using rule 256 (simple_stmt -> delay_stmt .)
    LOOP            reduce using rule 256 (simple_stmt -> delay_stmt .)
    BEGIN           reduce using rule 256 (simple_stmt -> delay_stmt .)
    END             reduce using rule 256 (simple_stmt -> delay_stmt .)
    OR              reduce using rule 256 (simple_stmt -> delay_stmt .)
    ELSE            reduce using rule 256 (simple_stmt -> delay_stmt .)
    ELSIF           reduce using rule 256 (simple_stmt -> delay_stmt .)
    THEN            reduce using rule 256 (simple_stmt -> delay_stmt .)
    WHEN            reduce using rule 256 (simple_stmt -> delay_stmt .)


state 302

    (399) accept_stmt -> accept_hdr . SEMICOLON
    (400) accept_stmt -> accept_hdr . DO handled_stmt_s END id_opt SEMICOLON

    SEMICOLON       shift and go to state 455
    DO              shift and go to state 456


state 303

    (249) unlabeled -> pragma .

    LLB             reduce using rule 249 (unlabeled -> pragma .)
    error           reduce using rule 249 (unlabeled -> pragma .)
    PRAGMA          reduce using rule 249 (unlabeled -> pragma .)
    NULL            reduce using rule 249 (unlabeled -> pragma .)
    EXIT            reduce using rule 249 (unlabeled -> pragma .)
    RETURN          reduce using rule 249 (unlabeled -> pragma .)
    GOTO            reduce using rule 249 (unlabeled -> pragma .)
    DELAY           reduce using rule 249 (unlabeled -> pragma .)
    ABORT           reduce using rule 249 (unlabeled -> pragma .)
    RAISE           reduce using rule 249 (unlabeled -> pragma .)
    REQUEUE         reduce using rule 249 (unlabeled -> pragma .)
    IF              reduce using rule 249 (unlabeled -> pragma .)
    CASE            reduce using rule 249 (unlabeled -> pragma .)
    IDENTIFIER      reduce using rule 249 (unlabeled -> pragma .)
    ACCEPT          reduce using rule 249 (unlabeled -> pragma .)
    SELECT          reduce using rule 249 (unlabeled -> pragma .)
    STRING          reduce using rule 249 (unlabeled -> pragma .)
    WHILE           reduce using rule 249 (unlabeled -> pragma .)
    DECLARE         reduce using rule 249 (unlabeled -> pragma .)
    FOR             reduce using rule 249 (unlabeled -> pragma .)
    LOOP            reduce using rule 249 (unlabeled -> pragma .)
    BEGIN           reduce using rule 249 (unlabeled -> pragma .)
    ELSE            reduce using rule 249 (unlabeled -> pragma .)
    ELSIF           reduce using rule 249 (unlabeled -> pragma .)
    END             reduce using rule 249 (unlabeled -> pragma .)
    WHEN            reduce using rule 249 (unlabeled -> pragma .)
    EXCEPTION       reduce using rule 249 (unlabeled -> pragma .)
    OR              reduce using rule 249 (unlabeled -> pragma .)
    THEN            reduce using rule 249 (unlabeled -> pragma .)


state 304

    (260) simple_stmt -> requeue_stmt .

    EXCEPTION       reduce using rule 260 (simple_stmt -> requeue_stmt .)
    LLB             reduce using rule 260 (simple_stmt -> requeue_stmt .)
    error           reduce using rule 260 (simple_stmt -> requeue_stmt .)
    PRAGMA          reduce using rule 260 (simple_stmt -> requeue_stmt .)
    NULL            reduce using rule 260 (simple_stmt -> requeue_stmt .)
    EXIT            reduce using rule 260 (simple_stmt -> requeue_stmt .)
    RETURN          reduce using rule 260 (simple_stmt -> requeue_stmt .)
    GOTO            reduce using rule 260 (simple_stmt -> requeue_stmt .)
    DELAY           reduce using rule 260 (simple_stmt -> requeue_stmt .)
    ABORT           reduce using rule 260 (simple_stmt -> requeue_stmt .)
    RAISE           reduce using rule 260 (simple_stmt -> requeue_stmt .)
    REQUEUE         reduce using rule 260 (simple_stmt -> requeue_stmt .)
    IF              reduce using rule 260 (simple_stmt -> requeue_stmt .)
    CASE            reduce using rule 260 (simple_stmt -> requeue_stmt .)
    IDENTIFIER      reduce using rule 260 (simple_stmt -> requeue_stmt .)
    ACCEPT          reduce using rule 260 (simple_stmt -> requeue_stmt .)
    SELECT          reduce using rule 260 (simple_stmt -> requeue_stmt .)
    STRING          reduce using rule 260 (simple_stmt -> requeue_stmt .)
    WHILE           reduce using rule 260 (simple_stmt -> requeue_stmt .)
    DECLARE         reduce using rule 260 (simple_stmt -> requeue_stmt .)
    FOR             reduce using rule 260 (simple_stmt -> requeue_stmt .)
    LOOP            reduce using rule 260 (simple_stmt -> requeue_stmt .)
    BEGIN           reduce using rule 260 (simple_stmt -> requeue_stmt .)
    END             reduce using rule 260 (simple_stmt -> requeue_stmt .)
    OR              reduce using rule 260 (simple_stmt -> requeue_stmt .)
    ELSE            reduce using rule 260 (simple_stmt -> requeue_stmt .)
    ELSIF           reduce using rule 260 (simple_stmt -> requeue_stmt .)
    THEN            reduce using rule 260 (simple_stmt -> requeue_stmt .)
    WHEN            reduce using rule 260 (simple_stmt -> requeue_stmt .)


state 305

    (258) simple_stmt -> raise_stmt .

    EXCEPTION       reduce using rule 258 (simple_stmt -> raise_stmt .)
    LLB             reduce using rule 258 (simple_stmt -> raise_stmt .)
    error           reduce using rule 258 (simple_stmt -> raise_stmt .)
    PRAGMA          reduce using rule 258 (simple_stmt -> raise_stmt .)
    NULL            reduce using rule 258 (simple_stmt -> raise_stmt .)
    EXIT            reduce using rule 258 (simple_stmt -> raise_stmt .)
    RETURN          reduce using rule 258 (simple_stmt -> raise_stmt .)
    GOTO            reduce using rule 258 (simple_stmt -> raise_stmt .)
    DELAY           reduce using rule 258 (simple_stmt -> raise_stmt .)
    ABORT           reduce using rule 258 (simple_stmt -> raise_stmt .)
    RAISE           reduce using rule 258 (simple_stmt -> raise_stmt .)
    REQUEUE         reduce using rule 258 (simple_stmt -> raise_stmt .)
    IF              reduce using rule 258 (simple_stmt -> raise_stmt .)
    CASE            reduce using rule 258 (simple_stmt -> raise_stmt .)
    IDENTIFIER      reduce using rule 258 (simple_stmt -> raise_stmt .)
    ACCEPT          reduce using rule 258 (simple_stmt -> raise_stmt .)
    SELECT          reduce using rule 258 (simple_stmt -> raise_stmt .)
    STRING          reduce using rule 258 (simple_stmt -> raise_stmt .)
    WHILE           reduce using rule 258 (simple_stmt -> raise_stmt .)
    DECLARE         reduce using rule 258 (simple_stmt -> raise_stmt .)
    FOR             reduce using rule 258 (simple_stmt -> raise_stmt .)
    LOOP            reduce using rule 258 (simple_stmt -> raise_stmt .)
    BEGIN           reduce using rule 258 (simple_stmt -> raise_stmt .)
    END             reduce using rule 258 (simple_stmt -> raise_stmt .)
    OR              reduce using rule 258 (simple_stmt -> raise_stmt .)
    ELSE            reduce using rule 258 (simple_stmt -> raise_stmt .)
    ELSIF           reduce using rule 258 (simple_stmt -> raise_stmt .)
    THEN            reduce using rule 258 (simple_stmt -> raise_stmt .)
    WHEN            reduce using rule 258 (simple_stmt -> raise_stmt .)


state 306

    (464) raise_stmt -> RAISE . name_opt SEMICOLON
    (303) name_opt -> . empty
    (304) name_opt -> . name
    (511) empty -> .
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    SEMICOLON       reduce using rule 511 (empty -> .)
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    name                           shift and go to state 457
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 146
    name_opt                       shift and go to state 458
    indexed_comp                   shift and go to state 119
    empty                          shift and go to state 459
    simple_name                    shift and go to state 153

state 307

    (408) select_stmt -> timed_entry_call .

    END             reduce using rule 408 (select_stmt -> timed_entry_call .)
    LLB             reduce using rule 408 (select_stmt -> timed_entry_call .)
    error           reduce using rule 408 (select_stmt -> timed_entry_call .)
    PRAGMA          reduce using rule 408 (select_stmt -> timed_entry_call .)
    NULL            reduce using rule 408 (select_stmt -> timed_entry_call .)
    EXIT            reduce using rule 408 (select_stmt -> timed_entry_call .)
    RETURN          reduce using rule 408 (select_stmt -> timed_entry_call .)
    GOTO            reduce using rule 408 (select_stmt -> timed_entry_call .)
    DELAY           reduce using rule 408 (select_stmt -> timed_entry_call .)
    ABORT           reduce using rule 408 (select_stmt -> timed_entry_call .)
    RAISE           reduce using rule 408 (select_stmt -> timed_entry_call .)
    REQUEUE         reduce using rule 408 (select_stmt -> timed_entry_call .)
    IF              reduce using rule 408 (select_stmt -> timed_entry_call .)
    CASE            reduce using rule 408 (select_stmt -> timed_entry_call .)
    IDENTIFIER      reduce using rule 408 (select_stmt -> timed_entry_call .)
    ACCEPT          reduce using rule 408 (select_stmt -> timed_entry_call .)
    SELECT          reduce using rule 408 (select_stmt -> timed_entry_call .)
    STRING          reduce using rule 408 (select_stmt -> timed_entry_call .)
    WHILE           reduce using rule 408 (select_stmt -> timed_entry_call .)
    DECLARE         reduce using rule 408 (select_stmt -> timed_entry_call .)
    FOR             reduce using rule 408 (select_stmt -> timed_entry_call .)
    LOOP            reduce using rule 408 (select_stmt -> timed_entry_call .)
    BEGIN           reduce using rule 408 (select_stmt -> timed_entry_call .)
    ELSE            reduce using rule 408 (select_stmt -> timed_entry_call .)
    ELSIF           reduce using rule 408 (select_stmt -> timed_entry_call .)
    WHEN            reduce using rule 408 (select_stmt -> timed_entry_call .)
    EXCEPTION       reduce using rule 408 (select_stmt -> timed_entry_call .)
    OR              reduce using rule 408 (select_stmt -> timed_entry_call .)
    THEN            reduce using rule 408 (select_stmt -> timed_entry_call .)


state 308

    (302) exit_stmt -> EXIT . name_opt when_opt SEMICOLON
    (303) name_opt -> . empty
    (304) name_opt -> . name
    (511) empty -> .
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    WHEN            reduce using rule 511 (empty -> .)
    SEMICOLON       reduce using rule 511 (empty -> .)
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    name                           shift and go to state 457
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 146
    selected_comp                  shift and go to state 120
    name_opt                       shift and go to state 460
    indexed_comp                   shift and go to state 119
    empty                          shift and go to state 459
    simple_name                    shift and go to state 153

state 309

    (261) simple_stmt -> error . SEMICOLON

    SEMICOLON       shift and go to state 461


state 310

    (257) simple_stmt -> abort_stmt .

    EXCEPTION       reduce using rule 257 (simple_stmt -> abort_stmt .)
    LLB             reduce using rule 257 (simple_stmt -> abort_stmt .)
    error           reduce using rule 257 (simple_stmt -> abort_stmt .)
    PRAGMA          reduce using rule 257 (simple_stmt -> abort_stmt .)
    NULL            reduce using rule 257 (simple_stmt -> abort_stmt .)
    EXIT            reduce using rule 257 (simple_stmt -> abort_stmt .)
    RETURN          reduce using rule 257 (simple_stmt -> abort_stmt .)
    GOTO            reduce using rule 257 (simple_stmt -> abort_stmt .)
    DELAY           reduce using rule 257 (simple_stmt -> abort_stmt .)
    ABORT           reduce using rule 257 (simple_stmt -> abort_stmt .)
    RAISE           reduce using rule 257 (simple_stmt -> abort_stmt .)
    REQUEUE         reduce using rule 257 (simple_stmt -> abort_stmt .)
    IF              reduce using rule 257 (simple_stmt -> abort_stmt .)
    CASE            reduce using rule 257 (simple_stmt -> abort_stmt .)
    IDENTIFIER      reduce using rule 257 (simple_stmt -> abort_stmt .)
    ACCEPT          reduce using rule 257 (simple_stmt -> abort_stmt .)
    SELECT          reduce using rule 257 (simple_stmt -> abort_stmt .)
    STRING          reduce using rule 257 (simple_stmt -> abort_stmt .)
    WHILE           reduce using rule 257 (simple_stmt -> abort_stmt .)
    DECLARE         reduce using rule 257 (simple_stmt -> abort_stmt .)
    FOR             reduce using rule 257 (simple_stmt -> abort_stmt .)
    LOOP            reduce using rule 257 (simple_stmt -> abort_stmt .)
    BEGIN           reduce using rule 257 (simple_stmt -> abort_stmt .)
    END             reduce using rule 257 (simple_stmt -> abort_stmt .)
    OR              reduce using rule 257 (simple_stmt -> abort_stmt .)
    ELSE            reduce using rule 257 (simple_stmt -> abort_stmt .)
    ELSIF           reduce using rule 257 (simple_stmt -> abort_stmt .)
    THEN            reduce using rule 257 (simple_stmt -> abort_stmt .)
    WHEN            reduce using rule 257 (simple_stmt -> abort_stmt .)


state 311

    (269) NULL_stmt -> NULL . SEMICOLON

    SEMICOLON       shift and go to state 462


state 312

    (299) handled_stmt_s -> statement_s . except_handler_part_opt
    (244) statement_s -> statement_s . statement
    (300) except_handler_part_opt -> .
    (301) except_handler_part_opt -> . except_handler_part
    (245) statement -> . unlabeled
    (246) statement -> . label statement
    (456) except_handler_part -> . EXCEPTION exception_handler
    (457) except_handler_part -> . except_handler_part exception_handler
    (247) unlabeled -> . simple_stmt
    (248) unlabeled -> . compound_stmt
    (249) unlabeled -> . pragma
    (268) label -> . LLB IDENTIFIER RLB
    (250) simple_stmt -> . NULL_stmt
    (251) simple_stmt -> . assign_stmt
    (252) simple_stmt -> . exit_stmt
    (253) simple_stmt -> . return_stmt
    (254) simple_stmt -> . goto_stmt
    (255) simple_stmt -> . procedure_call
    (256) simple_stmt -> . delay_stmt
    (257) simple_stmt -> . abort_stmt
    (258) simple_stmt -> . raise_stmt
    (259) simple_stmt -> . code_stmt
    (260) simple_stmt -> . requeue_stmt
    (261) simple_stmt -> . error SEMICOLON
    (262) compound_stmt -> . if_stmt
    (263) compound_stmt -> . case_stmt
    (264) compound_stmt -> . loop_stmt
    (265) compound_stmt -> . block
    (266) compound_stmt -> . accept_stmt
    (267) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (269) NULL_stmt -> . NULL SEMICOLON
    (270) assign_stmt -> . name IS_ASSIGNED expression SEMICOLON
    (302) exit_stmt -> . EXIT name_opt when_opt SEMICOLON
    (307) return_stmt -> . RETURN SEMICOLON
    (308) return_stmt -> . RETURN expression SEMICOLON
    (309) goto_stmt -> . GOTO name SEMICOLON
    (332) procedure_call -> . name SEMICOLON
    (404) delay_stmt -> . DELAY expression SEMICOLON
    (405) delay_stmt -> . DELAY UNTIL expression SEMICOLON
    (425) abort_stmt -> . ABORT name_s SEMICOLON
    (464) raise_stmt -> . RAISE name_opt SEMICOLON
    (510) code_stmt -> . qualified SEMICOLON
    (465) requeue_stmt -> . REQUEUE name SEMICOLON
    (466) requeue_stmt -> . REQUEUE name WITH ABORT SEMICOLON
    (271) if_stmt -> . IF cond_clause else_opt END IF SEMICOLON
    (278) case_stmt -> . case_hdr alternative_s END CASE SEMICOLON
    (283) loop_stmt -> . label_opt iteration basic_loop id_opt SEMICOLON
    (295) block -> . label_opt block_decl block_body END id_opt SEMICOLON
    (399) accept_stmt -> . accept_hdr SEMICOLON
    (400) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt SEMICOLON
    (406) select_stmt -> . select_wait
    (407) select_stmt -> . async_select
    (408) select_stmt -> . timed_entry_call
    (409) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (240) qualified -> . name TICK parenthesized_primary
    (279) case_hdr -> . CASE expression IS
    (284) label_opt -> .
    (285) label_opt -> . IDENTIFIER COLON
    (401) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (410) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON
    (420) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON
    (421) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON
    (422) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    END             reduce using rule 300 (except_handler_part_opt -> .)
    EXCEPTION       shift and go to state 466
    LLB             shift and go to state 289
    error           shift and go to state 309
    PRAGMA          shift and go to state 4
    NULL            shift and go to state 311
    EXIT            shift and go to state 308
    RETURN          shift and go to state 295
    GOTO            shift and go to state 276
    DELAY           shift and go to state 272
    ABORT           shift and go to state 282
    RAISE           shift and go to state 306
    REQUEUE         shift and go to state 298
    IF              shift and go to state 317
    CASE            shift and go to state 297
    WHILE           reduce using rule 284 (label_opt -> .)
    DECLARE         reduce using rule 284 (label_opt -> .)
    FOR             reduce using rule 284 (label_opt -> .)
    LOOP            reduce using rule 284 (label_opt -> .)
    BEGIN           reduce using rule 284 (label_opt -> .)
    IDENTIFIER      shift and go to state 300
    ACCEPT          shift and go to state 284
    SELECT          shift and go to state 286
    STRING          shift and go to state 137

    indexed_comp                   shift and go to state 119
    accept_stmt                    shift and go to state 283
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 316
    abort_stmt                     shift and go to state 310
    except_handler_part_opt        shift and go to state 464
    return_stmt                    shift and go to state 294
    procedure_call                 shift and go to state 285
    assign_stmt                    shift and go to state 320
    simple_name                    shift and go to state 153
    code_stmt                      shift and go to state 313
    case_stmt                      shift and go to state 287
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 146
    label                          shift and go to state 288
    exit_stmt                      shift and go to state 315
    select_stmt                    shift and go to state 274
    statement                      shift and go to state 465
    compound_stmt                  shift and go to state 290
    case_hdr                       shift and go to state 292
    delay_stmt                     shift and go to state 301
    unlabeled                      shift and go to state 314
    simple_stmt                    shift and go to state 277
    except_handler_part            shift and go to state 463
    loop_stmt                      shift and go to state 278
    qualified                      shift and go to state 279
    pragma                         shift and go to state 303
    async_select                   shift and go to state 273
    requeue_stmt                   shift and go to state 304
    raise_stmt                     shift and go to state 305
    name                           shift and go to state 281
    if_stmt                        shift and go to state 280
    accept_hdr                     shift and go to state 302
    cond_entry_call                shift and go to state 318
    timed_entry_call               shift and go to state 307
    label_opt                      shift and go to state 275
    goto_stmt                      shift and go to state 291
    NULL_stmt                      shift and go to state 319
    block                          shift and go to state 293

state 313

    (259) simple_stmt -> code_stmt .

    EXCEPTION       reduce using rule 259 (simple_stmt -> code_stmt .)
    LLB             reduce using rule 259 (simple_stmt -> code_stmt .)
    error           reduce using rule 259 (simple_stmt -> code_stmt .)
    PRAGMA          reduce using rule 259 (simple_stmt -> code_stmt .)
    NULL            reduce using rule 259 (simple_stmt -> code_stmt .)
    EXIT            reduce using rule 259 (simple_stmt -> code_stmt .)
    RETURN          reduce using rule 259 (simple_stmt -> code_stmt .)
    GOTO            reduce using rule 259 (simple_stmt -> code_stmt .)
    DELAY           reduce using rule 259 (simple_stmt -> code_stmt .)
    ABORT           reduce using rule 259 (simple_stmt -> code_stmt .)
    RAISE           reduce using rule 259 (simple_stmt -> code_stmt .)
    REQUEUE         reduce using rule 259 (simple_stmt -> code_stmt .)
    IF              reduce using rule 259 (simple_stmt -> code_stmt .)
    CASE            reduce using rule 259 (simple_stmt -> code_stmt .)
    IDENTIFIER      reduce using rule 259 (simple_stmt -> code_stmt .)
    ACCEPT          reduce using rule 259 (simple_stmt -> code_stmt .)
    SELECT          reduce using rule 259 (simple_stmt -> code_stmt .)
    STRING          reduce using rule 259 (simple_stmt -> code_stmt .)
    WHILE           reduce using rule 259 (simple_stmt -> code_stmt .)
    DECLARE         reduce using rule 259 (simple_stmt -> code_stmt .)
    FOR             reduce using rule 259 (simple_stmt -> code_stmt .)
    LOOP            reduce using rule 259 (simple_stmt -> code_stmt .)
    BEGIN           reduce using rule 259 (simple_stmt -> code_stmt .)
    END             reduce using rule 259 (simple_stmt -> code_stmt .)
    OR              reduce using rule 259 (simple_stmt -> code_stmt .)
    ELSE            reduce using rule 259 (simple_stmt -> code_stmt .)
    ELSIF           reduce using rule 259 (simple_stmt -> code_stmt .)
    THEN            reduce using rule 259 (simple_stmt -> code_stmt .)
    WHEN            reduce using rule 259 (simple_stmt -> code_stmt .)


state 314

    (245) statement -> unlabeled .

    END             reduce using rule 245 (statement -> unlabeled .)
    LLB             reduce using rule 245 (statement -> unlabeled .)
    error           reduce using rule 245 (statement -> unlabeled .)
    PRAGMA          reduce using rule 245 (statement -> unlabeled .)
    NULL            reduce using rule 245 (statement -> unlabeled .)
    EXIT            reduce using rule 245 (statement -> unlabeled .)
    RETURN          reduce using rule 245 (statement -> unlabeled .)
    GOTO            reduce using rule 245 (statement -> unlabeled .)
    DELAY           reduce using rule 245 (statement -> unlabeled .)
    ABORT           reduce using rule 245 (statement -> unlabeled .)
    RAISE           reduce using rule 245 (statement -> unlabeled .)
    REQUEUE         reduce using rule 245 (statement -> unlabeled .)
    IF              reduce using rule 245 (statement -> unlabeled .)
    CASE            reduce using rule 245 (statement -> unlabeled .)
    IDENTIFIER      reduce using rule 245 (statement -> unlabeled .)
    ACCEPT          reduce using rule 245 (statement -> unlabeled .)
    SELECT          reduce using rule 245 (statement -> unlabeled .)
    STRING          reduce using rule 245 (statement -> unlabeled .)
    WHILE           reduce using rule 245 (statement -> unlabeled .)
    DECLARE         reduce using rule 245 (statement -> unlabeled .)
    FOR             reduce using rule 245 (statement -> unlabeled .)
    LOOP            reduce using rule 245 (statement -> unlabeled .)
    BEGIN           reduce using rule 245 (statement -> unlabeled .)
    OR              reduce using rule 245 (statement -> unlabeled .)
    ELSE            reduce using rule 245 (statement -> unlabeled .)
    THEN            reduce using rule 245 (statement -> unlabeled .)
    ELSIF           reduce using rule 245 (statement -> unlabeled .)
    WHEN            reduce using rule 245 (statement -> unlabeled .)
    EXCEPTION       reduce using rule 245 (statement -> unlabeled .)


state 315

    (252) simple_stmt -> exit_stmt .

    EXCEPTION       reduce using rule 252 (simple_stmt -> exit_stmt .)
    LLB             reduce using rule 252 (simple_stmt -> exit_stmt .)
    error           reduce using rule 252 (simple_stmt -> exit_stmt .)
    PRAGMA          reduce using rule 252 (simple_stmt -> exit_stmt .)
    NULL            reduce using rule 252 (simple_stmt -> exit_stmt .)
    EXIT            reduce using rule 252 (simple_stmt -> exit_stmt .)
    RETURN          reduce using rule 252 (simple_stmt -> exit_stmt .)
    GOTO            reduce using rule 252 (simple_stmt -> exit_stmt .)
    DELAY           reduce using rule 252 (simple_stmt -> exit_stmt .)
    ABORT           reduce using rule 252 (simple_stmt -> exit_stmt .)
    RAISE           reduce using rule 252 (simple_stmt -> exit_stmt .)
    REQUEUE         reduce using rule 252 (simple_stmt -> exit_stmt .)
    IF              reduce using rule 252 (simple_stmt -> exit_stmt .)
    CASE            reduce using rule 252 (simple_stmt -> exit_stmt .)
    IDENTIFIER      reduce using rule 252 (simple_stmt -> exit_stmt .)
    ACCEPT          reduce using rule 252 (simple_stmt -> exit_stmt .)
    SELECT          reduce using rule 252 (simple_stmt -> exit_stmt .)
    STRING          reduce using rule 252 (simple_stmt -> exit_stmt .)
    WHILE           reduce using rule 252 (simple_stmt -> exit_stmt .)
    DECLARE         reduce using rule 252 (simple_stmt -> exit_stmt .)
    FOR             reduce using rule 252 (simple_stmt -> exit_stmt .)
    LOOP            reduce using rule 252 (simple_stmt -> exit_stmt .)
    BEGIN           reduce using rule 252 (simple_stmt -> exit_stmt .)
    END             reduce using rule 252 (simple_stmt -> exit_stmt .)
    OR              reduce using rule 252 (simple_stmt -> exit_stmt .)
    ELSE            reduce using rule 252 (simple_stmt -> exit_stmt .)
    ELSIF           reduce using rule 252 (simple_stmt -> exit_stmt .)
    THEN            reduce using rule 252 (simple_stmt -> exit_stmt .)
    WHEN            reduce using rule 252 (simple_stmt -> exit_stmt .)


state 316

    (406) select_stmt -> select_wait .

    END             reduce using rule 406 (select_stmt -> select_wait .)
    LLB             reduce using rule 406 (select_stmt -> select_wait .)
    error           reduce using rule 406 (select_stmt -> select_wait .)
    PRAGMA          reduce using rule 406 (select_stmt -> select_wait .)
    NULL            reduce using rule 406 (select_stmt -> select_wait .)
    EXIT            reduce using rule 406 (select_stmt -> select_wait .)
    RETURN          reduce using rule 406 (select_stmt -> select_wait .)
    GOTO            reduce using rule 406 (select_stmt -> select_wait .)
    DELAY           reduce using rule 406 (select_stmt -> select_wait .)
    ABORT           reduce using rule 406 (select_stmt -> select_wait .)
    RAISE           reduce using rule 406 (select_stmt -> select_wait .)
    REQUEUE         reduce using rule 406 (select_stmt -> select_wait .)
    IF              reduce using rule 406 (select_stmt -> select_wait .)
    CASE            reduce using rule 406 (select_stmt -> select_wait .)
    IDENTIFIER      reduce using rule 406 (select_stmt -> select_wait .)
    ACCEPT          reduce using rule 406 (select_stmt -> select_wait .)
    SELECT          reduce using rule 406 (select_stmt -> select_wait .)
    STRING          reduce using rule 406 (select_stmt -> select_wait .)
    WHILE           reduce using rule 406 (select_stmt -> select_wait .)
    DECLARE         reduce using rule 406 (select_stmt -> select_wait .)
    FOR             reduce using rule 406 (select_stmt -> select_wait .)
    LOOP            reduce using rule 406 (select_stmt -> select_wait .)
    BEGIN           reduce using rule 406 (select_stmt -> select_wait .)
    ELSE            reduce using rule 406 (select_stmt -> select_wait .)
    ELSIF           reduce using rule 406 (select_stmt -> select_wait .)
    WHEN            reduce using rule 406 (select_stmt -> select_wait .)
    EXCEPTION       reduce using rule 406 (select_stmt -> select_wait .)
    OR              reduce using rule 406 (select_stmt -> select_wait .)
    THEN            reduce using rule 406 (select_stmt -> select_wait .)


state 317

    (271) if_stmt -> IF . cond_clause else_opt END IF SEMICOLON
    (272) cond_clause -> . cond_part statement_s
    (273) cond_part -> . condition THEN
    (274) condition -> . expression
    (195) expression -> . relation
    (196) expression -> . expression logical relation
    (197) expression -> . expression short_circuit relation
    (203) relation -> . simple_expression
    (204) relation -> . simple_expression relational simple_expression
    (205) relation -> . simple_expression membership range
    (206) relation -> . simple_expression membership name
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    relation                       shift and go to state 127
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    cond_clause                    shift and go to state 467
    cond_part                      shift and go to state 468
    literal                        shift and go to state 135
    factor                         shift and go to state 136
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    condition                      shift and go to state 469
    term                           shift and go to state 144
    name                           shift and go to state 145
    operator_symbol                shift and go to state 146
    expression                     shift and go to state 470

state 318

    (409) select_stmt -> cond_entry_call .

    END             reduce using rule 409 (select_stmt -> cond_entry_call .)
    LLB             reduce using rule 409 (select_stmt -> cond_entry_call .)
    error           reduce using rule 409 (select_stmt -> cond_entry_call .)
    PRAGMA          reduce using rule 409 (select_stmt -> cond_entry_call .)
    NULL            reduce using rule 409 (select_stmt -> cond_entry_call .)
    EXIT            reduce using rule 409 (select_stmt -> cond_entry_call .)
    RETURN          reduce using rule 409 (select_stmt -> cond_entry_call .)
    GOTO            reduce using rule 409 (select_stmt -> cond_entry_call .)
    DELAY           reduce using rule 409 (select_stmt -> cond_entry_call .)
    ABORT           reduce using rule 409 (select_stmt -> cond_entry_call .)
    RAISE           reduce using rule 409 (select_stmt -> cond_entry_call .)
    REQUEUE         reduce using rule 409 (select_stmt -> cond_entry_call .)
    IF              reduce using rule 409 (select_stmt -> cond_entry_call .)
    CASE            reduce using rule 409 (select_stmt -> cond_entry_call .)
    IDENTIFIER      reduce using rule 409 (select_stmt -> cond_entry_call .)
    ACCEPT          reduce using rule 409 (select_stmt -> cond_entry_call .)
    SELECT          reduce using rule 409 (select_stmt -> cond_entry_call .)
    STRING          reduce using rule 409 (select_stmt -> cond_entry_call .)
    WHILE           reduce using rule 409 (select_stmt -> cond_entry_call .)
    DECLARE         reduce using rule 409 (select_stmt -> cond_entry_call .)
    FOR             reduce using rule 409 (select_stmt -> cond_entry_call .)
    LOOP            reduce using rule 409 (select_stmt -> cond_entry_call .)
    BEGIN           reduce using rule 409 (select_stmt -> cond_entry_call .)
    ELSE            reduce using rule 409 (select_stmt -> cond_entry_call .)
    ELSIF           reduce using rule 409 (select_stmt -> cond_entry_call .)
    WHEN            reduce using rule 409 (select_stmt -> cond_entry_call .)
    EXCEPTION       reduce using rule 409 (select_stmt -> cond_entry_call .)
    OR              reduce using rule 409 (select_stmt -> cond_entry_call .)
    THEN            reduce using rule 409 (select_stmt -> cond_entry_call .)


state 319

    (250) simple_stmt -> NULL_stmt .

    EXCEPTION       reduce using rule 250 (simple_stmt -> NULL_stmt .)
    LLB             reduce using rule 250 (simple_stmt -> NULL_stmt .)
    error           reduce using rule 250 (simple_stmt -> NULL_stmt .)
    PRAGMA          reduce using rule 250 (simple_stmt -> NULL_stmt .)
    NULL            reduce using rule 250 (simple_stmt -> NULL_stmt .)
    EXIT            reduce using rule 250 (simple_stmt -> NULL_stmt .)
    RETURN          reduce using rule 250 (simple_stmt -> NULL_stmt .)
    GOTO            reduce using rule 250 (simple_stmt -> NULL_stmt .)
    DELAY           reduce using rule 250 (simple_stmt -> NULL_stmt .)
    ABORT           reduce using rule 250 (simple_stmt -> NULL_stmt .)
    RAISE           reduce using rule 250 (simple_stmt -> NULL_stmt .)
    REQUEUE         reduce using rule 250 (simple_stmt -> NULL_stmt .)
    IF              reduce using rule 250 (simple_stmt -> NULL_stmt .)
    CASE            reduce using rule 250 (simple_stmt -> NULL_stmt .)
    IDENTIFIER      reduce using rule 250 (simple_stmt -> NULL_stmt .)
    ACCEPT          reduce using rule 250 (simple_stmt -> NULL_stmt .)
    SELECT          reduce using rule 250 (simple_stmt -> NULL_stmt .)
    STRING          reduce using rule 250 (simple_stmt -> NULL_stmt .)
    WHILE           reduce using rule 250 (simple_stmt -> NULL_stmt .)
    DECLARE         reduce using rule 250 (simple_stmt -> NULL_stmt .)
    FOR             reduce using rule 250 (simple_stmt -> NULL_stmt .)
    LOOP            reduce using rule 250 (simple_stmt -> NULL_stmt .)
    BEGIN           reduce using rule 250 (simple_stmt -> NULL_stmt .)
    END             reduce using rule 250 (simple_stmt -> NULL_stmt .)
    OR              reduce using rule 250 (simple_stmt -> NULL_stmt .)
    ELSE            reduce using rule 250 (simple_stmt -> NULL_stmt .)
    ELSIF           reduce using rule 250 (simple_stmt -> NULL_stmt .)
    THEN            reduce using rule 250 (simple_stmt -> NULL_stmt .)
    WHEN            reduce using rule 250 (simple_stmt -> NULL_stmt .)


state 320

    (251) simple_stmt -> assign_stmt .

    EXCEPTION       reduce using rule 251 (simple_stmt -> assign_stmt .)
    LLB             reduce using rule 251 (simple_stmt -> assign_stmt .)
    error           reduce using rule 251 (simple_stmt -> assign_stmt .)
    PRAGMA          reduce using rule 251 (simple_stmt -> assign_stmt .)
    NULL            reduce using rule 251 (simple_stmt -> assign_stmt .)
    EXIT            reduce using rule 251 (simple_stmt -> assign_stmt .)
    RETURN          reduce using rule 251 (simple_stmt -> assign_stmt .)
    GOTO            reduce using rule 251 (simple_stmt -> assign_stmt .)
    DELAY           reduce using rule 251 (simple_stmt -> assign_stmt .)
    ABORT           reduce using rule 251 (simple_stmt -> assign_stmt .)
    RAISE           reduce using rule 251 (simple_stmt -> assign_stmt .)
    REQUEUE         reduce using rule 251 (simple_stmt -> assign_stmt .)
    IF              reduce using rule 251 (simple_stmt -> assign_stmt .)
    CASE            reduce using rule 251 (simple_stmt -> assign_stmt .)
    IDENTIFIER      reduce using rule 251 (simple_stmt -> assign_stmt .)
    ACCEPT          reduce using rule 251 (simple_stmt -> assign_stmt .)
    SELECT          reduce using rule 251 (simple_stmt -> assign_stmt .)
    STRING          reduce using rule 251 (simple_stmt -> assign_stmt .)
    WHILE           reduce using rule 251 (simple_stmt -> assign_stmt .)
    DECLARE         reduce using rule 251 (simple_stmt -> assign_stmt .)
    FOR             reduce using rule 251 (simple_stmt -> assign_stmt .)
    LOOP            reduce using rule 251 (simple_stmt -> assign_stmt .)
    BEGIN           reduce using rule 251 (simple_stmt -> assign_stmt .)
    END             reduce using rule 251 (simple_stmt -> assign_stmt .)
    OR              reduce using rule 251 (simple_stmt -> assign_stmt .)
    ELSE            reduce using rule 251 (simple_stmt -> assign_stmt .)
    ELSIF           reduce using rule 251 (simple_stmt -> assign_stmt .)
    THEN            reduce using rule 251 (simple_stmt -> assign_stmt .)
    WHEN            reduce using rule 251 (simple_stmt -> assign_stmt .)


state 321

    (331) subprog_body -> subprog_spec_is_push decl_part block_body END . id_opt SEMICOLON
    (293) id_opt -> .
    (294) id_opt -> . designator
    (316) designator -> . compound_name
    (317) designator -> . STRING
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name DOT simple_name
    (161) simple_name -> . IDENTIFIER

    SEMICOLON       reduce using rule 293 (id_opt -> .)
    STRING          shift and go to state 114
    IDENTIFIER      shift and go to state 40

    designator                     shift and go to state 471
    id_opt                         shift and go to state 472
    compound_name                  shift and go to state 113
    simple_name                    shift and go to state 41

state 322

    (503) attrib_def -> FOR mark USE . expression SEMICOLON
    (504) record_type_spec -> FOR mark USE . RECORD align_opt comp_loc_s END RECORD SEMICOLON
    (509) address_spec -> FOR mark USE . AT expression SEMICOLON
    (195) expression -> . relation
    (196) expression -> . expression logical relation
    (197) expression -> . expression short_circuit relation
    (203) relation -> . simple_expression
    (204) relation -> . simple_expression relational simple_expression
    (205) relation -> . simple_expression membership range
    (206) relation -> . simple_expression membership name
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    RECORD          shift and go to state 473
    AT              shift and go to state 474
    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    relation                       shift and go to state 127
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    factor                         shift and go to state 136
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    term                           shift and go to state 144
    name                           shift and go to state 145
    operator_symbol                shift and go to state 146
    expression                     shift and go to state 475

state 323

    (159) mark -> mark TICK . attribute_id
    (180) attribute_id -> . IDENTIFIER
    (181) attribute_id -> . DIGITS
    (182) attribute_id -> . DELTA
    (183) attribute_id -> . ACCESS

    IDENTIFIER      shift and go to state 384
    DIGITS          shift and go to state 383
    DELTA           shift and go to state 387
    ACCESS          shift and go to state 385

    attribute_id                   shift and go to state 476

state 324

    (160) mark -> mark DOT . simple_name
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 40

    simple_name                    shift and go to state 477

state 325

    (365) task_body -> TASK BODY simple_name . IS decl_part block_body END id_opt SEMICOLON
    (451) body_stub -> TASK BODY simple_name . IS SEPARATE SEMICOLON

    IS              shift and go to state 478


state 326

    (360) task_spec -> TASK TYPE simple_name . discrim_part_opt task_def
    (37) discrim_part_opt -> .
    (38) discrim_part_opt -> . discrim_part
    (39) discrim_part_opt -> . LPAREN BOX RPAREN
    (110) discrim_part -> . LPAREN discrim_spec_s RPAREN

    IS              reduce using rule 37 (discrim_part_opt -> .)
    SEMICOLON       reduce using rule 37 (discrim_part_opt -> .)
    LPAREN          shift and go to state 331

    discrim_part_opt               shift and go to state 479
    discrim_part                   shift and go to state 332

state 327

    (362) task_def -> IS . entry_decl_s rep_spec_s task_private_opt END id_opt
    (388) entry_decl_s -> . pragma_s
    (389) entry_decl_s -> . entry_decl_s entry_decl pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    ENTRY           reduce using rule 8 (pragma_s -> .)
    PRIVATE         reduce using rule 8 (pragma_s -> .)
    FOR             reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)

    entry_decl_s                   shift and go to state 480
    pragma_s                       shift and go to state 481

state 328

    (359) task_spec -> TASK simple_name task_def .

    SEMICOLON       reduce using rule 359 (task_spec -> TASK simple_name task_def .)


state 329

    (340) pkg_body -> PACKAGE BODY compound_name . IS decl_part body_opt END c_id_opt SEMICOLON
    (452) body_stub -> PACKAGE BODY compound_name . IS SEPARATE SEMICOLON
    (163) compound_name -> compound_name . DOT simple_name

    IS              shift and go to state 482
    DOT             shift and go to state 118


state 330

    (36) type_decl -> TYPE IDENTIFIER discrim_part_opt . type_completion SEMICOLON
    (40) type_completion -> .
    (41) type_completion -> . IS type_def

    SEMICOLON       reduce using rule 40 (type_completion -> .)
    IS              shift and go to state 483

    type_completion                shift and go to state 484

state 331

    (39) discrim_part_opt -> LPAREN . BOX RPAREN
    (110) discrim_part -> LPAREN . discrim_spec_s RPAREN
    (111) discrim_spec_s -> . discrim_spec
    (112) discrim_spec_s -> . discrim_spec_s SEMICOLON discrim_spec
    (113) discrim_spec -> . def_id_s COLON access_opt mark init_opt
    (114) discrim_spec -> . error
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s COMMA def_id
    (26) def_id -> . IDENTIFIER

    BOX             shift and go to state 485
    error           shift and go to state 489
    IDENTIFIER      shift and go to state 79

    discrim_spec                   shift and go to state 486
    discrim_spec_s                 shift and go to state 487
    def_id                         shift and go to state 96
    def_id_s                       shift and go to state 488

state 332

    (38) discrim_part_opt -> discrim_part .

    IS              reduce using rule 38 (discrim_part_opt -> discrim_part .)
    SEMICOLON       reduce using rule 38 (discrim_part_opt -> discrim_part .)


state 333

    (48) subtype_decl -> SUBTYPE IDENTIFIER IS . subtype_ind SEMICOLON
    (49) subtype_ind -> . name constraint
    (50) subtype_ind -> . name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    name                           shift and go to state 490
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 146
    subtype_ind                    shift and go to state 491
    indexed_comp                   shift and go to state 119
    simple_name                    shift and go to state 153

state 334

    (453) body_stub -> subprog_spec IS SEPARATE . SEMICOLON

    SEMICOLON       shift and go to state 492


state 335

    (35) number_decl -> def_id_s COLON CONSTANT . IS_ASSIGNED expression SEMICOLON
    (29) object_qualifier_opt -> CONSTANT .

    IS_ASSIGNED     shift and go to state 493
    ARRAY           reduce using rule 29 (object_qualifier_opt -> CONSTANT .)
    IDENTIFIER      reduce using rule 29 (object_qualifier_opt -> CONSTANT .)
    STRING          reduce using rule 29 (object_qualifier_opt -> CONSTANT .)


state 336

    (455) exception_decl -> def_id_s COLON EXCEPTION . SEMICOLON
    (351) rename_decl -> def_id_s COLON EXCEPTION . renames SEMICOLON
    (357) renames -> . RENAMES name

    SEMICOLON       shift and go to state 494
    RENAMES         shift and go to state 51

    renames                        shift and go to state 495

state 337

    (28) object_qualifier_opt -> ALIASED .
    (30) object_qualifier_opt -> ALIASED . CONSTANT

    ARRAY           reduce using rule 28 (object_qualifier_opt -> ALIASED .)
    IDENTIFIER      reduce using rule 28 (object_qualifier_opt -> ALIASED .)
    STRING          reduce using rule 28 (object_qualifier_opt -> ALIASED .)
    CONSTANT        shift and go to state 496


state 338

    (23) object_decl -> def_id_s COLON object_qualifier_opt . object_subtype_def init_opt SEMICOLON
    (350) rename_decl -> def_id_s COLON object_qualifier_opt . subtype_ind renames SEMICOLON
    (31) object_subtype_def -> . subtype_ind
    (32) object_subtype_def -> . array_type
    (49) subtype_ind -> . name constraint
    (50) subtype_ind -> . name
    (78) array_type -> . unconstr_array_type
    (79) array_type -> . constr_array_type
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (80) unconstr_array_type -> . ARRAY LPAREN index_s RPAREN OF component_subtype_def
    (81) constr_array_type -> . ARRAY iter_index_constraint OF component_subtype_def
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    ARRAY           shift and go to state 497
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    indexed_comp                   shift and go to state 119
    simple_name                    shift and go to state 153
    array_type                     shift and go to state 498
    name                           shift and go to state 490
    object_subtype_def             shift and go to state 499
    constr_array_type              shift and go to state 500
    operator_symbol                shift and go to state 146
    subtype_ind                    shift and go to state 501
    unconstr_array_type            shift and go to state 502

state 339

    (25) def_id_s -> def_id_s COMMA def_id .

    COLON           reduce using rule 25 (def_id_s -> def_id_s COMMA def_id .)
    COMMA           reduce using rule 25 (def_id_s -> def_id_s COMMA def_id .)


state 340

    (474) generic_formal -> WITH FUNCTION designator . formal_part_opt RETURN name subp_default SEMICOLON
    (318) formal_part_opt -> .
    (319) formal_part_opt -> . formal_part
    (320) formal_part -> . LPAREN param_s RPAREN

    RETURN          reduce using rule 318 (formal_part_opt -> .)
    LPAREN          shift and go to state 164

    formal_part                    shift and go to state 162
    formal_part_opt                shift and go to state 503

state 341

    (475) generic_formal -> WITH PACKAGE simple_name . IS NEW name LPAREN BOX RPAREN SEMICOLON
    (476) generic_formal -> WITH PACKAGE simple_name . IS NEW name SEMICOLON

    IS              shift and go to state 504


state 342

    (473) generic_formal -> WITH PROCEDURE simple_name . formal_part_opt subp_default SEMICOLON
    (318) formal_part_opt -> .
    (319) formal_part_opt -> . formal_part
    (320) formal_part -> . LPAREN param_s RPAREN

    IS              reduce using rule 318 (formal_part_opt -> .)
    SEMICOLON       reduce using rule 318 (formal_part_opt -> .)
    LPAREN          shift and go to state 164

    formal_part                    shift and go to state 162
    formal_part_opt                shift and go to state 505

state 343

    (356) rename_unit -> generic_formal_part subprog_spec renames SEMICOLON .

    PACKAGE         reduce using rule 356 (rename_unit -> generic_formal_part subprog_spec renames SEMICOLON .)
    TASK            reduce using rule 356 (rename_unit -> generic_formal_part subprog_spec renames SEMICOLON .)
    PROTECTED       reduce using rule 356 (rename_unit -> generic_formal_part subprog_spec renames SEMICOLON .)
    error           reduce using rule 356 (rename_unit -> generic_formal_part subprog_spec renames SEMICOLON .)
    USE             reduce using rule 356 (rename_unit -> generic_formal_part subprog_spec renames SEMICOLON .)
    PRAGMA          reduce using rule 356 (rename_unit -> generic_formal_part subprog_spec renames SEMICOLON .)
    TYPE            reduce using rule 356 (rename_unit -> generic_formal_part subprog_spec renames SEMICOLON .)
    SUBTYPE         reduce using rule 356 (rename_unit -> generic_formal_part subprog_spec renames SEMICOLON .)
    FOR             reduce using rule 356 (rename_unit -> generic_formal_part subprog_spec renames SEMICOLON .)
    PROCEDURE       reduce using rule 356 (rename_unit -> generic_formal_part subprog_spec renames SEMICOLON .)
    FUNCTION        reduce using rule 356 (rename_unit -> generic_formal_part subprog_spec renames SEMICOLON .)
    GENERIC         reduce using rule 356 (rename_unit -> generic_formal_part subprog_spec renames SEMICOLON .)
    IDENTIFIER      reduce using rule 356 (rename_unit -> generic_formal_part subprog_spec renames SEMICOLON .)
    BEGIN           reduce using rule 356 (rename_unit -> generic_formal_part subprog_spec renames SEMICOLON .)
    PRIVATE         reduce using rule 356 (rename_unit -> generic_formal_part subprog_spec renames SEMICOLON .)
    END             reduce using rule 356 (rename_unit -> generic_formal_part subprog_spec renames SEMICOLON .)
    WITH            reduce using rule 356 (rename_unit -> generic_formal_part subprog_spec renames SEMICOLON .)
    SEPARATE        reduce using rule 356 (rename_unit -> generic_formal_part subprog_spec renames SEMICOLON .)
    $end            reduce using rule 356 (rename_unit -> generic_formal_part subprog_spec renames SEMICOLON .)


state 344

    (329) mode -> ACCESS .

    IDENTIFIER      reduce using rule 329 (mode -> ACCESS .)


state 345

    (326) mode -> IN .
    (328) mode -> IN . OUT

    IDENTIFIER      reduce using rule 326 (mode -> IN .)
    OUT             shift and go to state 506


state 346

    (327) mode -> OUT .

    IDENTIFIER      reduce using rule 327 (mode -> OUT .)


state 347

    (323) param -> def_id_s COLON mode . mark init_opt
    (158) mark -> . simple_name
    (159) mark -> . mark TICK attribute_id
    (160) mark -> . mark DOT simple_name
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 40

    mark                           shift and go to state 507
    simple_name                    shift and go to state 171

state 348

    (355) rename_unit -> generic_formal_part PACKAGE compound_name renames . SEMICOLON

    SEMICOLON       shift and go to state 508


state 349

    (335) pkg_spec -> PACKAGE compound_name IS . decl_item_s private_part END c_id_opt
    (137) decl_item_s -> .
    (138) decl_item_s -> . decl_item_s1
    (139) decl_item_s1 -> . decl_item
    (140) decl_item_s1 -> . decl_item_s1 decl_item
    (141) decl_item -> . decl
    (142) decl_item -> . use_clause
    (143) decl_item -> . rep_spec
    (144) decl_item -> . pragma
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error SEMICOLON
    (346) use_clause -> . USE name_s SEMICOLON
    (347) use_clause -> . USE TYPE name_s SEMICOLON
    (500) rep_spec -> . attrib_def
    (501) rep_spec -> . record_type_spec
    (502) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (23) object_decl -> . def_id_s COLON object_qualifier_opt object_subtype_def init_opt SEMICOLON
    (35) number_decl -> . def_id_s COLON CONSTANT IS_ASSIGNED expression SEMICOLON
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion SEMICOLON
    (48) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind SEMICOLON
    (310) subprog_decl -> . subprog_spec SEMICOLON
    (311) subprog_decl -> . generic_subp_inst SEMICOLON
    (312) subprog_decl -> . subprog_spec_is_push ABSTRACT SEMICOLON
    (333) pkg_decl -> . pkg_spec SEMICOLON
    (334) pkg_decl -> . generic_pkg_inst SEMICOLON
    (358) task_decl -> . task_spec SEMICOLON
    (366) prot_decl -> . prot_spec SEMICOLON
    (455) exception_decl -> . def_id_s COLON EXCEPTION SEMICOLON
    (350) rename_decl -> . def_id_s COLON object_qualifier_opt subtype_ind renames SEMICOLON
    (351) rename_decl -> . def_id_s COLON EXCEPTION renames SEMICOLON
    (352) rename_decl -> . rename_unit
    (467) generic_decl -> . generic_formal_part subprog_spec SEMICOLON
    (468) generic_decl -> . generic_formal_part pkg_spec SEMICOLON
    (451) body_stub -> . TASK BODY simple_name IS SEPARATE SEMICOLON
    (452) body_stub -> . PACKAGE BODY compound_name IS SEPARATE SEMICOLON
    (453) body_stub -> . subprog_spec IS SEPARATE SEMICOLON
    (454) body_stub -> . PROTECTED BODY simple_name IS SEPARATE SEMICOLON
    (503) attrib_def -> . FOR mark USE expression SEMICOLON
    (504) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD SEMICOLON
    (509) address_spec -> . FOR mark USE AT expression SEMICOLON
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s COMMA def_id
    (313) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (314) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (315) subprog_spec -> . FUNCTION designator
    (497) generic_subp_inst -> . subprog_spec IS generic_inst
    (330) subprog_spec_is_push -> . subprog_spec IS
    (335) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (498) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (359) task_spec -> . TASK simple_name task_def
    (360) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (367) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (368) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (353) rename_unit -> . PACKAGE compound_name renames SEMICOLON
    (354) rename_unit -> . subprog_spec renames SEMICOLON
    (355) rename_unit -> . generic_formal_part PACKAGE compound_name renames SEMICOLON
    (356) rename_unit -> . generic_formal_part subprog_spec renames SEMICOLON
    (469) generic_formal_part -> . GENERIC
    (470) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    PRIVATE         reduce using rule 137 (decl_item_s -> .)
    END             reduce using rule 137 (decl_item_s -> .)
    error           shift and go to state 85
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 87
    SUBTYPE         shift and go to state 91
    TASK            shift and go to state 262
    PACKAGE         shift and go to state 263
    PROTECTED       shift and go to state 259
    FOR             shift and go to state 70
    PROCEDURE       shift and go to state 30
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 79

    decl                           shift and go to state 57
    task_decl                      shift and go to state 67
    subtype_decl                   shift and go to state 68
    rep_spec                       shift and go to state 89
    decl_item_s1                   shift and go to state 258
    exception_decl                 shift and go to state 92
    address_spec                   shift and go to state 59
    subprog_spec_is_push           shift and go to state 264
    prot_decl                      shift and go to state 62
    record_type_spec               shift and go to state 75
    generic_decl                   shift and go to state 76
    attrib_def                     shift and go to state 77
    subprog_spec                   shift and go to state 265
    def_id_s                       shift and go to state 95
    decl_item                      shift and go to state 260
    task_spec                      shift and go to state 72
    object_decl                    shift and go to state 71
    body_stub                      shift and go to state 81
    generic_subp_inst              shift and go to state 28
    def_id                         shift and go to state 96
    rename_decl                    shift and go to state 97
    type_decl                      shift and go to state 63
    rename_unit                    shift and go to state 98
    pkg_decl                       shift and go to state 64
    prot_spec                      shift and go to state 83
    generic_formal_part            shift and go to state 33
    use_clause                     shift and go to state 73
    generic_pkg_inst               shift and go to state 34
    subprog_decl                   shift and go to state 65
    decl_item_s                    shift and go to state 261
    pragma                         shift and go to state 82
    pkg_spec                       shift and go to state 37
    number_decl                    shift and go to state 100

state 350

    (472) generic_formal -> TYPE simple_name generic_discrim_part_opt . IS generic_type_def SEMICOLON

    IS              shift and go to state 509


state 351

    (480) generic_discrim_part_opt -> LPAREN . BOX RPAREN
    (110) discrim_part -> LPAREN . discrim_spec_s RPAREN
    (111) discrim_spec_s -> . discrim_spec
    (112) discrim_spec_s -> . discrim_spec_s SEMICOLON discrim_spec
    (113) discrim_spec -> . def_id_s COLON access_opt mark init_opt
    (114) discrim_spec -> . error
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s COMMA def_id
    (26) def_id -> . IDENTIFIER

    BOX             shift and go to state 510
    error           shift and go to state 489
    IDENTIFIER      shift and go to state 79

    discrim_spec                   shift and go to state 486
    discrim_spec_s                 shift and go to state 487
    def_id                         shift and go to state 96
    def_id_s                       shift and go to state 488

state 352

    (479) generic_discrim_part_opt -> discrim_part .

    IS              reduce using rule 479 (generic_discrim_part_opt -> discrim_part .)


state 353

    (314) subprog_spec -> FUNCTION designator formal_part_opt RETURN . name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    name                           shift and go to state 511
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    indexed_comp                   shift and go to state 119
    operator_symbol                shift and go to state 146
    simple_name                    shift and go to state 153

state 354

    (232) factor -> primary POW primary .

    TIMES           reduce using rule 232 (factor -> primary POW primary .)
    DIVIDE          reduce using rule 232 (factor -> primary POW primary .)
    MOD             reduce using rule 232 (factor -> primary POW primary .)
    REM             reduce using rule 232 (factor -> primary POW primary .)
    DOUBLEDOT       reduce using rule 232 (factor -> primary POW primary .)
    EQ              reduce using rule 232 (factor -> primary POW primary .)
    NE              reduce using rule 232 (factor -> primary POW primary .)
    LT              reduce using rule 232 (factor -> primary POW primary .)
    LE              reduce using rule 232 (factor -> primary POW primary .)
    GT              reduce using rule 232 (factor -> primary POW primary .)
    GE              reduce using rule 232 (factor -> primary POW primary .)
    IN              reduce using rule 232 (factor -> primary POW primary .)
    NOT             reduce using rule 232 (factor -> primary POW primary .)
    PLUS            reduce using rule 232 (factor -> primary POW primary .)
    MINUS           reduce using rule 232 (factor -> primary POW primary .)
    AMPERSAND       reduce using rule 232 (factor -> primary POW primary .)
    AND             reduce using rule 232 (factor -> primary POW primary .)
    OR              reduce using rule 232 (factor -> primary POW primary .)
    XOR             reduce using rule 232 (factor -> primary POW primary .)
    RPAREN          reduce using rule 232 (factor -> primary POW primary .)
    COMMA           reduce using rule 232 (factor -> primary POW primary .)
    ARROW           reduce using rule 232 (factor -> primary POW primary .)
    |               reduce using rule 232 (factor -> primary POW primary .)
    DIGITS          reduce using rule 232 (factor -> primary POW primary .)
    RANGE           reduce using rule 232 (factor -> primary POW primary .)
    SEMICOLON       reduce using rule 232 (factor -> primary POW primary .)
    IS              reduce using rule 232 (factor -> primary POW primary .)
    THEN            reduce using rule 232 (factor -> primary POW primary .)
    LOOP            reduce using rule 232 (factor -> primary POW primary .)
    WITH            reduce using rule 232 (factor -> primary POW primary .)
    RENAMES         reduce using rule 232 (factor -> primary POW primary .)
    IS_ASSIGNED     reduce using rule 232 (factor -> primary POW primary .)


state 355

    (217) simple_expression -> simple_expression adding term .
    (224) term -> term . multiplying factor
    (225) multiplying -> . TIMES
    (226) multiplying -> . DIVIDE
    (227) multiplying -> . MOD
    (228) multiplying -> . REM

    DOUBLEDOT       reduce using rule 217 (simple_expression -> simple_expression adding term .)
    PLUS            reduce using rule 217 (simple_expression -> simple_expression adding term .)
    MINUS           reduce using rule 217 (simple_expression -> simple_expression adding term .)
    AMPERSAND       reduce using rule 217 (simple_expression -> simple_expression adding term .)
    COMMA           reduce using rule 217 (simple_expression -> simple_expression adding term .)
    ARROW           reduce using rule 217 (simple_expression -> simple_expression adding term .)
    |               reduce using rule 217 (simple_expression -> simple_expression adding term .)
    AND             reduce using rule 217 (simple_expression -> simple_expression adding term .)
    OR              reduce using rule 217 (simple_expression -> simple_expression adding term .)
    XOR             reduce using rule 217 (simple_expression -> simple_expression adding term .)
    RPAREN          reduce using rule 217 (simple_expression -> simple_expression adding term .)
    WITH            reduce using rule 217 (simple_expression -> simple_expression adding term .)
    SEMICOLON       reduce using rule 217 (simple_expression -> simple_expression adding term .)
    IS              reduce using rule 217 (simple_expression -> simple_expression adding term .)
    THEN            reduce using rule 217 (simple_expression -> simple_expression adding term .)
    LOOP            reduce using rule 217 (simple_expression -> simple_expression adding term .)
    RANGE           reduce using rule 217 (simple_expression -> simple_expression adding term .)
    DIGITS          reduce using rule 217 (simple_expression -> simple_expression adding term .)
    RENAMES         reduce using rule 217 (simple_expression -> simple_expression adding term .)
    IS_ASSIGNED     reduce using rule 217 (simple_expression -> simple_expression adding term .)
    EQ              reduce using rule 217 (simple_expression -> simple_expression adding term .)
    NE              reduce using rule 217 (simple_expression -> simple_expression adding term .)
    LT              reduce using rule 217 (simple_expression -> simple_expression adding term .)
    LE              reduce using rule 217 (simple_expression -> simple_expression adding term .)
    GT              reduce using rule 217 (simple_expression -> simple_expression adding term .)
    GE              reduce using rule 217 (simple_expression -> simple_expression adding term .)
    IN              reduce using rule 217 (simple_expression -> simple_expression adding term .)
    NOT             reduce using rule 217 (simple_expression -> simple_expression adding term .)
    TIMES           shift and go to state 238
    DIVIDE          shift and go to state 236
    MOD             shift and go to state 239
    REM             shift and go to state 237

    multiplying                    shift and go to state 235

state 356

    (60) range -> simple_expression . DOUBLEDOT simple_expression
    (217) simple_expression -> simple_expression . adding term
    (220) adding -> . PLUS
    (221) adding -> . MINUS
    (222) adding -> . AMPERSAND

    DOUBLEDOT       shift and go to state 364
    PLUS            shift and go to state 212
    MINUS           shift and go to state 217
    AMPERSAND       shift and go to state 207

    adding                         shift and go to state 204

state 357

    (206) relation -> simple_expression membership name .
    (61) range -> name . TICK RANGE
    (62) range -> name . TICK RANGE LPAREN expression RPAREN
    (168) indexed_comp -> name . LPAREN value_s RPAREN
    (175) selected_comp -> name . DOT simple_name
    (176) selected_comp -> name . DOT used_char
    (177) selected_comp -> name . DOT operator_symbol
    (178) selected_comp -> name . DOT ALL
    (179) attribute -> name . TICK attribute_id
    (237) primary -> name .
    (240) qualified -> name . TICK parenthesized_primary

    AND             reduce using rule 206 (relation -> simple_expression membership name .)
    OR              reduce using rule 206 (relation -> simple_expression membership name .)
    XOR             reduce using rule 206 (relation -> simple_expression membership name .)
    RPAREN          reduce using rule 206 (relation -> simple_expression membership name .)
    COMMA           reduce using rule 206 (relation -> simple_expression membership name .)
    ARROW           reduce using rule 206 (relation -> simple_expression membership name .)
    |               reduce using rule 206 (relation -> simple_expression membership name .)
    SEMICOLON       reduce using rule 206 (relation -> simple_expression membership name .)
    RANGE           reduce using rule 206 (relation -> simple_expression membership name .)
    IS              reduce using rule 206 (relation -> simple_expression membership name .)
    LOOP            reduce using rule 206 (relation -> simple_expression membership name .)
    THEN            reduce using rule 206 (relation -> simple_expression membership name .)
    DIGITS          reduce using rule 206 (relation -> simple_expression membership name .)
    WITH            reduce using rule 206 (relation -> simple_expression membership name .)
    RENAMES         reduce using rule 206 (relation -> simple_expression membership name .)
    IS_ASSIGNED     reduce using rule 206 (relation -> simple_expression membership name .)
    TICK            shift and go to state 373
    LPAREN          shift and go to state 240
    DOT             shift and go to state 242
    POW             reduce using rule 237 (primary -> name .)
    TIMES           reduce using rule 237 (primary -> name .)
    DIVIDE          reduce using rule 237 (primary -> name .)
    MOD             reduce using rule 237 (primary -> name .)
    REM             reduce using rule 237 (primary -> name .)
    DOUBLEDOT       reduce using rule 237 (primary -> name .)
    PLUS            reduce using rule 237 (primary -> name .)
    MINUS           reduce using rule 237 (primary -> name .)
    AMPERSAND       reduce using rule 237 (primary -> name .)


state 358

    (205) relation -> simple_expression membership range .

    AND             reduce using rule 205 (relation -> simple_expression membership range .)
    OR              reduce using rule 205 (relation -> simple_expression membership range .)
    XOR             reduce using rule 205 (relation -> simple_expression membership range .)
    RPAREN          reduce using rule 205 (relation -> simple_expression membership range .)
    COMMA           reduce using rule 205 (relation -> simple_expression membership range .)
    ARROW           reduce using rule 205 (relation -> simple_expression membership range .)
    |               reduce using rule 205 (relation -> simple_expression membership range .)
    SEMICOLON       reduce using rule 205 (relation -> simple_expression membership range .)
    RANGE           reduce using rule 205 (relation -> simple_expression membership range .)
    IS              reduce using rule 205 (relation -> simple_expression membership range .)
    LOOP            reduce using rule 205 (relation -> simple_expression membership range .)
    THEN            reduce using rule 205 (relation -> simple_expression membership range .)
    DIGITS          reduce using rule 205 (relation -> simple_expression membership range .)
    WITH            reduce using rule 205 (relation -> simple_expression membership range .)
    RENAMES         reduce using rule 205 (relation -> simple_expression membership range .)
    IS_ASSIGNED     reduce using rule 205 (relation -> simple_expression membership range .)


state 359

    (214) membership -> NOT IN .

    IDENTIFIER      reduce using rule 214 (membership -> NOT IN .)
    STRING          reduce using rule 214 (membership -> NOT IN .)
    PLUS            reduce using rule 214 (membership -> NOT IN .)
    MINUS           reduce using rule 214 (membership -> NOT IN .)
    NOT             reduce using rule 214 (membership -> NOT IN .)
    ABS             reduce using rule 214 (membership -> NOT IN .)
    NUMBER          reduce using rule 214 (membership -> NOT IN .)
    NULL            reduce using rule 214 (membership -> NOT IN .)
    NEW             reduce using rule 214 (membership -> NOT IN .)
    LPAREN          reduce using rule 214 (membership -> NOT IN .)
    CHARACTER       reduce using rule 214 (membership -> NOT IN .)


state 360

    (204) relation -> simple_expression relational simple_expression .
    (217) simple_expression -> simple_expression . adding term
    (220) adding -> . PLUS
    (221) adding -> . MINUS
    (222) adding -> . AMPERSAND

    AND             reduce using rule 204 (relation -> simple_expression relational simple_expression .)
    OR              reduce using rule 204 (relation -> simple_expression relational simple_expression .)
    XOR             reduce using rule 204 (relation -> simple_expression relational simple_expression .)
    RPAREN          reduce using rule 204 (relation -> simple_expression relational simple_expression .)
    COMMA           reduce using rule 204 (relation -> simple_expression relational simple_expression .)
    ARROW           reduce using rule 204 (relation -> simple_expression relational simple_expression .)
    |               reduce using rule 204 (relation -> simple_expression relational simple_expression .)
    SEMICOLON       reduce using rule 204 (relation -> simple_expression relational simple_expression .)
    RANGE           reduce using rule 204 (relation -> simple_expression relational simple_expression .)
    IS              reduce using rule 204 (relation -> simple_expression relational simple_expression .)
    LOOP            reduce using rule 204 (relation -> simple_expression relational simple_expression .)
    THEN            reduce using rule 204 (relation -> simple_expression relational simple_expression .)
    DIGITS          reduce using rule 204 (relation -> simple_expression relational simple_expression .)
    WITH            reduce using rule 204 (relation -> simple_expression relational simple_expression .)
    RENAMES         reduce using rule 204 (relation -> simple_expression relational simple_expression .)
    IS_ASSIGNED     reduce using rule 204 (relation -> simple_expression relational simple_expression .)
    PLUS            shift and go to state 212
    MINUS           shift and go to state 217
    AMPERSAND       shift and go to state 207

    adding                         shift and go to state 204

state 361

    (7) pragma_arg -> simple_name ARROW expression .
    (196) expression -> expression . logical relation
    (197) expression -> expression . short_circuit relation
    (198) logical -> . AND
    (199) logical -> . OR
    (200) logical -> . XOR
    (201) short_circuit -> . AND THEN
    (202) short_circuit -> . OR ELSE

    RPAREN          reduce using rule 7 (pragma_arg -> simple_name ARROW expression .)
    COMMA           reduce using rule 7 (pragma_arg -> simple_name ARROW expression .)
    AND             shift and go to state 244
    OR              shift and go to state 248
    XOR             shift and go to state 245

    short_circuit                  shift and go to state 247
    logical                        shift and go to state 246

state 362

    (3) pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .

    error           reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)
    USE             reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)
    PRAGMA          reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)
    TYPE            reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)
    SUBTYPE         reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)
    TASK            reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)
    PACKAGE         reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)
    PROTECTED       reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)
    FOR             reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)
    PROCEDURE       reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)
    GENERIC         reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)
    PRIVATE         reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)
    END             reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)
    ENTRY           reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)
    BEGIN           reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)
    LLB             reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)
    NULL            reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)
    EXIT            reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)
    RETURN          reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)
    GOTO            reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)
    DELAY           reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)
    ABORT           reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)
    RAISE           reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)
    REQUEUE         reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)
    IF              reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)
    CASE            reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)
    ACCEPT          reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)
    SELECT          reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)
    STRING          reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)
    WHILE           reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)
    DECLARE         reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)
    LOOP            reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)
    WITH            reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)
    SEPARATE        reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)
    $end            reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)
    OR              reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)
    ELSE            reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)
    ELSIF           reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)
    WHEN            reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)
    THEN            reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)
    EXCEPTION       reduce using rule 3 (pragma -> PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON .)


state 363

    (5) pragma_arg_s -> pragma_arg_s COMMA pragma_arg .

    RPAREN          reduce using rule 5 (pragma_arg_s -> pragma_arg_s COMMA pragma_arg .)
    COMMA           reduce using rule 5 (pragma_arg_s -> pragma_arg_s COMMA pragma_arg .)


state 364

    (60) range -> simple_expression DOUBLEDOT . simple_expression
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    simple_expression              shift and go to state 512
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    factor                         shift and go to state 136
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    term                           shift and go to state 144
    name                           shift and go to state 145
    operator_symbol                shift and go to state 146

state 365

    (191) aggregate -> LPAREN NULL RECORD . RPAREN

    RPAREN          shift and go to state 513


state 366

    (122) choice_s -> choice_s | . choice
    (123) choice -> . expression
    (124) choice -> . discrete_with_range
    (125) choice -> . OTHERS
    (195) expression -> . relation
    (196) expression -> . expression logical relation
    (197) expression -> . expression short_circuit relation
    (126) discrete_with_range -> . name range_constraint
    (127) discrete_with_range -> . range
    (203) relation -> . simple_expression
    (204) relation -> . simple_expression relational simple_expression
    (205) relation -> . simple_expression membership range
    (206) relation -> . simple_expression membership name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (60) range -> . simple_expression DOUBLEDOT simple_expression
    (61) range -> . name TICK RANGE
    (62) range -> . name TICK RANGE LPAREN expression RPAREN
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN

    OTHERS          shift and go to state 222
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137
    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    relation                       shift and go to state 127
    simple_expression              shift and go to state 379
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    factor                         shift and go to state 136
    choice                         shift and go to state 514
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    discrete_with_range            shift and go to state 515
    term                           shift and go to state 144
    name                           shift and go to state 230
    operator_symbol                shift and go to state 146
    range                          shift and go to state 232
    expression                     shift and go to state 516

state 367

    (194) comp_assoc -> choice_s ARROW . expression
    (195) expression -> . relation
    (196) expression -> . expression logical relation
    (197) expression -> . expression short_circuit relation
    (203) relation -> . simple_expression
    (204) relation -> . simple_expression relational simple_expression
    (205) relation -> . simple_expression membership range
    (206) relation -> . simple_expression membership name
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    relation                       shift and go to state 127
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    factor                         shift and go to state 136
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    term                           shift and go to state 144
    name                           shift and go to state 145
    operator_symbol                shift and go to state 146
    expression                     shift and go to state 517

state 368

    (187) aggregate -> LPAREN comp_assoc RPAREN .

    POW             reduce using rule 187 (aggregate -> LPAREN comp_assoc RPAREN .)
    TIMES           reduce using rule 187 (aggregate -> LPAREN comp_assoc RPAREN .)
    DIVIDE          reduce using rule 187 (aggregate -> LPAREN comp_assoc RPAREN .)
    MOD             reduce using rule 187 (aggregate -> LPAREN comp_assoc RPAREN .)
    REM             reduce using rule 187 (aggregate -> LPAREN comp_assoc RPAREN .)
    EQ              reduce using rule 187 (aggregate -> LPAREN comp_assoc RPAREN .)
    NE              reduce using rule 187 (aggregate -> LPAREN comp_assoc RPAREN .)
    LT              reduce using rule 187 (aggregate -> LPAREN comp_assoc RPAREN .)
    LE              reduce using rule 187 (aggregate -> LPAREN comp_assoc RPAREN .)
    GT              reduce using rule 187 (aggregate -> LPAREN comp_assoc RPAREN .)
    GE              reduce using rule 187 (aggregate -> LPAREN comp_assoc RPAREN .)
    IN              reduce using rule 187 (aggregate -> LPAREN comp_assoc RPAREN .)
    NOT             reduce using rule 187 (aggregate -> LPAREN comp_assoc RPAREN .)
    PLUS            reduce using rule 187 (aggregate -> LPAREN comp_assoc RPAREN .)
    MINUS           reduce using rule 187 (aggregate -> LPAREN comp_assoc RPAREN .)
    AMPERSAND       reduce using rule 187 (aggregate -> LPAREN comp_assoc RPAREN .)
    AND             reduce using rule 187 (aggregate -> LPAREN comp_assoc RPAREN .)
    OR              reduce using rule 187 (aggregate -> LPAREN comp_assoc RPAREN .)
    XOR             reduce using rule 187 (aggregate -> LPAREN comp_assoc RPAREN .)
    THEN            reduce using rule 187 (aggregate -> LPAREN comp_assoc RPAREN .)
    RPAREN          reduce using rule 187 (aggregate -> LPAREN comp_assoc RPAREN .)
    COMMA           reduce using rule 187 (aggregate -> LPAREN comp_assoc RPAREN .)
    DOUBLEDOT       reduce using rule 187 (aggregate -> LPAREN comp_assoc RPAREN .)
    WITH            reduce using rule 187 (aggregate -> LPAREN comp_assoc RPAREN .)
    ARROW           reduce using rule 187 (aggregate -> LPAREN comp_assoc RPAREN .)
    |               reduce using rule 187 (aggregate -> LPAREN comp_assoc RPAREN .)
    SEMICOLON       reduce using rule 187 (aggregate -> LPAREN comp_assoc RPAREN .)
    IS              reduce using rule 187 (aggregate -> LPAREN comp_assoc RPAREN .)
    LOOP            reduce using rule 187 (aggregate -> LPAREN comp_assoc RPAREN .)
    RANGE           reduce using rule 187 (aggregate -> LPAREN comp_assoc RPAREN .)
    DIGITS          reduce using rule 187 (aggregate -> LPAREN comp_assoc RPAREN .)
    RENAMES         reduce using rule 187 (aggregate -> LPAREN comp_assoc RPAREN .)
    IS_ASSIGNED     reduce using rule 187 (aggregate -> LPAREN comp_assoc RPAREN .)


state 369

    (193) value_s_2 -> value_s_2 COMMA . value
    (171) value -> . expression
    (172) value -> . comp_assoc
    (173) value -> . discrete_with_range
    (174) value -> . error
    (195) expression -> . relation
    (196) expression -> . expression logical relation
    (197) expression -> . expression short_circuit relation
    (194) comp_assoc -> . choice_s ARROW expression
    (126) discrete_with_range -> . name range_constraint
    (127) discrete_with_range -> . range
    (203) relation -> . simple_expression
    (204) relation -> . simple_expression relational simple_expression
    (205) relation -> . simple_expression membership range
    (206) relation -> . simple_expression membership name
    (121) choice_s -> . choice
    (122) choice_s -> . choice_s | choice
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (60) range -> . simple_expression DOUBLEDOT simple_expression
    (61) range -> . name TICK RANGE
    (62) range -> . name TICK RANGE LPAREN expression RPAREN
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (123) choice -> . expression
    (124) choice -> . discrete_with_range
    (125) choice -> . OTHERS
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN

    error           shift and go to state 233
    OTHERS          shift and go to state 222
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137
    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    relation                       shift and go to state 127
    simple_expression              shift and go to state 379
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    choice_s                       shift and go to state 225
    comp_assoc                     shift and go to state 380
    factor                         shift and go to state 136
    choice                         shift and go to state 227
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    discrete_with_range            shift and go to state 229
    term                           shift and go to state 144
    name                           shift and go to state 230
    operator_symbol                shift and go to state 146
    value                          shift and go to state 518
    range                          shift and go to state 232
    expression                     shift and go to state 382

state 370

    (188) aggregate -> LPAREN value_s_2 RPAREN .

    POW             reduce using rule 188 (aggregate -> LPAREN value_s_2 RPAREN .)
    TIMES           reduce using rule 188 (aggregate -> LPAREN value_s_2 RPAREN .)
    DIVIDE          reduce using rule 188 (aggregate -> LPAREN value_s_2 RPAREN .)
    MOD             reduce using rule 188 (aggregate -> LPAREN value_s_2 RPAREN .)
    REM             reduce using rule 188 (aggregate -> LPAREN value_s_2 RPAREN .)
    EQ              reduce using rule 188 (aggregate -> LPAREN value_s_2 RPAREN .)
    NE              reduce using rule 188 (aggregate -> LPAREN value_s_2 RPAREN .)
    LT              reduce using rule 188 (aggregate -> LPAREN value_s_2 RPAREN .)
    LE              reduce using rule 188 (aggregate -> LPAREN value_s_2 RPAREN .)
    GT              reduce using rule 188 (aggregate -> LPAREN value_s_2 RPAREN .)
    GE              reduce using rule 188 (aggregate -> LPAREN value_s_2 RPAREN .)
    IN              reduce using rule 188 (aggregate -> LPAREN value_s_2 RPAREN .)
    NOT             reduce using rule 188 (aggregate -> LPAREN value_s_2 RPAREN .)
    PLUS            reduce using rule 188 (aggregate -> LPAREN value_s_2 RPAREN .)
    MINUS           reduce using rule 188 (aggregate -> LPAREN value_s_2 RPAREN .)
    AMPERSAND       reduce using rule 188 (aggregate -> LPAREN value_s_2 RPAREN .)
    AND             reduce using rule 188 (aggregate -> LPAREN value_s_2 RPAREN .)
    OR              reduce using rule 188 (aggregate -> LPAREN value_s_2 RPAREN .)
    XOR             reduce using rule 188 (aggregate -> LPAREN value_s_2 RPAREN .)
    THEN            reduce using rule 188 (aggregate -> LPAREN value_s_2 RPAREN .)
    RPAREN          reduce using rule 188 (aggregate -> LPAREN value_s_2 RPAREN .)
    COMMA           reduce using rule 188 (aggregate -> LPAREN value_s_2 RPAREN .)
    DOUBLEDOT       reduce using rule 188 (aggregate -> LPAREN value_s_2 RPAREN .)
    WITH            reduce using rule 188 (aggregate -> LPAREN value_s_2 RPAREN .)
    ARROW           reduce using rule 188 (aggregate -> LPAREN value_s_2 RPAREN .)
    |               reduce using rule 188 (aggregate -> LPAREN value_s_2 RPAREN .)
    SEMICOLON       reduce using rule 188 (aggregate -> LPAREN value_s_2 RPAREN .)
    IS              reduce using rule 188 (aggregate -> LPAREN value_s_2 RPAREN .)
    LOOP            reduce using rule 188 (aggregate -> LPAREN value_s_2 RPAREN .)
    RANGE           reduce using rule 188 (aggregate -> LPAREN value_s_2 RPAREN .)
    DIGITS          reduce using rule 188 (aggregate -> LPAREN value_s_2 RPAREN .)
    RENAMES         reduce using rule 188 (aggregate -> LPAREN value_s_2 RPAREN .)
    IS_ASSIGNED     reduce using rule 188 (aggregate -> LPAREN value_s_2 RPAREN .)


state 371

    (59) range_constraint -> RANGE . range
    (60) range -> . simple_expression DOUBLEDOT simple_expression
    (61) range -> . name TICK RANGE
    (62) range -> . name TICK RANGE LPAREN expression RPAREN
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN

    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    simple_expression              shift and go to state 356
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    factor                         shift and go to state 136
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    term                           shift and go to state 144
    name                           shift and go to state 519
    operator_symbol                shift and go to state 146
    range                          shift and go to state 520

state 372

    (126) discrete_with_range -> name range_constraint .

    ARROW           reduce using rule 126 (discrete_with_range -> name range_constraint .)
    |               reduce using rule 126 (discrete_with_range -> name range_constraint .)
    RPAREN          reduce using rule 126 (discrete_with_range -> name range_constraint .)
    COMMA           reduce using rule 126 (discrete_with_range -> name range_constraint .)


state 373

    (61) range -> name TICK . RANGE
    (62) range -> name TICK . RANGE LPAREN expression RPAREN
    (179) attribute -> name TICK . attribute_id
    (240) qualified -> name TICK . parenthesized_primary
    (180) attribute_id -> . IDENTIFIER
    (181) attribute_id -> . DIGITS
    (182) attribute_id -> . DELTA
    (183) attribute_id -> . ACCESS
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN

    RANGE           shift and go to state 521
    IDENTIFIER      shift and go to state 384
    DIGITS          shift and go to state 383
    DELTA           shift and go to state 387
    ACCESS          shift and go to state 385
    LPAREN          shift and go to state 142

    attribute_id                   shift and go to state 386
    aggregate                      shift and go to state 126
    parenthesized_primary          shift and go to state 388

state 374

    (192) value_s_2 -> value COMMA . value
    (171) value -> . expression
    (172) value -> . comp_assoc
    (173) value -> . discrete_with_range
    (174) value -> . error
    (195) expression -> . relation
    (196) expression -> . expression logical relation
    (197) expression -> . expression short_circuit relation
    (194) comp_assoc -> . choice_s ARROW expression
    (126) discrete_with_range -> . name range_constraint
    (127) discrete_with_range -> . range
    (203) relation -> . simple_expression
    (204) relation -> . simple_expression relational simple_expression
    (205) relation -> . simple_expression membership range
    (206) relation -> . simple_expression membership name
    (121) choice_s -> . choice
    (122) choice_s -> . choice_s | choice
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (60) range -> . simple_expression DOUBLEDOT simple_expression
    (61) range -> . name TICK RANGE
    (62) range -> . name TICK RANGE LPAREN expression RPAREN
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (123) choice -> . expression
    (124) choice -> . discrete_with_range
    (125) choice -> . OTHERS
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN

    error           shift and go to state 233
    OTHERS          shift and go to state 222
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137
    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    relation                       shift and go to state 127
    simple_expression              shift and go to state 379
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    choice_s                       shift and go to state 225
    comp_assoc                     shift and go to state 380
    factor                         shift and go to state 136
    choice                         shift and go to state 227
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    discrete_with_range            shift and go to state 229
    term                           shift and go to state 144
    name                           shift and go to state 230
    operator_symbol                shift and go to state 146
    value                          shift and go to state 522
    range                          shift and go to state 232
    expression                     shift and go to state 382

state 375

    (239) parenthesized_primary -> LPAREN expression RPAREN .

    POW             reduce using rule 239 (parenthesized_primary -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 239 (parenthesized_primary -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 239 (parenthesized_primary -> LPAREN expression RPAREN .)
    MOD             reduce using rule 239 (parenthesized_primary -> LPAREN expression RPAREN .)
    REM             reduce using rule 239 (parenthesized_primary -> LPAREN expression RPAREN .)
    EQ              reduce using rule 239 (parenthesized_primary -> LPAREN expression RPAREN .)
    NE              reduce using rule 239 (parenthesized_primary -> LPAREN expression RPAREN .)
    LT              reduce using rule 239 (parenthesized_primary -> LPAREN expression RPAREN .)
    LE              reduce using rule 239 (parenthesized_primary -> LPAREN expression RPAREN .)
    GT              reduce using rule 239 (parenthesized_primary -> LPAREN expression RPAREN .)
    GE              reduce using rule 239 (parenthesized_primary -> LPAREN expression RPAREN .)
    IN              reduce using rule 239 (parenthesized_primary -> LPAREN expression RPAREN .)
    NOT             reduce using rule 239 (parenthesized_primary -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 239 (parenthesized_primary -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 239 (parenthesized_primary -> LPAREN expression RPAREN .)
    AMPERSAND       reduce using rule 239 (parenthesized_primary -> LPAREN expression RPAREN .)
    IS              reduce using rule 239 (parenthesized_primary -> LPAREN expression RPAREN .)
    AND             reduce using rule 239 (parenthesized_primary -> LPAREN expression RPAREN .)
    OR              reduce using rule 239 (parenthesized_primary -> LPAREN expression RPAREN .)
    XOR             reduce using rule 239 (parenthesized_primary -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 239 (parenthesized_primary -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 239 (parenthesized_primary -> LPAREN expression RPAREN .)
    WITH            reduce using rule 239 (parenthesized_primary -> LPAREN expression RPAREN .)
    ARROW           reduce using rule 239 (parenthesized_primary -> LPAREN expression RPAREN .)
    |               reduce using rule 239 (parenthesized_primary -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 239 (parenthesized_primary -> LPAREN expression RPAREN .)
    THEN            reduce using rule 239 (parenthesized_primary -> LPAREN expression RPAREN .)
    LOOP            reduce using rule 239 (parenthesized_primary -> LPAREN expression RPAREN .)
    RANGE           reduce using rule 239 (parenthesized_primary -> LPAREN expression RPAREN .)
    DIGITS          reduce using rule 239 (parenthesized_primary -> LPAREN expression RPAREN .)
    RENAMES         reduce using rule 239 (parenthesized_primary -> LPAREN expression RPAREN .)
    IS_ASSIGNED     reduce using rule 239 (parenthesized_primary -> LPAREN expression RPAREN .)
    DOUBLEDOT       reduce using rule 239 (parenthesized_primary -> LPAREN expression RPAREN .)


state 376

    (189) aggregate -> LPAREN expression WITH . value_s RPAREN
    (190) aggregate -> LPAREN expression WITH . NULL RECORD RPAREN
    (169) value_s -> . value
    (170) value_s -> . value_s COMMA value
    (171) value -> . expression
    (172) value -> . comp_assoc
    (173) value -> . discrete_with_range
    (174) value -> . error
    (195) expression -> . relation
    (196) expression -> . expression logical relation
    (197) expression -> . expression short_circuit relation
    (194) comp_assoc -> . choice_s ARROW expression
    (126) discrete_with_range -> . name range_constraint
    (127) discrete_with_range -> . range
    (203) relation -> . simple_expression
    (204) relation -> . simple_expression relational simple_expression
    (205) relation -> . simple_expression membership range
    (206) relation -> . simple_expression membership name
    (121) choice_s -> . choice
    (122) choice_s -> . choice_s | choice
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (60) range -> . simple_expression DOUBLEDOT simple_expression
    (61) range -> . name TICK RANGE
    (62) range -> . name TICK RANGE LPAREN expression RPAREN
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (123) choice -> . expression
    (124) choice -> . discrete_with_range
    (125) choice -> . OTHERS
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN

    NULL            shift and go to state 523
    error           shift and go to state 233
    OTHERS          shift and go to state 222
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137
    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    relation                       shift and go to state 127
    value_s                        shift and go to state 524
    simple_expression              shift and go to state 379
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    choice_s                       shift and go to state 225
    comp_assoc                     shift and go to state 380
    factor                         shift and go to state 136
    choice                         shift and go to state 227
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    discrete_with_range            shift and go to state 229
    term                           shift and go to state 144
    name                           shift and go to state 230
    operator_symbol                shift and go to state 146
    value                          shift and go to state 378
    range                          shift and go to state 232
    expression                     shift and go to state 382

state 377

    (224) term -> term multiplying factor .

    TIMES           reduce using rule 224 (term -> term multiplying factor .)
    DIVIDE          reduce using rule 224 (term -> term multiplying factor .)
    MOD             reduce using rule 224 (term -> term multiplying factor .)
    REM             reduce using rule 224 (term -> term multiplying factor .)
    EQ              reduce using rule 224 (term -> term multiplying factor .)
    NE              reduce using rule 224 (term -> term multiplying factor .)
    LT              reduce using rule 224 (term -> term multiplying factor .)
    LE              reduce using rule 224 (term -> term multiplying factor .)
    GT              reduce using rule 224 (term -> term multiplying factor .)
    GE              reduce using rule 224 (term -> term multiplying factor .)
    IN              reduce using rule 224 (term -> term multiplying factor .)
    NOT             reduce using rule 224 (term -> term multiplying factor .)
    PLUS            reduce using rule 224 (term -> term multiplying factor .)
    MINUS           reduce using rule 224 (term -> term multiplying factor .)
    AMPERSAND       reduce using rule 224 (term -> term multiplying factor .)
    AND             reduce using rule 224 (term -> term multiplying factor .)
    OR              reduce using rule 224 (term -> term multiplying factor .)
    XOR             reduce using rule 224 (term -> term multiplying factor .)
    RANGE           reduce using rule 224 (term -> term multiplying factor .)
    SEMICOLON       reduce using rule 224 (term -> term multiplying factor .)
    DOUBLEDOT       reduce using rule 224 (term -> term multiplying factor .)
    RPAREN          reduce using rule 224 (term -> term multiplying factor .)
    COMMA           reduce using rule 224 (term -> term multiplying factor .)
    ARROW           reduce using rule 224 (term -> term multiplying factor .)
    |               reduce using rule 224 (term -> term multiplying factor .)
    THEN            reduce using rule 224 (term -> term multiplying factor .)
    IS              reduce using rule 224 (term -> term multiplying factor .)
    WITH            reduce using rule 224 (term -> term multiplying factor .)
    LOOP            reduce using rule 224 (term -> term multiplying factor .)
    DIGITS          reduce using rule 224 (term -> term multiplying factor .)
    RENAMES         reduce using rule 224 (term -> term multiplying factor .)
    IS_ASSIGNED     reduce using rule 224 (term -> term multiplying factor .)


state 378

    (169) value_s -> value .

    RPAREN          reduce using rule 169 (value_s -> value .)
    COMMA           reduce using rule 169 (value_s -> value .)


state 379

    (203) relation -> simple_expression .
    (204) relation -> simple_expression . relational simple_expression
    (205) relation -> simple_expression . membership range
    (206) relation -> simple_expression . membership name
    (60) range -> simple_expression . DOUBLEDOT simple_expression
    (217) simple_expression -> simple_expression . adding term
    (207) relational -> . EQ
    (208) relational -> . NE
    (209) relational -> . LT
    (210) relational -> . LE
    (211) relational -> . GT
    (212) relational -> . GE
    (213) membership -> . IN
    (214) membership -> . NOT IN
    (220) adding -> . PLUS
    (221) adding -> . MINUS
    (222) adding -> . AMPERSAND

    AND             reduce using rule 203 (relation -> simple_expression .)
    OR              reduce using rule 203 (relation -> simple_expression .)
    XOR             reduce using rule 203 (relation -> simple_expression .)
    RPAREN          reduce using rule 203 (relation -> simple_expression .)
    COMMA           reduce using rule 203 (relation -> simple_expression .)
    ARROW           reduce using rule 203 (relation -> simple_expression .)
    |               reduce using rule 203 (relation -> simple_expression .)
    DOUBLEDOT       shift and go to state 364
    EQ              shift and go to state 216
    NE              shift and go to state 210
    LT              shift and go to state 208
    LE              shift and go to state 205
    GT              shift and go to state 211
    GE              shift and go to state 206
    IN              shift and go to state 213
    NOT             shift and go to state 214
    PLUS            shift and go to state 212
    MINUS           shift and go to state 217
    AMPERSAND       shift and go to state 207

    adding                         shift and go to state 204
    membership                     shift and go to state 209
    relational                     shift and go to state 215

state 380

    (172) value -> comp_assoc .

    RPAREN          reduce using rule 172 (value -> comp_assoc .)
    COMMA           reduce using rule 172 (value -> comp_assoc .)


state 381

    (168) indexed_comp -> name LPAREN value_s . RPAREN
    (170) value_s -> value_s . COMMA value

    RPAREN          shift and go to state 525
    COMMA           shift and go to state 526


state 382

    (171) value -> expression .
    (196) expression -> expression . logical relation
    (197) expression -> expression . short_circuit relation
    (123) choice -> expression .
    (198) logical -> . AND
    (199) logical -> . OR
    (200) logical -> . XOR
    (201) short_circuit -> . AND THEN
    (202) short_circuit -> . OR ELSE

    RPAREN          reduce using rule 171 (value -> expression .)
    COMMA           reduce using rule 171 (value -> expression .)
    ARROW           reduce using rule 123 (choice -> expression .)
    |               reduce using rule 123 (choice -> expression .)
    AND             shift and go to state 244
    OR              shift and go to state 248
    XOR             shift and go to state 245

    logical                        shift and go to state 246
    short_circuit                  shift and go to state 247

state 383

    (181) attribute_id -> DIGITS .

    TICK            reduce using rule 181 (attribute_id -> DIGITS .)
    LPAREN          reduce using rule 181 (attribute_id -> DIGITS .)
    DOT             reduce using rule 181 (attribute_id -> DIGITS .)
    POW             reduce using rule 181 (attribute_id -> DIGITS .)
    TIMES           reduce using rule 181 (attribute_id -> DIGITS .)
    DIVIDE          reduce using rule 181 (attribute_id -> DIGITS .)
    MOD             reduce using rule 181 (attribute_id -> DIGITS .)
    REM             reduce using rule 181 (attribute_id -> DIGITS .)
    EQ              reduce using rule 181 (attribute_id -> DIGITS .)
    NE              reduce using rule 181 (attribute_id -> DIGITS .)
    LT              reduce using rule 181 (attribute_id -> DIGITS .)
    LE              reduce using rule 181 (attribute_id -> DIGITS .)
    GT              reduce using rule 181 (attribute_id -> DIGITS .)
    GE              reduce using rule 181 (attribute_id -> DIGITS .)
    IN              reduce using rule 181 (attribute_id -> DIGITS .)
    NOT             reduce using rule 181 (attribute_id -> DIGITS .)
    PLUS            reduce using rule 181 (attribute_id -> DIGITS .)
    MINUS           reduce using rule 181 (attribute_id -> DIGITS .)
    AMPERSAND       reduce using rule 181 (attribute_id -> DIGITS .)
    AND             reduce using rule 181 (attribute_id -> DIGITS .)
    OR              reduce using rule 181 (attribute_id -> DIGITS .)
    XOR             reduce using rule 181 (attribute_id -> DIGITS .)
    RPAREN          reduce using rule 181 (attribute_id -> DIGITS .)
    COMMA           reduce using rule 181 (attribute_id -> DIGITS .)
    DOUBLEDOT       reduce using rule 181 (attribute_id -> DIGITS .)
    WITH            reduce using rule 181 (attribute_id -> DIGITS .)
    ARROW           reduce using rule 181 (attribute_id -> DIGITS .)
    |               reduce using rule 181 (attribute_id -> DIGITS .)
    SEMICOLON       reduce using rule 181 (attribute_id -> DIGITS .)
    IS              reduce using rule 181 (attribute_id -> DIGITS .)
    THEN            reduce using rule 181 (attribute_id -> DIGITS .)
    LOOP            reduce using rule 181 (attribute_id -> DIGITS .)
    RANGE           reduce using rule 181 (attribute_id -> DIGITS .)
    DIGITS          reduce using rule 181 (attribute_id -> DIGITS .)
    RENAMES         reduce using rule 181 (attribute_id -> DIGITS .)
    IS_ASSIGNED     reduce using rule 181 (attribute_id -> DIGITS .)
    USE             reduce using rule 181 (attribute_id -> DIGITS .)
    AT              reduce using rule 181 (attribute_id -> DIGITS .)
    WHEN            reduce using rule 181 (attribute_id -> DIGITS .)


state 384

    (180) attribute_id -> IDENTIFIER .

    TICK            reduce using rule 180 (attribute_id -> IDENTIFIER .)
    LPAREN          reduce using rule 180 (attribute_id -> IDENTIFIER .)
    DOT             reduce using rule 180 (attribute_id -> IDENTIFIER .)
    POW             reduce using rule 180 (attribute_id -> IDENTIFIER .)
    TIMES           reduce using rule 180 (attribute_id -> IDENTIFIER .)
    DIVIDE          reduce using rule 180 (attribute_id -> IDENTIFIER .)
    MOD             reduce using rule 180 (attribute_id -> IDENTIFIER .)
    REM             reduce using rule 180 (attribute_id -> IDENTIFIER .)
    EQ              reduce using rule 180 (attribute_id -> IDENTIFIER .)
    NE              reduce using rule 180 (attribute_id -> IDENTIFIER .)
    LT              reduce using rule 180 (attribute_id -> IDENTIFIER .)
    LE              reduce using rule 180 (attribute_id -> IDENTIFIER .)
    GT              reduce using rule 180 (attribute_id -> IDENTIFIER .)
    GE              reduce using rule 180 (attribute_id -> IDENTIFIER .)
    IN              reduce using rule 180 (attribute_id -> IDENTIFIER .)
    NOT             reduce using rule 180 (attribute_id -> IDENTIFIER .)
    PLUS            reduce using rule 180 (attribute_id -> IDENTIFIER .)
    MINUS           reduce using rule 180 (attribute_id -> IDENTIFIER .)
    AMPERSAND       reduce using rule 180 (attribute_id -> IDENTIFIER .)
    AND             reduce using rule 180 (attribute_id -> IDENTIFIER .)
    OR              reduce using rule 180 (attribute_id -> IDENTIFIER .)
    XOR             reduce using rule 180 (attribute_id -> IDENTIFIER .)
    RPAREN          reduce using rule 180 (attribute_id -> IDENTIFIER .)
    COMMA           reduce using rule 180 (attribute_id -> IDENTIFIER .)
    DOUBLEDOT       reduce using rule 180 (attribute_id -> IDENTIFIER .)
    WITH            reduce using rule 180 (attribute_id -> IDENTIFIER .)
    ARROW           reduce using rule 180 (attribute_id -> IDENTIFIER .)
    |               reduce using rule 180 (attribute_id -> IDENTIFIER .)
    SEMICOLON       reduce using rule 180 (attribute_id -> IDENTIFIER .)
    IS              reduce using rule 180 (attribute_id -> IDENTIFIER .)
    THEN            reduce using rule 180 (attribute_id -> IDENTIFIER .)
    LOOP            reduce using rule 180 (attribute_id -> IDENTIFIER .)
    RANGE           reduce using rule 180 (attribute_id -> IDENTIFIER .)
    DIGITS          reduce using rule 180 (attribute_id -> IDENTIFIER .)
    RENAMES         reduce using rule 180 (attribute_id -> IDENTIFIER .)
    IS_ASSIGNED     reduce using rule 180 (attribute_id -> IDENTIFIER .)
    USE             reduce using rule 180 (attribute_id -> IDENTIFIER .)
    AT              reduce using rule 180 (attribute_id -> IDENTIFIER .)
    WHEN            reduce using rule 180 (attribute_id -> IDENTIFIER .)


state 385

    (183) attribute_id -> ACCESS .

    TICK            reduce using rule 183 (attribute_id -> ACCESS .)
    LPAREN          reduce using rule 183 (attribute_id -> ACCESS .)
    DOT             reduce using rule 183 (attribute_id -> ACCESS .)
    POW             reduce using rule 183 (attribute_id -> ACCESS .)
    TIMES           reduce using rule 183 (attribute_id -> ACCESS .)
    DIVIDE          reduce using rule 183 (attribute_id -> ACCESS .)
    MOD             reduce using rule 183 (attribute_id -> ACCESS .)
    REM             reduce using rule 183 (attribute_id -> ACCESS .)
    EQ              reduce using rule 183 (attribute_id -> ACCESS .)
    NE              reduce using rule 183 (attribute_id -> ACCESS .)
    LT              reduce using rule 183 (attribute_id -> ACCESS .)
    LE              reduce using rule 183 (attribute_id -> ACCESS .)
    GT              reduce using rule 183 (attribute_id -> ACCESS .)
    GE              reduce using rule 183 (attribute_id -> ACCESS .)
    IN              reduce using rule 183 (attribute_id -> ACCESS .)
    NOT             reduce using rule 183 (attribute_id -> ACCESS .)
    PLUS            reduce using rule 183 (attribute_id -> ACCESS .)
    MINUS           reduce using rule 183 (attribute_id -> ACCESS .)
    AMPERSAND       reduce using rule 183 (attribute_id -> ACCESS .)
    AND             reduce using rule 183 (attribute_id -> ACCESS .)
    OR              reduce using rule 183 (attribute_id -> ACCESS .)
    XOR             reduce using rule 183 (attribute_id -> ACCESS .)
    RPAREN          reduce using rule 183 (attribute_id -> ACCESS .)
    COMMA           reduce using rule 183 (attribute_id -> ACCESS .)
    DOUBLEDOT       reduce using rule 183 (attribute_id -> ACCESS .)
    WITH            reduce using rule 183 (attribute_id -> ACCESS .)
    ARROW           reduce using rule 183 (attribute_id -> ACCESS .)
    |               reduce using rule 183 (attribute_id -> ACCESS .)
    SEMICOLON       reduce using rule 183 (attribute_id -> ACCESS .)
    IS              reduce using rule 183 (attribute_id -> ACCESS .)
    THEN            reduce using rule 183 (attribute_id -> ACCESS .)
    LOOP            reduce using rule 183 (attribute_id -> ACCESS .)
    RANGE           reduce using rule 183 (attribute_id -> ACCESS .)
    DIGITS          reduce using rule 183 (attribute_id -> ACCESS .)
    RENAMES         reduce using rule 183 (attribute_id -> ACCESS .)
    IS_ASSIGNED     reduce using rule 183 (attribute_id -> ACCESS .)
    USE             reduce using rule 183 (attribute_id -> ACCESS .)
    AT              reduce using rule 183 (attribute_id -> ACCESS .)
    WHEN            reduce using rule 183 (attribute_id -> ACCESS .)


state 386

    (179) attribute -> name TICK attribute_id .

    TICK            reduce using rule 179 (attribute -> name TICK attribute_id .)
    LPAREN          reduce using rule 179 (attribute -> name TICK attribute_id .)
    DOT             reduce using rule 179 (attribute -> name TICK attribute_id .)
    RANGE           reduce using rule 179 (attribute -> name TICK attribute_id .)
    LOOP            reduce using rule 179 (attribute -> name TICK attribute_id .)
    POW             reduce using rule 179 (attribute -> name TICK attribute_id .)
    TIMES           reduce using rule 179 (attribute -> name TICK attribute_id .)
    DIVIDE          reduce using rule 179 (attribute -> name TICK attribute_id .)
    MOD             reduce using rule 179 (attribute -> name TICK attribute_id .)
    REM             reduce using rule 179 (attribute -> name TICK attribute_id .)
    DOUBLEDOT       reduce using rule 179 (attribute -> name TICK attribute_id .)
    PLUS            reduce using rule 179 (attribute -> name TICK attribute_id .)
    MINUS           reduce using rule 179 (attribute -> name TICK attribute_id .)
    AMPERSAND       reduce using rule 179 (attribute -> name TICK attribute_id .)
    IS_ASSIGNED     reduce using rule 179 (attribute -> name TICK attribute_id .)
    SEMICOLON       reduce using rule 179 (attribute -> name TICK attribute_id .)
    EQ              reduce using rule 179 (attribute -> name TICK attribute_id .)
    NE              reduce using rule 179 (attribute -> name TICK attribute_id .)
    LT              reduce using rule 179 (attribute -> name TICK attribute_id .)
    LE              reduce using rule 179 (attribute -> name TICK attribute_id .)
    GT              reduce using rule 179 (attribute -> name TICK attribute_id .)
    GE              reduce using rule 179 (attribute -> name TICK attribute_id .)
    IN              reduce using rule 179 (attribute -> name TICK attribute_id .)
    NOT             reduce using rule 179 (attribute -> name TICK attribute_id .)
    AND             reduce using rule 179 (attribute -> name TICK attribute_id .)
    OR              reduce using rule 179 (attribute -> name TICK attribute_id .)
    XOR             reduce using rule 179 (attribute -> name TICK attribute_id .)
    RPAREN          reduce using rule 179 (attribute -> name TICK attribute_id .)
    COMMA           reduce using rule 179 (attribute -> name TICK attribute_id .)
    RENAMES         reduce using rule 179 (attribute -> name TICK attribute_id .)
    WITH            reduce using rule 179 (attribute -> name TICK attribute_id .)
    ARROW           reduce using rule 179 (attribute -> name TICK attribute_id .)
    |               reduce using rule 179 (attribute -> name TICK attribute_id .)
    IS              reduce using rule 179 (attribute -> name TICK attribute_id .)
    THEN            reduce using rule 179 (attribute -> name TICK attribute_id .)
    DIGITS          reduce using rule 179 (attribute -> name TICK attribute_id .)
    WHEN            reduce using rule 179 (attribute -> name TICK attribute_id .)


state 387

    (182) attribute_id -> DELTA .

    TICK            reduce using rule 182 (attribute_id -> DELTA .)
    LPAREN          reduce using rule 182 (attribute_id -> DELTA .)
    DOT             reduce using rule 182 (attribute_id -> DELTA .)
    POW             reduce using rule 182 (attribute_id -> DELTA .)
    TIMES           reduce using rule 182 (attribute_id -> DELTA .)
    DIVIDE          reduce using rule 182 (attribute_id -> DELTA .)
    MOD             reduce using rule 182 (attribute_id -> DELTA .)
    REM             reduce using rule 182 (attribute_id -> DELTA .)
    EQ              reduce using rule 182 (attribute_id -> DELTA .)
    NE              reduce using rule 182 (attribute_id -> DELTA .)
    LT              reduce using rule 182 (attribute_id -> DELTA .)
    LE              reduce using rule 182 (attribute_id -> DELTA .)
    GT              reduce using rule 182 (attribute_id -> DELTA .)
    GE              reduce using rule 182 (attribute_id -> DELTA .)
    IN              reduce using rule 182 (attribute_id -> DELTA .)
    NOT             reduce using rule 182 (attribute_id -> DELTA .)
    PLUS            reduce using rule 182 (attribute_id -> DELTA .)
    MINUS           reduce using rule 182 (attribute_id -> DELTA .)
    AMPERSAND       reduce using rule 182 (attribute_id -> DELTA .)
    AND             reduce using rule 182 (attribute_id -> DELTA .)
    OR              reduce using rule 182 (attribute_id -> DELTA .)
    XOR             reduce using rule 182 (attribute_id -> DELTA .)
    RPAREN          reduce using rule 182 (attribute_id -> DELTA .)
    COMMA           reduce using rule 182 (attribute_id -> DELTA .)
    DOUBLEDOT       reduce using rule 182 (attribute_id -> DELTA .)
    WITH            reduce using rule 182 (attribute_id -> DELTA .)
    ARROW           reduce using rule 182 (attribute_id -> DELTA .)
    |               reduce using rule 182 (attribute_id -> DELTA .)
    SEMICOLON       reduce using rule 182 (attribute_id -> DELTA .)
    IS              reduce using rule 182 (attribute_id -> DELTA .)
    THEN            reduce using rule 182 (attribute_id -> DELTA .)
    LOOP            reduce using rule 182 (attribute_id -> DELTA .)
    RANGE           reduce using rule 182 (attribute_id -> DELTA .)
    DIGITS          reduce using rule 182 (attribute_id -> DELTA .)
    RENAMES         reduce using rule 182 (attribute_id -> DELTA .)
    IS_ASSIGNED     reduce using rule 182 (attribute_id -> DELTA .)
    USE             reduce using rule 182 (attribute_id -> DELTA .)
    AT              reduce using rule 182 (attribute_id -> DELTA .)
    WHEN            reduce using rule 182 (attribute_id -> DELTA .)


state 388

    (240) qualified -> name TICK parenthesized_primary .

    SEMICOLON       reduce using rule 240 (qualified -> name TICK parenthesized_primary .)
    POW             reduce using rule 240 (qualified -> name TICK parenthesized_primary .)
    TIMES           reduce using rule 240 (qualified -> name TICK parenthesized_primary .)
    DIVIDE          reduce using rule 240 (qualified -> name TICK parenthesized_primary .)
    MOD             reduce using rule 240 (qualified -> name TICK parenthesized_primary .)
    REM             reduce using rule 240 (qualified -> name TICK parenthesized_primary .)
    EQ              reduce using rule 240 (qualified -> name TICK parenthesized_primary .)
    NE              reduce using rule 240 (qualified -> name TICK parenthesized_primary .)
    LT              reduce using rule 240 (qualified -> name TICK parenthesized_primary .)
    LE              reduce using rule 240 (qualified -> name TICK parenthesized_primary .)
    GT              reduce using rule 240 (qualified -> name TICK parenthesized_primary .)
    GE              reduce using rule 240 (qualified -> name TICK parenthesized_primary .)
    IN              reduce using rule 240 (qualified -> name TICK parenthesized_primary .)
    NOT             reduce using rule 240 (qualified -> name TICK parenthesized_primary .)
    PLUS            reduce using rule 240 (qualified -> name TICK parenthesized_primary .)
    MINUS           reduce using rule 240 (qualified -> name TICK parenthesized_primary .)
    AMPERSAND       reduce using rule 240 (qualified -> name TICK parenthesized_primary .)
    AND             reduce using rule 240 (qualified -> name TICK parenthesized_primary .)
    OR              reduce using rule 240 (qualified -> name TICK parenthesized_primary .)
    XOR             reduce using rule 240 (qualified -> name TICK parenthesized_primary .)
    RPAREN          reduce using rule 240 (qualified -> name TICK parenthesized_primary .)
    COMMA           reduce using rule 240 (qualified -> name TICK parenthesized_primary .)
    WITH            reduce using rule 240 (qualified -> name TICK parenthesized_primary .)
    ARROW           reduce using rule 240 (qualified -> name TICK parenthesized_primary .)
    |               reduce using rule 240 (qualified -> name TICK parenthesized_primary .)
    IS              reduce using rule 240 (qualified -> name TICK parenthesized_primary .)
    THEN            reduce using rule 240 (qualified -> name TICK parenthesized_primary .)
    LOOP            reduce using rule 240 (qualified -> name TICK parenthesized_primary .)
    RANGE           reduce using rule 240 (qualified -> name TICK parenthesized_primary .)
    DIGITS          reduce using rule 240 (qualified -> name TICK parenthesized_primary .)
    RENAMES         reduce using rule 240 (qualified -> name TICK parenthesized_primary .)
    IS_ASSIGNED     reduce using rule 240 (qualified -> name TICK parenthesized_primary .)
    DOUBLEDOT       reduce using rule 240 (qualified -> name TICK parenthesized_primary .)


state 389

    (178) selected_comp -> name DOT ALL .

    TICK            reduce using rule 178 (selected_comp -> name DOT ALL .)
    LPAREN          reduce using rule 178 (selected_comp -> name DOT ALL .)
    DOT             reduce using rule 178 (selected_comp -> name DOT ALL .)
    TIMES           reduce using rule 178 (selected_comp -> name DOT ALL .)
    DIVIDE          reduce using rule 178 (selected_comp -> name DOT ALL .)
    MOD             reduce using rule 178 (selected_comp -> name DOT ALL .)
    REM             reduce using rule 178 (selected_comp -> name DOT ALL .)
    EQ              reduce using rule 178 (selected_comp -> name DOT ALL .)
    NE              reduce using rule 178 (selected_comp -> name DOT ALL .)
    LT              reduce using rule 178 (selected_comp -> name DOT ALL .)
    LE              reduce using rule 178 (selected_comp -> name DOT ALL .)
    GT              reduce using rule 178 (selected_comp -> name DOT ALL .)
    GE              reduce using rule 178 (selected_comp -> name DOT ALL .)
    IN              reduce using rule 178 (selected_comp -> name DOT ALL .)
    NOT             reduce using rule 178 (selected_comp -> name DOT ALL .)
    PLUS            reduce using rule 178 (selected_comp -> name DOT ALL .)
    MINUS           reduce using rule 178 (selected_comp -> name DOT ALL .)
    AMPERSAND       reduce using rule 178 (selected_comp -> name DOT ALL .)
    AND             reduce using rule 178 (selected_comp -> name DOT ALL .)
    OR              reduce using rule 178 (selected_comp -> name DOT ALL .)
    XOR             reduce using rule 178 (selected_comp -> name DOT ALL .)
    RPAREN          reduce using rule 178 (selected_comp -> name DOT ALL .)
    COMMA           reduce using rule 178 (selected_comp -> name DOT ALL .)
    DOUBLEDOT       reduce using rule 178 (selected_comp -> name DOT ALL .)
    WITH            reduce using rule 178 (selected_comp -> name DOT ALL .)
    ARROW           reduce using rule 178 (selected_comp -> name DOT ALL .)
    |               reduce using rule 178 (selected_comp -> name DOT ALL .)
    SEMICOLON       reduce using rule 178 (selected_comp -> name DOT ALL .)
    IS              reduce using rule 178 (selected_comp -> name DOT ALL .)
    THEN            reduce using rule 178 (selected_comp -> name DOT ALL .)
    LOOP            reduce using rule 178 (selected_comp -> name DOT ALL .)
    RANGE           reduce using rule 178 (selected_comp -> name DOT ALL .)
    DIGITS          reduce using rule 178 (selected_comp -> name DOT ALL .)
    RENAMES         reduce using rule 178 (selected_comp -> name DOT ALL .)
    IS_ASSIGNED     reduce using rule 178 (selected_comp -> name DOT ALL .)
    POW             reduce using rule 178 (selected_comp -> name DOT ALL .)
    WHEN            reduce using rule 178 (selected_comp -> name DOT ALL .)


state 390

    (177) selected_comp -> name DOT operator_symbol .

    TICK            reduce using rule 177 (selected_comp -> name DOT operator_symbol .)
    LPAREN          reduce using rule 177 (selected_comp -> name DOT operator_symbol .)
    DOT             reduce using rule 177 (selected_comp -> name DOT operator_symbol .)
    TIMES           reduce using rule 177 (selected_comp -> name DOT operator_symbol .)
    DIVIDE          reduce using rule 177 (selected_comp -> name DOT operator_symbol .)
    MOD             reduce using rule 177 (selected_comp -> name DOT operator_symbol .)
    REM             reduce using rule 177 (selected_comp -> name DOT operator_symbol .)
    EQ              reduce using rule 177 (selected_comp -> name DOT operator_symbol .)
    NE              reduce using rule 177 (selected_comp -> name DOT operator_symbol .)
    LT              reduce using rule 177 (selected_comp -> name DOT operator_symbol .)
    LE              reduce using rule 177 (selected_comp -> name DOT operator_symbol .)
    GT              reduce using rule 177 (selected_comp -> name DOT operator_symbol .)
    GE              reduce using rule 177 (selected_comp -> name DOT operator_symbol .)
    IN              reduce using rule 177 (selected_comp -> name DOT operator_symbol .)
    NOT             reduce using rule 177 (selected_comp -> name DOT operator_symbol .)
    PLUS            reduce using rule 177 (selected_comp -> name DOT operator_symbol .)
    MINUS           reduce using rule 177 (selected_comp -> name DOT operator_symbol .)
    AMPERSAND       reduce using rule 177 (selected_comp -> name DOT operator_symbol .)
    AND             reduce using rule 177 (selected_comp -> name DOT operator_symbol .)
    OR              reduce using rule 177 (selected_comp -> name DOT operator_symbol .)
    XOR             reduce using rule 177 (selected_comp -> name DOT operator_symbol .)
    RPAREN          reduce using rule 177 (selected_comp -> name DOT operator_symbol .)
    COMMA           reduce using rule 177 (selected_comp -> name DOT operator_symbol .)
    DOUBLEDOT       reduce using rule 177 (selected_comp -> name DOT operator_symbol .)
    WITH            reduce using rule 177 (selected_comp -> name DOT operator_symbol .)
    ARROW           reduce using rule 177 (selected_comp -> name DOT operator_symbol .)
    |               reduce using rule 177 (selected_comp -> name DOT operator_symbol .)
    SEMICOLON       reduce using rule 177 (selected_comp -> name DOT operator_symbol .)
    IS              reduce using rule 177 (selected_comp -> name DOT operator_symbol .)
    THEN            reduce using rule 177 (selected_comp -> name DOT operator_symbol .)
    LOOP            reduce using rule 177 (selected_comp -> name DOT operator_symbol .)
    RANGE           reduce using rule 177 (selected_comp -> name DOT operator_symbol .)
    DIGITS          reduce using rule 177 (selected_comp -> name DOT operator_symbol .)
    RENAMES         reduce using rule 177 (selected_comp -> name DOT operator_symbol .)
    IS_ASSIGNED     reduce using rule 177 (selected_comp -> name DOT operator_symbol .)
    POW             reduce using rule 177 (selected_comp -> name DOT operator_symbol .)
    WHEN            reduce using rule 177 (selected_comp -> name DOT operator_symbol .)


state 391

    (176) selected_comp -> name DOT used_char .

    TICK            reduce using rule 176 (selected_comp -> name DOT used_char .)
    LPAREN          reduce using rule 176 (selected_comp -> name DOT used_char .)
    DOT             reduce using rule 176 (selected_comp -> name DOT used_char .)
    TIMES           reduce using rule 176 (selected_comp -> name DOT used_char .)
    DIVIDE          reduce using rule 176 (selected_comp -> name DOT used_char .)
    MOD             reduce using rule 176 (selected_comp -> name DOT used_char .)
    REM             reduce using rule 176 (selected_comp -> name DOT used_char .)
    EQ              reduce using rule 176 (selected_comp -> name DOT used_char .)
    NE              reduce using rule 176 (selected_comp -> name DOT used_char .)
    LT              reduce using rule 176 (selected_comp -> name DOT used_char .)
    LE              reduce using rule 176 (selected_comp -> name DOT used_char .)
    GT              reduce using rule 176 (selected_comp -> name DOT used_char .)
    GE              reduce using rule 176 (selected_comp -> name DOT used_char .)
    IN              reduce using rule 176 (selected_comp -> name DOT used_char .)
    NOT             reduce using rule 176 (selected_comp -> name DOT used_char .)
    PLUS            reduce using rule 176 (selected_comp -> name DOT used_char .)
    MINUS           reduce using rule 176 (selected_comp -> name DOT used_char .)
    AMPERSAND       reduce using rule 176 (selected_comp -> name DOT used_char .)
    AND             reduce using rule 176 (selected_comp -> name DOT used_char .)
    OR              reduce using rule 176 (selected_comp -> name DOT used_char .)
    XOR             reduce using rule 176 (selected_comp -> name DOT used_char .)
    RPAREN          reduce using rule 176 (selected_comp -> name DOT used_char .)
    COMMA           reduce using rule 176 (selected_comp -> name DOT used_char .)
    DOUBLEDOT       reduce using rule 176 (selected_comp -> name DOT used_char .)
    WITH            reduce using rule 176 (selected_comp -> name DOT used_char .)
    ARROW           reduce using rule 176 (selected_comp -> name DOT used_char .)
    |               reduce using rule 176 (selected_comp -> name DOT used_char .)
    SEMICOLON       reduce using rule 176 (selected_comp -> name DOT used_char .)
    IS              reduce using rule 176 (selected_comp -> name DOT used_char .)
    THEN            reduce using rule 176 (selected_comp -> name DOT used_char .)
    LOOP            reduce using rule 176 (selected_comp -> name DOT used_char .)
    RANGE           reduce using rule 176 (selected_comp -> name DOT used_char .)
    DIGITS          reduce using rule 176 (selected_comp -> name DOT used_char .)
    RENAMES         reduce using rule 176 (selected_comp -> name DOT used_char .)
    IS_ASSIGNED     reduce using rule 176 (selected_comp -> name DOT used_char .)
    POW             reduce using rule 176 (selected_comp -> name DOT used_char .)
    WHEN            reduce using rule 176 (selected_comp -> name DOT used_char .)


state 392

    (175) selected_comp -> name DOT simple_name .

    TICK            reduce using rule 175 (selected_comp -> name DOT simple_name .)
    LPAREN          reduce using rule 175 (selected_comp -> name DOT simple_name .)
    DOT             reduce using rule 175 (selected_comp -> name DOT simple_name .)
    TIMES           reduce using rule 175 (selected_comp -> name DOT simple_name .)
    DIVIDE          reduce using rule 175 (selected_comp -> name DOT simple_name .)
    MOD             reduce using rule 175 (selected_comp -> name DOT simple_name .)
    REM             reduce using rule 175 (selected_comp -> name DOT simple_name .)
    EQ              reduce using rule 175 (selected_comp -> name DOT simple_name .)
    NE              reduce using rule 175 (selected_comp -> name DOT simple_name .)
    LT              reduce using rule 175 (selected_comp -> name DOT simple_name .)
    LE              reduce using rule 175 (selected_comp -> name DOT simple_name .)
    GT              reduce using rule 175 (selected_comp -> name DOT simple_name .)
    GE              reduce using rule 175 (selected_comp -> name DOT simple_name .)
    IN              reduce using rule 175 (selected_comp -> name DOT simple_name .)
    NOT             reduce using rule 175 (selected_comp -> name DOT simple_name .)
    PLUS            reduce using rule 175 (selected_comp -> name DOT simple_name .)
    MINUS           reduce using rule 175 (selected_comp -> name DOT simple_name .)
    AMPERSAND       reduce using rule 175 (selected_comp -> name DOT simple_name .)
    AND             reduce using rule 175 (selected_comp -> name DOT simple_name .)
    OR              reduce using rule 175 (selected_comp -> name DOT simple_name .)
    XOR             reduce using rule 175 (selected_comp -> name DOT simple_name .)
    RPAREN          reduce using rule 175 (selected_comp -> name DOT simple_name .)
    COMMA           reduce using rule 175 (selected_comp -> name DOT simple_name .)
    DOUBLEDOT       reduce using rule 175 (selected_comp -> name DOT simple_name .)
    WITH            reduce using rule 175 (selected_comp -> name DOT simple_name .)
    ARROW           reduce using rule 175 (selected_comp -> name DOT simple_name .)
    |               reduce using rule 175 (selected_comp -> name DOT simple_name .)
    SEMICOLON       reduce using rule 175 (selected_comp -> name DOT simple_name .)
    IS              reduce using rule 175 (selected_comp -> name DOT simple_name .)
    THEN            reduce using rule 175 (selected_comp -> name DOT simple_name .)
    LOOP            reduce using rule 175 (selected_comp -> name DOT simple_name .)
    RANGE           reduce using rule 175 (selected_comp -> name DOT simple_name .)
    DIGITS          reduce using rule 175 (selected_comp -> name DOT simple_name .)
    RENAMES         reduce using rule 175 (selected_comp -> name DOT simple_name .)
    IS_ASSIGNED     reduce using rule 175 (selected_comp -> name DOT simple_name .)
    POW             reduce using rule 175 (selected_comp -> name DOT simple_name .)
    WHEN            reduce using rule 175 (selected_comp -> name DOT simple_name .)


state 393

    (201) short_circuit -> AND THEN .

    PLUS            reduce using rule 201 (short_circuit -> AND THEN .)
    MINUS           reduce using rule 201 (short_circuit -> AND THEN .)
    NOT             reduce using rule 201 (short_circuit -> AND THEN .)
    ABS             reduce using rule 201 (short_circuit -> AND THEN .)
    NUMBER          reduce using rule 201 (short_circuit -> AND THEN .)
    NULL            reduce using rule 201 (short_circuit -> AND THEN .)
    NEW             reduce using rule 201 (short_circuit -> AND THEN .)
    LPAREN          reduce using rule 201 (short_circuit -> AND THEN .)
    CHARACTER       reduce using rule 201 (short_circuit -> AND THEN .)
    IDENTIFIER      reduce using rule 201 (short_circuit -> AND THEN .)
    STRING          reduce using rule 201 (short_circuit -> AND THEN .)


state 394

    (196) expression -> expression logical relation .

    AND             reduce using rule 196 (expression -> expression logical relation .)
    OR              reduce using rule 196 (expression -> expression logical relation .)
    XOR             reduce using rule 196 (expression -> expression logical relation .)
    SEMICOLON       reduce using rule 196 (expression -> expression logical relation .)
    IS              reduce using rule 196 (expression -> expression logical relation .)
    RPAREN          reduce using rule 196 (expression -> expression logical relation .)
    COMMA           reduce using rule 196 (expression -> expression logical relation .)
    ARROW           reduce using rule 196 (expression -> expression logical relation .)
    |               reduce using rule 196 (expression -> expression logical relation .)
    RANGE           reduce using rule 196 (expression -> expression logical relation .)
    RENAMES         reduce using rule 196 (expression -> expression logical relation .)
    IS_ASSIGNED     reduce using rule 196 (expression -> expression logical relation .)
    WITH            reduce using rule 196 (expression -> expression logical relation .)
    THEN            reduce using rule 196 (expression -> expression logical relation .)
    LOOP            reduce using rule 196 (expression -> expression logical relation .)
    DIGITS          reduce using rule 196 (expression -> expression logical relation .)


state 395

    (197) expression -> expression short_circuit relation .

    AND             reduce using rule 197 (expression -> expression short_circuit relation .)
    OR              reduce using rule 197 (expression -> expression short_circuit relation .)
    XOR             reduce using rule 197 (expression -> expression short_circuit relation .)
    SEMICOLON       reduce using rule 197 (expression -> expression short_circuit relation .)
    IS              reduce using rule 197 (expression -> expression short_circuit relation .)
    RPAREN          reduce using rule 197 (expression -> expression short_circuit relation .)
    COMMA           reduce using rule 197 (expression -> expression short_circuit relation .)
    ARROW           reduce using rule 197 (expression -> expression short_circuit relation .)
    |               reduce using rule 197 (expression -> expression short_circuit relation .)
    RANGE           reduce using rule 197 (expression -> expression short_circuit relation .)
    RENAMES         reduce using rule 197 (expression -> expression short_circuit relation .)
    IS_ASSIGNED     reduce using rule 197 (expression -> expression short_circuit relation .)
    WITH            reduce using rule 197 (expression -> expression short_circuit relation .)
    THEN            reduce using rule 197 (expression -> expression short_circuit relation .)
    LOOP            reduce using rule 197 (expression -> expression short_circuit relation .)
    DIGITS          reduce using rule 197 (expression -> expression short_circuit relation .)


state 396

    (202) short_circuit -> OR ELSE .

    PLUS            reduce using rule 202 (short_circuit -> OR ELSE .)
    MINUS           reduce using rule 202 (short_circuit -> OR ELSE .)
    NOT             reduce using rule 202 (short_circuit -> OR ELSE .)
    ABS             reduce using rule 202 (short_circuit -> OR ELSE .)
    NUMBER          reduce using rule 202 (short_circuit -> OR ELSE .)
    NULL            reduce using rule 202 (short_circuit -> OR ELSE .)
    NEW             reduce using rule 202 (short_circuit -> OR ELSE .)
    LPAREN          reduce using rule 202 (short_circuit -> OR ELSE .)
    CHARACTER       reduce using rule 202 (short_circuit -> OR ELSE .)
    IDENTIFIER      reduce using rule 202 (short_circuit -> OR ELSE .)
    STRING          reduce using rule 202 (short_circuit -> OR ELSE .)


state 397

    (349) name_s -> name_s COMMA name .
    (168) indexed_comp -> name . LPAREN value_s RPAREN
    (175) selected_comp -> name . DOT simple_name
    (176) selected_comp -> name . DOT used_char
    (177) selected_comp -> name . DOT operator_symbol
    (178) selected_comp -> name . DOT ALL
    (179) attribute -> name . TICK attribute_id

    SEMICOLON       reduce using rule 349 (name_s -> name_s COMMA name .)
    COMMA           reduce using rule 349 (name_s -> name_s COMMA name .)
    LPAREN          shift and go to state 240
    DOT             shift and go to state 242
    TICK            shift and go to state 251


state 398

    (347) use_clause -> USE TYPE name_s SEMICOLON .

    error           reduce using rule 347 (use_clause -> USE TYPE name_s SEMICOLON .)
    USE             reduce using rule 347 (use_clause -> USE TYPE name_s SEMICOLON .)
    PRAGMA          reduce using rule 347 (use_clause -> USE TYPE name_s SEMICOLON .)
    TYPE            reduce using rule 347 (use_clause -> USE TYPE name_s SEMICOLON .)
    SUBTYPE         reduce using rule 347 (use_clause -> USE TYPE name_s SEMICOLON .)
    TASK            reduce using rule 347 (use_clause -> USE TYPE name_s SEMICOLON .)
    PACKAGE         reduce using rule 347 (use_clause -> USE TYPE name_s SEMICOLON .)
    PROTECTED       reduce using rule 347 (use_clause -> USE TYPE name_s SEMICOLON .)
    FOR             reduce using rule 347 (use_clause -> USE TYPE name_s SEMICOLON .)
    PROCEDURE       reduce using rule 347 (use_clause -> USE TYPE name_s SEMICOLON .)
    FUNCTION        reduce using rule 347 (use_clause -> USE TYPE name_s SEMICOLON .)
    GENERIC         reduce using rule 347 (use_clause -> USE TYPE name_s SEMICOLON .)
    IDENTIFIER      reduce using rule 347 (use_clause -> USE TYPE name_s SEMICOLON .)
    END             reduce using rule 347 (use_clause -> USE TYPE name_s SEMICOLON .)
    PRIVATE         reduce using rule 347 (use_clause -> USE TYPE name_s SEMICOLON .)
    WITH            reduce using rule 347 (use_clause -> USE TYPE name_s SEMICOLON .)
    SEPARATE        reduce using rule 347 (use_clause -> USE TYPE name_s SEMICOLON .)
    BEGIN           reduce using rule 347 (use_clause -> USE TYPE name_s SEMICOLON .)


state 399

    (447) subunit_body -> subprog_body .

    PRIVATE         reduce using rule 447 (subunit_body -> subprog_body .)
    WITH            reduce using rule 447 (subunit_body -> subprog_body .)
    PACKAGE         reduce using rule 447 (subunit_body -> subprog_body .)
    SEPARATE        reduce using rule 447 (subunit_body -> subprog_body .)
    PROCEDURE       reduce using rule 447 (subunit_body -> subprog_body .)
    FUNCTION        reduce using rule 447 (subunit_body -> subprog_body .)
    GENERIC         reduce using rule 447 (subunit_body -> subprog_body .)
    $end            reduce using rule 447 (subunit_body -> subprog_body .)


state 400

    (449) subunit_body -> task_body .

    PRIVATE         reduce using rule 449 (subunit_body -> task_body .)
    WITH            reduce using rule 449 (subunit_body -> task_body .)
    PACKAGE         reduce using rule 449 (subunit_body -> task_body .)
    SEPARATE        reduce using rule 449 (subunit_body -> task_body .)
    PROCEDURE       reduce using rule 449 (subunit_body -> task_body .)
    FUNCTION        reduce using rule 449 (subunit_body -> task_body .)
    GENERIC         reduce using rule 449 (subunit_body -> task_body .)
    $end            reduce using rule 449 (subunit_body -> task_body .)


state 401

    (382) prot_body -> PROTECTED . BODY simple_name IS prot_op_body_s END id_opt SEMICOLON

    BODY            shift and go to state 527


state 402

    (446) subunit -> SEPARATE LPAREN compound_name RPAREN subunit_body .

    PRIVATE         reduce using rule 446 (subunit -> SEPARATE LPAREN compound_name RPAREN subunit_body .)
    WITH            reduce using rule 446 (subunit -> SEPARATE LPAREN compound_name RPAREN subunit_body .)
    PACKAGE         reduce using rule 446 (subunit -> SEPARATE LPAREN compound_name RPAREN subunit_body .)
    SEPARATE        reduce using rule 446 (subunit -> SEPARATE LPAREN compound_name RPAREN subunit_body .)
    PROCEDURE       reduce using rule 446 (subunit -> SEPARATE LPAREN compound_name RPAREN subunit_body .)
    FUNCTION        reduce using rule 446 (subunit -> SEPARATE LPAREN compound_name RPAREN subunit_body .)
    GENERIC         reduce using rule 446 (subunit -> SEPARATE LPAREN compound_name RPAREN subunit_body .)
    $end            reduce using rule 446 (subunit -> SEPARATE LPAREN compound_name RPAREN subunit_body .)


state 403

    (365) task_body -> TASK . BODY simple_name IS decl_part block_body END id_opt SEMICOLON

    BODY            shift and go to state 528


state 404

    (330) subprog_spec_is_push -> subprog_spec . IS

    IS              shift and go to state 529


state 405

    (340) pkg_body -> PACKAGE . BODY compound_name IS decl_part body_opt END c_id_opt SEMICOLON

    BODY            shift and go to state 53


state 406

    (331) subprog_body -> subprog_spec_is_push . decl_part block_body END id_opt SEMICOLON
    (135) decl_part -> .
    (136) decl_part -> . decl_item_or_body_s1
    (145) decl_item_or_body_s1 -> . decl_item_or_body
    (146) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (147) decl_item_or_body -> . body
    (148) decl_item_or_body -> . decl_item
    (149) body -> . subprog_body
    (150) body -> . pkg_body
    (151) body -> . task_body
    (152) body -> . prot_body
    (141) decl_item -> . decl
    (142) decl_item -> . use_clause
    (143) decl_item -> . rep_spec
    (144) decl_item -> . pragma
    (331) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt SEMICOLON
    (340) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt SEMICOLON
    (365) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt SEMICOLON
    (382) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt SEMICOLON
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error SEMICOLON
    (346) use_clause -> . USE name_s SEMICOLON
    (347) use_clause -> . USE TYPE name_s SEMICOLON
    (500) rep_spec -> . attrib_def
    (501) rep_spec -> . record_type_spec
    (502) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (330) subprog_spec_is_push -> . subprog_spec IS
    (23) object_decl -> . def_id_s COLON object_qualifier_opt object_subtype_def init_opt SEMICOLON
    (35) number_decl -> . def_id_s COLON CONSTANT IS_ASSIGNED expression SEMICOLON
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion SEMICOLON
    (48) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind SEMICOLON
    (310) subprog_decl -> . subprog_spec SEMICOLON
    (311) subprog_decl -> . generic_subp_inst SEMICOLON
    (312) subprog_decl -> . subprog_spec_is_push ABSTRACT SEMICOLON
    (333) pkg_decl -> . pkg_spec SEMICOLON
    (334) pkg_decl -> . generic_pkg_inst SEMICOLON
    (358) task_decl -> . task_spec SEMICOLON
    (366) prot_decl -> . prot_spec SEMICOLON
    (455) exception_decl -> . def_id_s COLON EXCEPTION SEMICOLON
    (350) rename_decl -> . def_id_s COLON object_qualifier_opt subtype_ind renames SEMICOLON
    (351) rename_decl -> . def_id_s COLON EXCEPTION renames SEMICOLON
    (352) rename_decl -> . rename_unit
    (467) generic_decl -> . generic_formal_part subprog_spec SEMICOLON
    (468) generic_decl -> . generic_formal_part pkg_spec SEMICOLON
    (451) body_stub -> . TASK BODY simple_name IS SEPARATE SEMICOLON
    (452) body_stub -> . PACKAGE BODY compound_name IS SEPARATE SEMICOLON
    (453) body_stub -> . subprog_spec IS SEPARATE SEMICOLON
    (454) body_stub -> . PROTECTED BODY simple_name IS SEPARATE SEMICOLON
    (503) attrib_def -> . FOR mark USE expression SEMICOLON
    (504) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD SEMICOLON
    (509) address_spec -> . FOR mark USE AT expression SEMICOLON
    (313) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (314) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (315) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s COMMA def_id
    (497) generic_subp_inst -> . subprog_spec IS generic_inst
    (335) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (498) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (359) task_spec -> . TASK simple_name task_def
    (360) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (367) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (368) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (353) rename_unit -> . PACKAGE compound_name renames SEMICOLON
    (354) rename_unit -> . subprog_spec renames SEMICOLON
    (355) rename_unit -> . generic_formal_part PACKAGE compound_name renames SEMICOLON
    (356) rename_unit -> . generic_formal_part subprog_spec renames SEMICOLON
    (469) generic_formal_part -> . GENERIC
    (470) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    BEGIN           reduce using rule 135 (decl_part -> .)
    PACKAGE         shift and go to state 80
    TASK            shift and go to state 74
    PROTECTED       shift and go to state 58
    error           shift and go to state 85
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 87
    SUBTYPE         shift and go to state 91
    FOR             shift and go to state 70
    PROCEDURE       shift and go to state 30
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 79

    decl                           shift and go to state 57
    subprog_body                   shift and go to state 66
    task_decl                      shift and go to state 67
    type_decl                      shift and go to state 63
    rep_spec                       shift and go to state 89
    task_body                      shift and go to state 90
    subtype_decl                   shift and go to state 68
    exception_decl                 shift and go to state 92
    address_spec                   shift and go to state 59
    subprog_spec_is_push           shift and go to state 93
    decl_part                      shift and go to state 61
    prot_decl                      shift and go to state 62
    record_type_spec               shift and go to state 75
    generic_decl                   shift and go to state 76
    def_id                         shift and go to state 96
    attrib_def                     shift and go to state 77
    subprog_spec                   shift and go to state 94
    def_id_s                       shift and go to state 95
    decl_item_or_body_s1           shift and go to state 78
    decl_item                      shift and go to state 60
    task_spec                      shift and go to state 72
    body                           shift and go to state 69
    object_decl                    shift and go to state 71
    body_stub                      shift and go to state 81
    pkg_spec                       shift and go to state 37
    rename_decl                    shift and go to state 97
    generic_subp_inst              shift and go to state 28
    pragma                         shift and go to state 82
    rename_unit                    shift and go to state 98
    subprog_decl                   shift and go to state 65
    pkg_decl                       shift and go to state 64
    prot_spec                      shift and go to state 83
    generic_formal_part            shift and go to state 33
    prot_body                      shift and go to state 99
    use_clause                     shift and go to state 73
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 84
    decl_item_or_body              shift and go to state 86
    number_decl                    shift and go to state 100

state 407

    (450) subunit_body -> prot_body .

    PRIVATE         reduce using rule 450 (subunit_body -> prot_body .)
    WITH            reduce using rule 450 (subunit_body -> prot_body .)
    PACKAGE         reduce using rule 450 (subunit_body -> prot_body .)
    SEPARATE        reduce using rule 450 (subunit_body -> prot_body .)
    PROCEDURE       reduce using rule 450 (subunit_body -> prot_body .)
    FUNCTION        reduce using rule 450 (subunit_body -> prot_body .)
    GENERIC         reduce using rule 450 (subunit_body -> prot_body .)
    $end            reduce using rule 450 (subunit_body -> prot_body .)


state 408

    (448) subunit_body -> pkg_body .

    PRIVATE         reduce using rule 448 (subunit_body -> pkg_body .)
    WITH            reduce using rule 448 (subunit_body -> pkg_body .)
    PACKAGE         reduce using rule 448 (subunit_body -> pkg_body .)
    SEPARATE        reduce using rule 448 (subunit_body -> pkg_body .)
    PROCEDURE       reduce using rule 448 (subunit_body -> pkg_body .)
    FUNCTION        reduce using rule 448 (subunit_body -> pkg_body .)
    GENERIC         reduce using rule 448 (subunit_body -> pkg_body .)
    $end            reduce using rule 448 (subunit_body -> pkg_body .)


state 409

    (340) pkg_body -> PACKAGE BODY compound_name IS decl_part . body_opt END c_id_opt SEMICOLON
    (341) body_opt -> .
    (342) body_opt -> . block_body
    (298) block_body -> . BEGIN handled_stmt_s

    END             reduce using rule 341 (body_opt -> .)
    BEGIN           shift and go to state 168

    body_opt                       shift and go to state 530
    block_body                     shift and go to state 531

state 410

    (140) decl_item_s1 -> decl_item_s1 decl_item .

    error           reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)
    USE             reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)
    PRAGMA          reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)
    TYPE            reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)
    SUBTYPE         reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)
    TASK            reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)
    PACKAGE         reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)
    PROTECTED       reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)
    FOR             reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)
    PROCEDURE       reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)
    FUNCTION        reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)
    GENERIC         reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)
    IDENTIFIER      reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)
    PRIVATE         reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)
    END             reduce using rule 140 (decl_item_s1 -> decl_item_s1 decl_item .)


state 411

    (454) body_stub -> PROTECTED BODY . simple_name IS SEPARATE SEMICOLON
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 40

    simple_name                    shift and go to state 532

state 412

    (337) private_part -> PRIVATE . decl_item_s
    (137) decl_item_s -> .
    (138) decl_item_s -> . decl_item_s1
    (139) decl_item_s1 -> . decl_item
    (140) decl_item_s1 -> . decl_item_s1 decl_item
    (141) decl_item -> . decl
    (142) decl_item -> . use_clause
    (143) decl_item -> . rep_spec
    (144) decl_item -> . pragma
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error SEMICOLON
    (346) use_clause -> . USE name_s SEMICOLON
    (347) use_clause -> . USE TYPE name_s SEMICOLON
    (500) rep_spec -> . attrib_def
    (501) rep_spec -> . record_type_spec
    (502) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (23) object_decl -> . def_id_s COLON object_qualifier_opt object_subtype_def init_opt SEMICOLON
    (35) number_decl -> . def_id_s COLON CONSTANT IS_ASSIGNED expression SEMICOLON
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion SEMICOLON
    (48) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind SEMICOLON
    (310) subprog_decl -> . subprog_spec SEMICOLON
    (311) subprog_decl -> . generic_subp_inst SEMICOLON
    (312) subprog_decl -> . subprog_spec_is_push ABSTRACT SEMICOLON
    (333) pkg_decl -> . pkg_spec SEMICOLON
    (334) pkg_decl -> . generic_pkg_inst SEMICOLON
    (358) task_decl -> . task_spec SEMICOLON
    (366) prot_decl -> . prot_spec SEMICOLON
    (455) exception_decl -> . def_id_s COLON EXCEPTION SEMICOLON
    (350) rename_decl -> . def_id_s COLON object_qualifier_opt subtype_ind renames SEMICOLON
    (351) rename_decl -> . def_id_s COLON EXCEPTION renames SEMICOLON
    (352) rename_decl -> . rename_unit
    (467) generic_decl -> . generic_formal_part subprog_spec SEMICOLON
    (468) generic_decl -> . generic_formal_part pkg_spec SEMICOLON
    (451) body_stub -> . TASK BODY simple_name IS SEPARATE SEMICOLON
    (452) body_stub -> . PACKAGE BODY compound_name IS SEPARATE SEMICOLON
    (453) body_stub -> . subprog_spec IS SEPARATE SEMICOLON
    (454) body_stub -> . PROTECTED BODY simple_name IS SEPARATE SEMICOLON
    (503) attrib_def -> . FOR mark USE expression SEMICOLON
    (504) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD SEMICOLON
    (509) address_spec -> . FOR mark USE AT expression SEMICOLON
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s COMMA def_id
    (313) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (314) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (315) subprog_spec -> . FUNCTION designator
    (497) generic_subp_inst -> . subprog_spec IS generic_inst
    (330) subprog_spec_is_push -> . subprog_spec IS
    (335) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (498) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (359) task_spec -> . TASK simple_name task_def
    (360) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (367) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (368) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (353) rename_unit -> . PACKAGE compound_name renames SEMICOLON
    (354) rename_unit -> . subprog_spec renames SEMICOLON
    (355) rename_unit -> . generic_formal_part PACKAGE compound_name renames SEMICOLON
    (356) rename_unit -> . generic_formal_part subprog_spec renames SEMICOLON
    (469) generic_formal_part -> . GENERIC
    (470) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    END             reduce using rule 137 (decl_item_s -> .)
    error           shift and go to state 85
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 87
    SUBTYPE         shift and go to state 91
    TASK            shift and go to state 262
    PACKAGE         shift and go to state 263
    PROTECTED       shift and go to state 259
    FOR             shift and go to state 70
    PROCEDURE       shift and go to state 30
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 79

    decl                           shift and go to state 57
    task_decl                      shift and go to state 67
    subtype_decl                   shift and go to state 68
    rep_spec                       shift and go to state 89
    decl_item_s1                   shift and go to state 258
    exception_decl                 shift and go to state 92
    address_spec                   shift and go to state 59
    decl_item                      shift and go to state 260
    subprog_spec_is_push           shift and go to state 264
    prot_decl                      shift and go to state 62
    record_type_spec               shift and go to state 75
    generic_decl                   shift and go to state 76
    attrib_def                     shift and go to state 77
    subprog_spec                   shift and go to state 265
    def_id_s                       shift and go to state 95
    task_spec                      shift and go to state 72
    object_decl                    shift and go to state 71
    body_stub                      shift and go to state 81
    generic_subp_inst              shift and go to state 28
    def_id                         shift and go to state 96
    rename_decl                    shift and go to state 97
    type_decl                      shift and go to state 63
    rename_unit                    shift and go to state 98
    pkg_decl                       shift and go to state 64
    prot_spec                      shift and go to state 83
    generic_formal_part            shift and go to state 33
    use_clause                     shift and go to state 73
    generic_pkg_inst               shift and go to state 34
    subprog_decl                   shift and go to state 65
    decl_item_s                    shift and go to state 533
    pragma                         shift and go to state 82
    pkg_spec                       shift and go to state 37
    number_decl                    shift and go to state 100

state 413

    (335) pkg_spec -> PACKAGE compound_name IS decl_item_s private_part . END c_id_opt

    END             shift and go to state 534


state 414

    (451) body_stub -> TASK BODY . simple_name IS SEPARATE SEMICOLON
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 40

    simple_name                    shift and go to state 535

state 415

    (452) body_stub -> PACKAGE BODY . compound_name IS SEPARATE SEMICOLON
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name DOT simple_name
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 40

    compound_name                  shift and go to state 536
    simple_name                    shift and go to state 41

state 416

    (453) body_stub -> subprog_spec IS . SEPARATE SEMICOLON
    (497) generic_subp_inst -> subprog_spec IS . generic_inst
    (330) subprog_spec_is_push -> subprog_spec IS .
    (499) generic_inst -> . NEW name

    SEPARATE        shift and go to state 334
    ABSTRACT        reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    NEW             shift and go to state 157

    generic_inst                   shift and go to state 158

state 417

    (322) param_s -> param_s SEMICOLON . param
    (323) param -> . def_id_s COLON mode mark init_opt
    (324) param -> . error
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s COMMA def_id
    (26) def_id -> . IDENTIFIER

    error           shift and go to state 108
    IDENTIFIER      shift and go to state 79

    param                          shift and go to state 537
    def_id                         shift and go to state 96
    def_id_s                       shift and go to state 104

state 418

    (320) formal_part -> LPAREN param_s RPAREN .

    IS              reduce using rule 320 (formal_part -> LPAREN param_s RPAREN .)
    SEMICOLON       reduce using rule 320 (formal_part -> LPAREN param_s RPAREN .)
    DO              reduce using rule 320 (formal_part -> LPAREN param_s RPAREN .)
    WHEN            reduce using rule 320 (formal_part -> LPAREN param_s RPAREN .)
    RETURN          reduce using rule 320 (formal_part -> LPAREN param_s RPAREN .)
    RENAMES         reduce using rule 320 (formal_part -> LPAREN param_s RPAREN .)


state 419

    (382) prot_body -> PROTECTED BODY simple_name IS . prot_op_body_s END id_opt SEMICOLON
    (454) body_stub -> PROTECTED BODY simple_name IS . SEPARATE SEMICOLON
    (383) prot_op_body_s -> . pragma_s
    (384) prot_op_body_s -> . prot_op_body_s prot_op_body pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    SEPARATE        shift and go to state 538
    PRAGMA          reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)
    ENTRY           reduce using rule 8 (pragma_s -> .)
    PROCEDURE       reduce using rule 8 (pragma_s -> .)
    FUNCTION        reduce using rule 8 (pragma_s -> .)

    prot_op_body_s                 shift and go to state 539
    pragma_s                       shift and go to state 540

state 420

    (369) prot_def -> IS prot_op_decl_s . prot_private_opt END id_opt
    (373) prot_op_decl_s -> prot_op_decl_s . prot_op_decl
    (370) prot_private_opt -> .
    (371) prot_private_opt -> . PRIVATE prot_elem_decl_s
    (374) prot_op_decl -> . entry_decl
    (375) prot_op_decl -> . subprog_spec SEMICOLON
    (376) prot_op_decl -> . rep_spec
    (377) prot_op_decl -> . pragma
    (390) entry_decl -> . ENTRY IDENTIFIER formal_part_opt SEMICOLON
    (391) entry_decl -> . ENTRY IDENTIFIER LPAREN discrete_range RPAREN formal_part_opt SEMICOLON
    (313) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (314) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (315) subprog_spec -> . FUNCTION designator
    (500) rep_spec -> . attrib_def
    (501) rep_spec -> . record_type_spec
    (502) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (503) attrib_def -> . FOR mark USE expression SEMICOLON
    (504) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD SEMICOLON
    (509) address_spec -> . FOR mark USE AT expression SEMICOLON

    END             reduce using rule 370 (prot_private_opt -> .)
    PRIVATE         shift and go to state 544
    ENTRY           shift and go to state 547
    PROCEDURE       shift and go to state 30
    FUNCTION        shift and go to state 36
    PRAGMA          shift and go to state 4
    FOR             shift and go to state 70

    rep_spec                       shift and go to state 542
    entry_decl                     shift and go to state 543
    address_spec                   shift and go to state 59
    record_type_spec               shift and go to state 75
    attrib_def                     shift and go to state 77
    subprog_spec                   shift and go to state 545
    prot_private_opt               shift and go to state 546
    pragma                         shift and go to state 541
    prot_op_decl                   shift and go to state 548

state 421

    (368) prot_spec -> PROTECTED TYPE simple_name discrim_part_opt . prot_def
    (369) prot_def -> . IS prot_op_decl_s prot_private_opt END id_opt

    IS              shift and go to state 269

    prot_def                       shift and go to state 549

state 422

    (405) delay_stmt -> DELAY UNTIL . expression SEMICOLON
    (195) expression -> . relation
    (196) expression -> . expression logical relation
    (197) expression -> . expression short_circuit relation
    (203) relation -> . simple_expression
    (204) relation -> . simple_expression relational simple_expression
    (205) relation -> . simple_expression membership range
    (206) relation -> . simple_expression membership name
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    relation                       shift and go to state 127
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    factor                         shift and go to state 136
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    term                           shift and go to state 144
    name                           shift and go to state 145
    operator_symbol                shift and go to state 146
    expression                     shift and go to state 550

state 423

    (404) delay_stmt -> DELAY expression . SEMICOLON
    (196) expression -> expression . logical relation
    (197) expression -> expression . short_circuit relation
    (198) logical -> . AND
    (199) logical -> . OR
    (200) logical -> . XOR
    (201) short_circuit -> . AND THEN
    (202) short_circuit -> . OR ELSE

    SEMICOLON       shift and go to state 551
    AND             shift and go to state 244
    OR              shift and go to state 248
    XOR             shift and go to state 245

    logical                        shift and go to state 246
    short_circuit                  shift and go to state 247

state 424

    (289) iteration -> iter_part . reverse_opt discrete_range
    (290) reverse_opt -> .
    (291) reverse_opt -> . REVERSE

    IDENTIFIER      reduce using rule 290 (reverse_opt -> .)
    STRING          reduce using rule 290 (reverse_opt -> .)
    PLUS            reduce using rule 290 (reverse_opt -> .)
    MINUS           reduce using rule 290 (reverse_opt -> .)
    NOT             reduce using rule 290 (reverse_opt -> .)
    ABS             reduce using rule 290 (reverse_opt -> .)
    NUMBER          reduce using rule 290 (reverse_opt -> .)
    NULL            reduce using rule 290 (reverse_opt -> .)
    NEW             reduce using rule 290 (reverse_opt -> .)
    LPAREN          reduce using rule 290 (reverse_opt -> .)
    CHARACTER       reduce using rule 290 (reverse_opt -> .)
    REVERSE         shift and go to state 553

    reverse_opt                    shift and go to state 552

state 425

    (286) iter_part -> FOR . IDENTIFIER IN

    IDENTIFIER      shift and go to state 554


state 426

    (283) loop_stmt -> label_opt iteration . basic_loop id_opt SEMICOLON
    (292) basic_loop -> . LOOP statement_s END LOOP

    LOOP            shift and go to state 556

    basic_loop                     shift and go to state 555

state 427

    (295) block -> label_opt block_decl . block_body END id_opt SEMICOLON
    (298) block_body -> . BEGIN handled_stmt_s

    BEGIN           shift and go to state 168

    block_body                     shift and go to state 557

state 428

    (288) iteration -> WHILE . condition
    (274) condition -> . expression
    (195) expression -> . relation
    (196) expression -> . expression logical relation
    (197) expression -> . expression short_circuit relation
    (203) relation -> . simple_expression
    (204) relation -> . simple_expression relational simple_expression
    (205) relation -> . simple_expression membership range
    (206) relation -> . simple_expression membership name
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    relation                       shift and go to state 127
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    factor                         shift and go to state 136
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    condition                      shift and go to state 558
    term                           shift and go to state 144
    name                           shift and go to state 145
    operator_symbol                shift and go to state 146
    expression                     shift and go to state 470

state 429

    (297) block_decl -> DECLARE . decl_part
    (135) decl_part -> .
    (136) decl_part -> . decl_item_or_body_s1
    (145) decl_item_or_body_s1 -> . decl_item_or_body
    (146) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (147) decl_item_or_body -> . body
    (148) decl_item_or_body -> . decl_item
    (149) body -> . subprog_body
    (150) body -> . pkg_body
    (151) body -> . task_body
    (152) body -> . prot_body
    (141) decl_item -> . decl
    (142) decl_item -> . use_clause
    (143) decl_item -> . rep_spec
    (144) decl_item -> . pragma
    (331) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt SEMICOLON
    (340) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt SEMICOLON
    (365) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt SEMICOLON
    (382) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt SEMICOLON
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error SEMICOLON
    (346) use_clause -> . USE name_s SEMICOLON
    (347) use_clause -> . USE TYPE name_s SEMICOLON
    (500) rep_spec -> . attrib_def
    (501) rep_spec -> . record_type_spec
    (502) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (330) subprog_spec_is_push -> . subprog_spec IS
    (23) object_decl -> . def_id_s COLON object_qualifier_opt object_subtype_def init_opt SEMICOLON
    (35) number_decl -> . def_id_s COLON CONSTANT IS_ASSIGNED expression SEMICOLON
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion SEMICOLON
    (48) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind SEMICOLON
    (310) subprog_decl -> . subprog_spec SEMICOLON
    (311) subprog_decl -> . generic_subp_inst SEMICOLON
    (312) subprog_decl -> . subprog_spec_is_push ABSTRACT SEMICOLON
    (333) pkg_decl -> . pkg_spec SEMICOLON
    (334) pkg_decl -> . generic_pkg_inst SEMICOLON
    (358) task_decl -> . task_spec SEMICOLON
    (366) prot_decl -> . prot_spec SEMICOLON
    (455) exception_decl -> . def_id_s COLON EXCEPTION SEMICOLON
    (350) rename_decl -> . def_id_s COLON object_qualifier_opt subtype_ind renames SEMICOLON
    (351) rename_decl -> . def_id_s COLON EXCEPTION renames SEMICOLON
    (352) rename_decl -> . rename_unit
    (467) generic_decl -> . generic_formal_part subprog_spec SEMICOLON
    (468) generic_decl -> . generic_formal_part pkg_spec SEMICOLON
    (451) body_stub -> . TASK BODY simple_name IS SEPARATE SEMICOLON
    (452) body_stub -> . PACKAGE BODY compound_name IS SEPARATE SEMICOLON
    (453) body_stub -> . subprog_spec IS SEPARATE SEMICOLON
    (454) body_stub -> . PROTECTED BODY simple_name IS SEPARATE SEMICOLON
    (503) attrib_def -> . FOR mark USE expression SEMICOLON
    (504) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD SEMICOLON
    (509) address_spec -> . FOR mark USE AT expression SEMICOLON
    (313) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (314) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (315) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s COMMA def_id
    (497) generic_subp_inst -> . subprog_spec IS generic_inst
    (335) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (498) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (359) task_spec -> . TASK simple_name task_def
    (360) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (367) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (368) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (353) rename_unit -> . PACKAGE compound_name renames SEMICOLON
    (354) rename_unit -> . subprog_spec renames SEMICOLON
    (355) rename_unit -> . generic_formal_part PACKAGE compound_name renames SEMICOLON
    (356) rename_unit -> . generic_formal_part subprog_spec renames SEMICOLON
    (469) generic_formal_part -> . GENERIC
    (470) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    BEGIN           reduce using rule 135 (decl_part -> .)
    PACKAGE         shift and go to state 80
    TASK            shift and go to state 74
    PROTECTED       shift and go to state 58
    error           shift and go to state 85
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 87
    SUBTYPE         shift and go to state 91
    FOR             shift and go to state 70
    PROCEDURE       shift and go to state 30
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 79

    decl                           shift and go to state 57
    subprog_body                   shift and go to state 66
    task_decl                      shift and go to state 67
    type_decl                      shift and go to state 63
    rep_spec                       shift and go to state 89
    task_body                      shift and go to state 90
    subtype_decl                   shift and go to state 68
    exception_decl                 shift and go to state 92
    address_spec                   shift and go to state 59
    subprog_spec_is_push           shift and go to state 93
    decl_part                      shift and go to state 559
    prot_decl                      shift and go to state 62
    record_type_spec               shift and go to state 75
    generic_decl                   shift and go to state 76
    def_id                         shift and go to state 96
    attrib_def                     shift and go to state 77
    subprog_spec                   shift and go to state 94
    def_id_s                       shift and go to state 95
    decl_item_or_body_s1           shift and go to state 78
    decl_item                      shift and go to state 60
    task_spec                      shift and go to state 72
    body                           shift and go to state 69
    object_decl                    shift and go to state 71
    body_stub                      shift and go to state 81
    pkg_spec                       shift and go to state 37
    rename_decl                    shift and go to state 97
    generic_subp_inst              shift and go to state 28
    pragma                         shift and go to state 82
    rename_unit                    shift and go to state 98
    subprog_decl                   shift and go to state 65
    pkg_decl                       shift and go to state 64
    prot_spec                      shift and go to state 83
    generic_formal_part            shift and go to state 33
    prot_body                      shift and go to state 99
    use_clause                     shift and go to state 73
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 84
    decl_item_or_body              shift and go to state 86
    number_decl                    shift and go to state 100

state 430

    (309) goto_stmt -> GOTO name . SEMICOLON
    (168) indexed_comp -> name . LPAREN value_s RPAREN
    (175) selected_comp -> name . DOT simple_name
    (176) selected_comp -> name . DOT used_char
    (177) selected_comp -> name . DOT operator_symbol
    (178) selected_comp -> name . DOT ALL
    (179) attribute -> name . TICK attribute_id

    SEMICOLON       shift and go to state 560
    LPAREN          shift and go to state 240
    DOT             shift and go to state 242
    TICK            shift and go to state 251


state 431

    (510) code_stmt -> qualified SEMICOLON .

    EXCEPTION       reduce using rule 510 (code_stmt -> qualified SEMICOLON .)
    LLB             reduce using rule 510 (code_stmt -> qualified SEMICOLON .)
    error           reduce using rule 510 (code_stmt -> qualified SEMICOLON .)
    PRAGMA          reduce using rule 510 (code_stmt -> qualified SEMICOLON .)
    NULL            reduce using rule 510 (code_stmt -> qualified SEMICOLON .)
    EXIT            reduce using rule 510 (code_stmt -> qualified SEMICOLON .)
    RETURN          reduce using rule 510 (code_stmt -> qualified SEMICOLON .)
    GOTO            reduce using rule 510 (code_stmt -> qualified SEMICOLON .)
    DELAY           reduce using rule 510 (code_stmt -> qualified SEMICOLON .)
    ABORT           reduce using rule 510 (code_stmt -> qualified SEMICOLON .)
    RAISE           reduce using rule 510 (code_stmt -> qualified SEMICOLON .)
    REQUEUE         reduce using rule 510 (code_stmt -> qualified SEMICOLON .)
    IF              reduce using rule 510 (code_stmt -> qualified SEMICOLON .)
    CASE            reduce using rule 510 (code_stmt -> qualified SEMICOLON .)
    IDENTIFIER      reduce using rule 510 (code_stmt -> qualified SEMICOLON .)
    ACCEPT          reduce using rule 510 (code_stmt -> qualified SEMICOLON .)
    SELECT          reduce using rule 510 (code_stmt -> qualified SEMICOLON .)
    STRING          reduce using rule 510 (code_stmt -> qualified SEMICOLON .)
    WHILE           reduce using rule 510 (code_stmt -> qualified SEMICOLON .)
    DECLARE         reduce using rule 510 (code_stmt -> qualified SEMICOLON .)
    FOR             reduce using rule 510 (code_stmt -> qualified SEMICOLON .)
    LOOP            reduce using rule 510 (code_stmt -> qualified SEMICOLON .)
    BEGIN           reduce using rule 510 (code_stmt -> qualified SEMICOLON .)
    END             reduce using rule 510 (code_stmt -> qualified SEMICOLON .)
    OR              reduce using rule 510 (code_stmt -> qualified SEMICOLON .)
    ELSE            reduce using rule 510 (code_stmt -> qualified SEMICOLON .)
    ELSIF           reduce using rule 510 (code_stmt -> qualified SEMICOLON .)
    WHEN            reduce using rule 510 (code_stmt -> qualified SEMICOLON .)
    THEN            reduce using rule 510 (code_stmt -> qualified SEMICOLON .)


state 432

    (270) assign_stmt -> name IS_ASSIGNED . expression SEMICOLON
    (195) expression -> . relation
    (196) expression -> . expression logical relation
    (197) expression -> . expression short_circuit relation
    (203) relation -> . simple_expression
    (204) relation -> . simple_expression relational simple_expression
    (205) relation -> . simple_expression membership range
    (206) relation -> . simple_expression membership name
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    relation                       shift and go to state 127
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    factor                         shift and go to state 136
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    term                           shift and go to state 144
    name                           shift and go to state 145
    operator_symbol                shift and go to state 146
    expression                     shift and go to state 561

state 433

    (332) procedure_call -> name SEMICOLON .

    LLB             reduce using rule 332 (procedure_call -> name SEMICOLON .)
    error           reduce using rule 332 (procedure_call -> name SEMICOLON .)
    PRAGMA          reduce using rule 332 (procedure_call -> name SEMICOLON .)
    NULL            reduce using rule 332 (procedure_call -> name SEMICOLON .)
    EXIT            reduce using rule 332 (procedure_call -> name SEMICOLON .)
    RETURN          reduce using rule 332 (procedure_call -> name SEMICOLON .)
    GOTO            reduce using rule 332 (procedure_call -> name SEMICOLON .)
    DELAY           reduce using rule 332 (procedure_call -> name SEMICOLON .)
    ABORT           reduce using rule 332 (procedure_call -> name SEMICOLON .)
    RAISE           reduce using rule 332 (procedure_call -> name SEMICOLON .)
    REQUEUE         reduce using rule 332 (procedure_call -> name SEMICOLON .)
    IF              reduce using rule 332 (procedure_call -> name SEMICOLON .)
    CASE            reduce using rule 332 (procedure_call -> name SEMICOLON .)
    IDENTIFIER      reduce using rule 332 (procedure_call -> name SEMICOLON .)
    ACCEPT          reduce using rule 332 (procedure_call -> name SEMICOLON .)
    SELECT          reduce using rule 332 (procedure_call -> name SEMICOLON .)
    STRING          reduce using rule 332 (procedure_call -> name SEMICOLON .)
    WHILE           reduce using rule 332 (procedure_call -> name SEMICOLON .)
    DECLARE         reduce using rule 332 (procedure_call -> name SEMICOLON .)
    FOR             reduce using rule 332 (procedure_call -> name SEMICOLON .)
    LOOP            reduce using rule 332 (procedure_call -> name SEMICOLON .)
    BEGIN           reduce using rule 332 (procedure_call -> name SEMICOLON .)
    END             reduce using rule 332 (procedure_call -> name SEMICOLON .)
    OR              reduce using rule 332 (procedure_call -> name SEMICOLON .)
    ELSE            reduce using rule 332 (procedure_call -> name SEMICOLON .)
    THEN            reduce using rule 332 (procedure_call -> name SEMICOLON .)
    WHEN            reduce using rule 332 (procedure_call -> name SEMICOLON .)
    ELSIF           reduce using rule 332 (procedure_call -> name SEMICOLON .)
    EXCEPTION       reduce using rule 332 (procedure_call -> name SEMICOLON .)


state 434

    (425) abort_stmt -> ABORT name_s . SEMICOLON
    (349) name_s -> name_s . COMMA name

    SEMICOLON       shift and go to state 562
    COMMA           shift and go to state 249


state 435

    (401) accept_hdr -> ACCEPT entry_name . formal_part_opt
    (403) entry_name -> entry_name . LPAREN expression RPAREN
    (318) formal_part_opt -> .
    (319) formal_part_opt -> . formal_part
    (320) formal_part -> . LPAREN param_s RPAREN

    LPAREN          shift and go to state 563
    SEMICOLON       reduce using rule 318 (formal_part_opt -> .)
    DO              reduce using rule 318 (formal_part_opt -> .)

    formal_part                    shift and go to state 162
    formal_part_opt                shift and go to state 564

state 436

    (402) entry_name -> simple_name .

    LPAREN          reduce using rule 402 (entry_name -> simple_name .)
    SEMICOLON       reduce using rule 402 (entry_name -> simple_name .)
    DO              reduce using rule 402 (entry_name -> simple_name .)


state 437

    (415) select_alt -> accept_stmt . stmts_opt
    (423) stmts_opt -> .
    (424) stmts_opt -> . statement_s
    (243) statement_s -> . statement
    (244) statement_s -> . statement_s statement
    (245) statement -> . unlabeled
    (246) statement -> . label statement
    (247) unlabeled -> . simple_stmt
    (248) unlabeled -> . compound_stmt
    (249) unlabeled -> . pragma
    (268) label -> . LLB IDENTIFIER RLB
    (250) simple_stmt -> . NULL_stmt
    (251) simple_stmt -> . assign_stmt
    (252) simple_stmt -> . exit_stmt
    (253) simple_stmt -> . return_stmt
    (254) simple_stmt -> . goto_stmt
    (255) simple_stmt -> . procedure_call
    (256) simple_stmt -> . delay_stmt
    (257) simple_stmt -> . abort_stmt
    (258) simple_stmt -> . raise_stmt
    (259) simple_stmt -> . code_stmt
    (260) simple_stmt -> . requeue_stmt
    (261) simple_stmt -> . error SEMICOLON
    (262) compound_stmt -> . if_stmt
    (263) compound_stmt -> . case_stmt
    (264) compound_stmt -> . loop_stmt
    (265) compound_stmt -> . block
    (266) compound_stmt -> . accept_stmt
    (267) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (269) NULL_stmt -> . NULL SEMICOLON
    (270) assign_stmt -> . name IS_ASSIGNED expression SEMICOLON
    (302) exit_stmt -> . EXIT name_opt when_opt SEMICOLON
    (307) return_stmt -> . RETURN SEMICOLON
    (308) return_stmt -> . RETURN expression SEMICOLON
    (309) goto_stmt -> . GOTO name SEMICOLON
    (332) procedure_call -> . name SEMICOLON
    (404) delay_stmt -> . DELAY expression SEMICOLON
    (405) delay_stmt -> . DELAY UNTIL expression SEMICOLON
    (425) abort_stmt -> . ABORT name_s SEMICOLON
    (464) raise_stmt -> . RAISE name_opt SEMICOLON
    (510) code_stmt -> . qualified SEMICOLON
    (465) requeue_stmt -> . REQUEUE name SEMICOLON
    (466) requeue_stmt -> . REQUEUE name WITH ABORT SEMICOLON
    (271) if_stmt -> . IF cond_clause else_opt END IF SEMICOLON
    (278) case_stmt -> . case_hdr alternative_s END CASE SEMICOLON
    (283) loop_stmt -> . label_opt iteration basic_loop id_opt SEMICOLON
    (295) block -> . label_opt block_decl block_body END id_opt SEMICOLON
    (399) accept_stmt -> . accept_hdr SEMICOLON
    (400) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt SEMICOLON
    (406) select_stmt -> . select_wait
    (407) select_stmt -> . async_select
    (408) select_stmt -> . timed_entry_call
    (409) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (240) qualified -> . name TICK parenthesized_primary
    (279) case_hdr -> . CASE expression IS
    (284) label_opt -> .
    (285) label_opt -> . IDENTIFIER COLON
    (401) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (410) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON
    (420) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON
    (421) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON
    (422) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    OR              reduce using rule 423 (stmts_opt -> .)
    ELSE            reduce using rule 423 (stmts_opt -> .)
    ELSIF           reduce using rule 423 (stmts_opt -> .)
    END             reduce using rule 423 (stmts_opt -> .)
    LLB             shift and go to state 289
    error           shift and go to state 309
    PRAGMA          shift and go to state 4
    NULL            shift and go to state 311
    EXIT            shift and go to state 308
    RETURN          shift and go to state 295
    GOTO            shift and go to state 276
    DELAY           shift and go to state 272
    ABORT           shift and go to state 282
    RAISE           shift and go to state 306
    REQUEUE         shift and go to state 298
    IF              shift and go to state 317
    CASE            shift and go to state 297
    WHILE           reduce using rule 284 (label_opt -> .)
    DECLARE         reduce using rule 284 (label_opt -> .)
    FOR             reduce using rule 284 (label_opt -> .)
    LOOP            reduce using rule 284 (label_opt -> .)
    BEGIN           reduce using rule 284 (label_opt -> .)
    IDENTIFIER      shift and go to state 300
    ACCEPT          shift and go to state 284
    SELECT          shift and go to state 286
    STRING          shift and go to state 137

    indexed_comp                   shift and go to state 119
    accept_stmt                    shift and go to state 283
    label_opt                      shift and go to state 275
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 316
    abort_stmt                     shift and go to state 310
    return_stmt                    shift and go to state 294
    procedure_call                 shift and go to state 285
    assign_stmt                    shift and go to state 320
    statement_s                    shift and go to state 566
    simple_name                    shift and go to state 153
    code_stmt                      shift and go to state 313
    case_stmt                      shift and go to state 287
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 146
    label                          shift and go to state 288
    exit_stmt                      shift and go to state 315
    select_stmt                    shift and go to state 274
    statement                      shift and go to state 299
    compound_stmt                  shift and go to state 290
    case_hdr                       shift and go to state 292
    delay_stmt                     shift and go to state 301
    unlabeled                      shift and go to state 314
    simple_stmt                    shift and go to state 277
    loop_stmt                      shift and go to state 278
    qualified                      shift and go to state 279
    pragma                         shift and go to state 303
    async_select                   shift and go to state 273
    requeue_stmt                   shift and go to state 304
    raise_stmt                     shift and go to state 305
    name                           shift and go to state 281
    if_stmt                        shift and go to state 280
    accept_hdr                     shift and go to state 302
    cond_entry_call                shift and go to state 318
    timed_entry_call               shift and go to state 307
    stmts_opt                      shift and go to state 565
    goto_stmt                      shift and go to state 291
    NULL_stmt                      shift and go to state 319
    block                          shift and go to state 293

state 438

    (421) timed_entry_call -> SELECT entry_call . stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON
    (422) cond_entry_call -> SELECT entry_call . stmts_opt ELSE statement_s END SELECT SEMICOLON
    (419) delay_or_entry_alt -> entry_call . stmts_opt
    (423) stmts_opt -> .
    (424) stmts_opt -> . statement_s
    (243) statement_s -> . statement
    (244) statement_s -> . statement_s statement
    (245) statement -> . unlabeled
    (246) statement -> . label statement
    (247) unlabeled -> . simple_stmt
    (248) unlabeled -> . compound_stmt
    (249) unlabeled -> . pragma
    (268) label -> . LLB IDENTIFIER RLB
    (250) simple_stmt -> . NULL_stmt
    (251) simple_stmt -> . assign_stmt
    (252) simple_stmt -> . exit_stmt
    (253) simple_stmt -> . return_stmt
    (254) simple_stmt -> . goto_stmt
    (255) simple_stmt -> . procedure_call
    (256) simple_stmt -> . delay_stmt
    (257) simple_stmt -> . abort_stmt
    (258) simple_stmt -> . raise_stmt
    (259) simple_stmt -> . code_stmt
    (260) simple_stmt -> . requeue_stmt
    (261) simple_stmt -> . error SEMICOLON
    (262) compound_stmt -> . if_stmt
    (263) compound_stmt -> . case_stmt
    (264) compound_stmt -> . loop_stmt
    (265) compound_stmt -> . block
    (266) compound_stmt -> . accept_stmt
    (267) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (269) NULL_stmt -> . NULL SEMICOLON
    (270) assign_stmt -> . name IS_ASSIGNED expression SEMICOLON
    (302) exit_stmt -> . EXIT name_opt when_opt SEMICOLON
    (307) return_stmt -> . RETURN SEMICOLON
    (308) return_stmt -> . RETURN expression SEMICOLON
    (309) goto_stmt -> . GOTO name SEMICOLON
    (332) procedure_call -> . name SEMICOLON
    (404) delay_stmt -> . DELAY expression SEMICOLON
    (405) delay_stmt -> . DELAY UNTIL expression SEMICOLON
    (425) abort_stmt -> . ABORT name_s SEMICOLON
    (464) raise_stmt -> . RAISE name_opt SEMICOLON
    (510) code_stmt -> . qualified SEMICOLON
    (465) requeue_stmt -> . REQUEUE name SEMICOLON
    (466) requeue_stmt -> . REQUEUE name WITH ABORT SEMICOLON
    (271) if_stmt -> . IF cond_clause else_opt END IF SEMICOLON
    (278) case_stmt -> . case_hdr alternative_s END CASE SEMICOLON
    (283) loop_stmt -> . label_opt iteration basic_loop id_opt SEMICOLON
    (295) block -> . label_opt block_decl block_body END id_opt SEMICOLON
    (399) accept_stmt -> . accept_hdr SEMICOLON
    (400) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt SEMICOLON
    (406) select_stmt -> . select_wait
    (407) select_stmt -> . async_select
    (408) select_stmt -> . timed_entry_call
    (409) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (240) qualified -> . name TICK parenthesized_primary
    (279) case_hdr -> . CASE expression IS
    (284) label_opt -> .
    (285) label_opt -> . IDENTIFIER COLON
    (401) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (410) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON
    (420) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON
    (421) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON
    (422) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    OR              reduce using rule 423 (stmts_opt -> .)
    ELSE            reduce using rule 423 (stmts_opt -> .)
    THEN            reduce using rule 423 (stmts_opt -> .)
    LLB             shift and go to state 289
    error           shift and go to state 309
    PRAGMA          shift and go to state 4
    NULL            shift and go to state 311
    EXIT            shift and go to state 308
    RETURN          shift and go to state 295
    GOTO            shift and go to state 276
    DELAY           shift and go to state 272
    ABORT           shift and go to state 282
    RAISE           shift and go to state 306
    REQUEUE         shift and go to state 298
    IF              shift and go to state 317
    CASE            shift and go to state 297
    WHILE           reduce using rule 284 (label_opt -> .)
    DECLARE         reduce using rule 284 (label_opt -> .)
    FOR             reduce using rule 284 (label_opt -> .)
    LOOP            reduce using rule 284 (label_opt -> .)
    BEGIN           reduce using rule 284 (label_opt -> .)
    IDENTIFIER      shift and go to state 300
    ACCEPT          shift and go to state 284
    SELECT          shift and go to state 286
    STRING          shift and go to state 137

    indexed_comp                   shift and go to state 119
    accept_stmt                    shift and go to state 283
    label_opt                      shift and go to state 275
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 316
    abort_stmt                     shift and go to state 310
    return_stmt                    shift and go to state 294
    procedure_call                 shift and go to state 285
    assign_stmt                    shift and go to state 320
    statement_s                    shift and go to state 566
    simple_name                    shift and go to state 153
    code_stmt                      shift and go to state 313
    case_stmt                      shift and go to state 287
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 146
    label                          shift and go to state 288
    exit_stmt                      shift and go to state 315
    select_stmt                    shift and go to state 274
    statement                      shift and go to state 299
    compound_stmt                  shift and go to state 290
    case_hdr                       shift and go to state 292
    delay_stmt                     shift and go to state 301
    unlabeled                      shift and go to state 314
    simple_stmt                    shift and go to state 277
    loop_stmt                      shift and go to state 278
    qualified                      shift and go to state 279
    pragma                         shift and go to state 303
    async_select                   shift and go to state 273
    requeue_stmt                   shift and go to state 304
    raise_stmt                     shift and go to state 305
    name                           shift and go to state 281
    if_stmt                        shift and go to state 280
    accept_hdr                     shift and go to state 302
    cond_entry_call                shift and go to state 318
    timed_entry_call               shift and go to state 307
    stmts_opt                      shift and go to state 567
    goto_stmt                      shift and go to state 291
    NULL_stmt                      shift and go to state 319
    block                          shift and go to state 293

state 439

    (420) async_select -> SELECT delay_or_entry_alt . THEN ABORT statement_s END SELECT SEMICOLON

    THEN            shift and go to state 568


state 440

    (412) guarded_select_alt -> WHEN . condition ARROW select_alt
    (274) condition -> . expression
    (195) expression -> . relation
    (196) expression -> . expression logical relation
    (197) expression -> . expression short_circuit relation
    (203) relation -> . simple_expression
    (204) relation -> . simple_expression relational simple_expression
    (205) relation -> . simple_expression membership range
    (206) relation -> . simple_expression membership name
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    relation                       shift and go to state 127
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    factor                         shift and go to state 136
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    condition                      shift and go to state 569
    term                           shift and go to state 144
    name                           shift and go to state 145
    operator_symbol                shift and go to state 146
    expression                     shift and go to state 470

state 441

    (410) select_wait -> SELECT guarded_select_alt . or_select else_opt END SELECT SEMICOLON
    (413) or_select -> .
    (414) or_select -> . or_select OR guarded_select_alt

    OR              reduce using rule 413 (or_select -> .)
    ELSE            reduce using rule 413 (or_select -> .)
    ELSIF           reduce using rule 413 (or_select -> .)
    END             reduce using rule 413 (or_select -> .)

    or_select                      shift and go to state 570

state 442

    (411) guarded_select_alt -> select_alt .

    OR              reduce using rule 411 (guarded_select_alt -> select_alt .)
    ELSE            reduce using rule 411 (guarded_select_alt -> select_alt .)
    ELSIF           reduce using rule 411 (guarded_select_alt -> select_alt .)
    END             reduce using rule 411 (guarded_select_alt -> select_alt .)


state 443

    (418) delay_or_entry_alt -> delay_stmt . stmts_opt
    (416) select_alt -> delay_stmt . stmts_opt
    (423) stmts_opt -> .
    (424) stmts_opt -> . statement_s
    (243) statement_s -> . statement
    (244) statement_s -> . statement_s statement
    (245) statement -> . unlabeled
    (246) statement -> . label statement
    (247) unlabeled -> . simple_stmt
    (248) unlabeled -> . compound_stmt
    (249) unlabeled -> . pragma
    (268) label -> . LLB IDENTIFIER RLB
    (250) simple_stmt -> . NULL_stmt
    (251) simple_stmt -> . assign_stmt
    (252) simple_stmt -> . exit_stmt
    (253) simple_stmt -> . return_stmt
    (254) simple_stmt -> . goto_stmt
    (255) simple_stmt -> . procedure_call
    (256) simple_stmt -> . delay_stmt
    (257) simple_stmt -> . abort_stmt
    (258) simple_stmt -> . raise_stmt
    (259) simple_stmt -> . code_stmt
    (260) simple_stmt -> . requeue_stmt
    (261) simple_stmt -> . error SEMICOLON
    (262) compound_stmt -> . if_stmt
    (263) compound_stmt -> . case_stmt
    (264) compound_stmt -> . loop_stmt
    (265) compound_stmt -> . block
    (266) compound_stmt -> . accept_stmt
    (267) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (269) NULL_stmt -> . NULL SEMICOLON
    (270) assign_stmt -> . name IS_ASSIGNED expression SEMICOLON
    (302) exit_stmt -> . EXIT name_opt when_opt SEMICOLON
    (307) return_stmt -> . RETURN SEMICOLON
    (308) return_stmt -> . RETURN expression SEMICOLON
    (309) goto_stmt -> . GOTO name SEMICOLON
    (332) procedure_call -> . name SEMICOLON
    (404) delay_stmt -> . DELAY expression SEMICOLON
    (405) delay_stmt -> . DELAY UNTIL expression SEMICOLON
    (425) abort_stmt -> . ABORT name_s SEMICOLON
    (464) raise_stmt -> . RAISE name_opt SEMICOLON
    (510) code_stmt -> . qualified SEMICOLON
    (465) requeue_stmt -> . REQUEUE name SEMICOLON
    (466) requeue_stmt -> . REQUEUE name WITH ABORT SEMICOLON
    (271) if_stmt -> . IF cond_clause else_opt END IF SEMICOLON
    (278) case_stmt -> . case_hdr alternative_s END CASE SEMICOLON
    (283) loop_stmt -> . label_opt iteration basic_loop id_opt SEMICOLON
    (295) block -> . label_opt block_decl block_body END id_opt SEMICOLON
    (399) accept_stmt -> . accept_hdr SEMICOLON
    (400) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt SEMICOLON
    (406) select_stmt -> . select_wait
    (407) select_stmt -> . async_select
    (408) select_stmt -> . timed_entry_call
    (409) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (240) qualified -> . name TICK parenthesized_primary
    (279) case_hdr -> . CASE expression IS
    (284) label_opt -> .
    (285) label_opt -> . IDENTIFIER COLON
    (401) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (410) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON
    (420) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON
    (421) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON
    (422) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    THEN            reduce using rule 423 (stmts_opt -> .)
    OR              reduce using rule 423 (stmts_opt -> .)
    ELSE            reduce using rule 423 (stmts_opt -> .)
    ELSIF           reduce using rule 423 (stmts_opt -> .)
    END             reduce using rule 423 (stmts_opt -> .)
    LLB             shift and go to state 289
    error           shift and go to state 309
    PRAGMA          shift and go to state 4
    NULL            shift and go to state 311
    EXIT            shift and go to state 308
    RETURN          shift and go to state 295
    GOTO            shift and go to state 276
    DELAY           shift and go to state 272
    ABORT           shift and go to state 282
    RAISE           shift and go to state 306
    REQUEUE         shift and go to state 298
    IF              shift and go to state 317
    CASE            shift and go to state 297
    WHILE           reduce using rule 284 (label_opt -> .)
    DECLARE         reduce using rule 284 (label_opt -> .)
    FOR             reduce using rule 284 (label_opt -> .)
    LOOP            reduce using rule 284 (label_opt -> .)
    BEGIN           reduce using rule 284 (label_opt -> .)
    IDENTIFIER      shift and go to state 300
    ACCEPT          shift and go to state 284
    SELECT          shift and go to state 286
    STRING          shift and go to state 137

    indexed_comp                   shift and go to state 119
    accept_stmt                    shift and go to state 283
    label_opt                      shift and go to state 275
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 316
    abort_stmt                     shift and go to state 310
    return_stmt                    shift and go to state 294
    procedure_call                 shift and go to state 285
    assign_stmt                    shift and go to state 320
    statement_s                    shift and go to state 566
    simple_name                    shift and go to state 153
    code_stmt                      shift and go to state 313
    case_stmt                      shift and go to state 287
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 146
    label                          shift and go to state 288
    exit_stmt                      shift and go to state 315
    select_stmt                    shift and go to state 274
    statement                      shift and go to state 299
    compound_stmt                  shift and go to state 290
    case_hdr                       shift and go to state 292
    delay_stmt                     shift and go to state 301
    unlabeled                      shift and go to state 314
    simple_stmt                    shift and go to state 277
    loop_stmt                      shift and go to state 278
    qualified                      shift and go to state 279
    pragma                         shift and go to state 303
    async_select                   shift and go to state 273
    requeue_stmt                   shift and go to state 304
    raise_stmt                     shift and go to state 305
    name                           shift and go to state 281
    if_stmt                        shift and go to state 280
    accept_hdr                     shift and go to state 302
    cond_entry_call                shift and go to state 318
    timed_entry_call               shift and go to state 307
    stmts_opt                      shift and go to state 571
    goto_stmt                      shift and go to state 291
    NULL_stmt                      shift and go to state 319
    block                          shift and go to state 293

state 444

    (332) procedure_call -> name . SEMICOLON
    (168) indexed_comp -> name . LPAREN value_s RPAREN
    (175) selected_comp -> name . DOT simple_name
    (176) selected_comp -> name . DOT used_char
    (177) selected_comp -> name . DOT operator_symbol
    (178) selected_comp -> name . DOT ALL
    (179) attribute -> name . TICK attribute_id

    SEMICOLON       shift and go to state 433
    LPAREN          shift and go to state 240
    DOT             shift and go to state 242
    TICK            shift and go to state 251


state 445

    (417) select_alt -> TERMINATE . SEMICOLON

    SEMICOLON       shift and go to state 572


state 446

    (398) entry_call -> procedure_call .

    LLB             reduce using rule 398 (entry_call -> procedure_call .)
    error           reduce using rule 398 (entry_call -> procedure_call .)
    PRAGMA          reduce using rule 398 (entry_call -> procedure_call .)
    NULL            reduce using rule 398 (entry_call -> procedure_call .)
    EXIT            reduce using rule 398 (entry_call -> procedure_call .)
    RETURN          reduce using rule 398 (entry_call -> procedure_call .)
    GOTO            reduce using rule 398 (entry_call -> procedure_call .)
    DELAY           reduce using rule 398 (entry_call -> procedure_call .)
    ABORT           reduce using rule 398 (entry_call -> procedure_call .)
    RAISE           reduce using rule 398 (entry_call -> procedure_call .)
    REQUEUE         reduce using rule 398 (entry_call -> procedure_call .)
    IF              reduce using rule 398 (entry_call -> procedure_call .)
    CASE            reduce using rule 398 (entry_call -> procedure_call .)
    IDENTIFIER      reduce using rule 398 (entry_call -> procedure_call .)
    ACCEPT          reduce using rule 398 (entry_call -> procedure_call .)
    SELECT          reduce using rule 398 (entry_call -> procedure_call .)
    STRING          reduce using rule 398 (entry_call -> procedure_call .)
    OR              reduce using rule 398 (entry_call -> procedure_call .)
    ELSE            reduce using rule 398 (entry_call -> procedure_call .)
    WHILE           reduce using rule 398 (entry_call -> procedure_call .)
    DECLARE         reduce using rule 398 (entry_call -> procedure_call .)
    FOR             reduce using rule 398 (entry_call -> procedure_call .)
    LOOP            reduce using rule 398 (entry_call -> procedure_call .)
    BEGIN           reduce using rule 398 (entry_call -> procedure_call .)
    THEN            reduce using rule 398 (entry_call -> procedure_call .)


state 447

    (246) statement -> label statement .

    END             reduce using rule 246 (statement -> label statement .)
    LLB             reduce using rule 246 (statement -> label statement .)
    error           reduce using rule 246 (statement -> label statement .)
    PRAGMA          reduce using rule 246 (statement -> label statement .)
    NULL            reduce using rule 246 (statement -> label statement .)
    EXIT            reduce using rule 246 (statement -> label statement .)
    RETURN          reduce using rule 246 (statement -> label statement .)
    GOTO            reduce using rule 246 (statement -> label statement .)
    DELAY           reduce using rule 246 (statement -> label statement .)
    ABORT           reduce using rule 246 (statement -> label statement .)
    RAISE           reduce using rule 246 (statement -> label statement .)
    REQUEUE         reduce using rule 246 (statement -> label statement .)
    IF              reduce using rule 246 (statement -> label statement .)
    CASE            reduce using rule 246 (statement -> label statement .)
    IDENTIFIER      reduce using rule 246 (statement -> label statement .)
    ACCEPT          reduce using rule 246 (statement -> label statement .)
    SELECT          reduce using rule 246 (statement -> label statement .)
    STRING          reduce using rule 246 (statement -> label statement .)
    WHILE           reduce using rule 246 (statement -> label statement .)
    DECLARE         reduce using rule 246 (statement -> label statement .)
    FOR             reduce using rule 246 (statement -> label statement .)
    LOOP            reduce using rule 246 (statement -> label statement .)
    BEGIN           reduce using rule 246 (statement -> label statement .)
    OR              reduce using rule 246 (statement -> label statement .)
    ELSE            reduce using rule 246 (statement -> label statement .)
    THEN            reduce using rule 246 (statement -> label statement .)
    ELSIF           reduce using rule 246 (statement -> label statement .)
    WHEN            reduce using rule 246 (statement -> label statement .)
    EXCEPTION       reduce using rule 246 (statement -> label statement .)


state 448

    (268) label -> LLB IDENTIFIER . RLB

    RLB             shift and go to state 573


state 449

    (278) case_stmt -> case_hdr alternative_s . END CASE SEMICOLON
    (281) alternative_s -> alternative_s . alternative
    (282) alternative -> . WHEN choice_s ARROW statement_s

    END             shift and go to state 574
    WHEN            shift and go to state 575

    alternative                    shift and go to state 576

state 450

    (307) return_stmt -> RETURN SEMICOLON .

    LLB             reduce using rule 307 (return_stmt -> RETURN SEMICOLON .)
    error           reduce using rule 307 (return_stmt -> RETURN SEMICOLON .)
    PRAGMA          reduce using rule 307 (return_stmt -> RETURN SEMICOLON .)
    NULL            reduce using rule 307 (return_stmt -> RETURN SEMICOLON .)
    EXIT            reduce using rule 307 (return_stmt -> RETURN SEMICOLON .)
    RETURN          reduce using rule 307 (return_stmt -> RETURN SEMICOLON .)
    GOTO            reduce using rule 307 (return_stmt -> RETURN SEMICOLON .)
    DELAY           reduce using rule 307 (return_stmt -> RETURN SEMICOLON .)
    ABORT           reduce using rule 307 (return_stmt -> RETURN SEMICOLON .)
    RAISE           reduce using rule 307 (return_stmt -> RETURN SEMICOLON .)
    REQUEUE         reduce using rule 307 (return_stmt -> RETURN SEMICOLON .)
    IF              reduce using rule 307 (return_stmt -> RETURN SEMICOLON .)
    CASE            reduce using rule 307 (return_stmt -> RETURN SEMICOLON .)
    IDENTIFIER      reduce using rule 307 (return_stmt -> RETURN SEMICOLON .)
    ACCEPT          reduce using rule 307 (return_stmt -> RETURN SEMICOLON .)
    SELECT          reduce using rule 307 (return_stmt -> RETURN SEMICOLON .)
    STRING          reduce using rule 307 (return_stmt -> RETURN SEMICOLON .)
    WHILE           reduce using rule 307 (return_stmt -> RETURN SEMICOLON .)
    DECLARE         reduce using rule 307 (return_stmt -> RETURN SEMICOLON .)
    FOR             reduce using rule 307 (return_stmt -> RETURN SEMICOLON .)
    LOOP            reduce using rule 307 (return_stmt -> RETURN SEMICOLON .)
    BEGIN           reduce using rule 307 (return_stmt -> RETURN SEMICOLON .)
    THEN            reduce using rule 307 (return_stmt -> RETURN SEMICOLON .)
    OR              reduce using rule 307 (return_stmt -> RETURN SEMICOLON .)
    ELSE            reduce using rule 307 (return_stmt -> RETURN SEMICOLON .)
    ELSIF           reduce using rule 307 (return_stmt -> RETURN SEMICOLON .)
    END             reduce using rule 307 (return_stmt -> RETURN SEMICOLON .)
    EXCEPTION       reduce using rule 307 (return_stmt -> RETURN SEMICOLON .)
    WHEN            reduce using rule 307 (return_stmt -> RETURN SEMICOLON .)


state 451

    (308) return_stmt -> RETURN expression . SEMICOLON
    (196) expression -> expression . logical relation
    (197) expression -> expression . short_circuit relation
    (198) logical -> . AND
    (199) logical -> . OR
    (200) logical -> . XOR
    (201) short_circuit -> . AND THEN
    (202) short_circuit -> . OR ELSE

    SEMICOLON       shift and go to state 577
    AND             shift and go to state 244
    OR              shift and go to state 248
    XOR             shift and go to state 245

    logical                        shift and go to state 246
    short_circuit                  shift and go to state 247

state 452

    (279) case_hdr -> CASE expression . IS
    (196) expression -> expression . logical relation
    (197) expression -> expression . short_circuit relation
    (198) logical -> . AND
    (199) logical -> . OR
    (200) logical -> . XOR
    (201) short_circuit -> . AND THEN
    (202) short_circuit -> . OR ELSE

    IS              shift and go to state 578
    AND             shift and go to state 244
    OR              shift and go to state 248
    XOR             shift and go to state 245

    logical                        shift and go to state 246
    short_circuit                  shift and go to state 247

state 453

    (465) requeue_stmt -> REQUEUE name . SEMICOLON
    (466) requeue_stmt -> REQUEUE name . WITH ABORT SEMICOLON
    (168) indexed_comp -> name . LPAREN value_s RPAREN
    (175) selected_comp -> name . DOT simple_name
    (176) selected_comp -> name . DOT used_char
    (177) selected_comp -> name . DOT operator_symbol
    (178) selected_comp -> name . DOT ALL
    (179) attribute -> name . TICK attribute_id

    SEMICOLON       shift and go to state 579
    WITH            shift and go to state 580
    LPAREN          shift and go to state 240
    DOT             shift and go to state 242
    TICK            shift and go to state 251


state 454

    (285) label_opt -> IDENTIFIER COLON .

    WHILE           reduce using rule 285 (label_opt -> IDENTIFIER COLON .)
    DECLARE         reduce using rule 285 (label_opt -> IDENTIFIER COLON .)
    FOR             reduce using rule 285 (label_opt -> IDENTIFIER COLON .)
    LOOP            reduce using rule 285 (label_opt -> IDENTIFIER COLON .)
    BEGIN           reduce using rule 285 (label_opt -> IDENTIFIER COLON .)


state 455

    (399) accept_stmt -> accept_hdr SEMICOLON .

    LLB             reduce using rule 399 (accept_stmt -> accept_hdr SEMICOLON .)
    error           reduce using rule 399 (accept_stmt -> accept_hdr SEMICOLON .)
    PRAGMA          reduce using rule 399 (accept_stmt -> accept_hdr SEMICOLON .)
    NULL            reduce using rule 399 (accept_stmt -> accept_hdr SEMICOLON .)
    EXIT            reduce using rule 399 (accept_stmt -> accept_hdr SEMICOLON .)
    RETURN          reduce using rule 399 (accept_stmt -> accept_hdr SEMICOLON .)
    GOTO            reduce using rule 399 (accept_stmt -> accept_hdr SEMICOLON .)
    DELAY           reduce using rule 399 (accept_stmt -> accept_hdr SEMICOLON .)
    ABORT           reduce using rule 399 (accept_stmt -> accept_hdr SEMICOLON .)
    RAISE           reduce using rule 399 (accept_stmt -> accept_hdr SEMICOLON .)
    REQUEUE         reduce using rule 399 (accept_stmt -> accept_hdr SEMICOLON .)
    IF              reduce using rule 399 (accept_stmt -> accept_hdr SEMICOLON .)
    CASE            reduce using rule 399 (accept_stmt -> accept_hdr SEMICOLON .)
    IDENTIFIER      reduce using rule 399 (accept_stmt -> accept_hdr SEMICOLON .)
    ACCEPT          reduce using rule 399 (accept_stmt -> accept_hdr SEMICOLON .)
    SELECT          reduce using rule 399 (accept_stmt -> accept_hdr SEMICOLON .)
    STRING          reduce using rule 399 (accept_stmt -> accept_hdr SEMICOLON .)
    WHILE           reduce using rule 399 (accept_stmt -> accept_hdr SEMICOLON .)
    DECLARE         reduce using rule 399 (accept_stmt -> accept_hdr SEMICOLON .)
    FOR             reduce using rule 399 (accept_stmt -> accept_hdr SEMICOLON .)
    LOOP            reduce using rule 399 (accept_stmt -> accept_hdr SEMICOLON .)
    BEGIN           reduce using rule 399 (accept_stmt -> accept_hdr SEMICOLON .)
    END             reduce using rule 399 (accept_stmt -> accept_hdr SEMICOLON .)
    EXCEPTION       reduce using rule 399 (accept_stmt -> accept_hdr SEMICOLON .)
    OR              reduce using rule 399 (accept_stmt -> accept_hdr SEMICOLON .)
    ELSE            reduce using rule 399 (accept_stmt -> accept_hdr SEMICOLON .)
    ELSIF           reduce using rule 399 (accept_stmt -> accept_hdr SEMICOLON .)
    THEN            reduce using rule 399 (accept_stmt -> accept_hdr SEMICOLON .)
    WHEN            reduce using rule 399 (accept_stmt -> accept_hdr SEMICOLON .)


state 456

    (400) accept_stmt -> accept_hdr DO . handled_stmt_s END id_opt SEMICOLON
    (299) handled_stmt_s -> . statement_s except_handler_part_opt
    (243) statement_s -> . statement
    (244) statement_s -> . statement_s statement
    (245) statement -> . unlabeled
    (246) statement -> . label statement
    (247) unlabeled -> . simple_stmt
    (248) unlabeled -> . compound_stmt
    (249) unlabeled -> . pragma
    (268) label -> . LLB IDENTIFIER RLB
    (250) simple_stmt -> . NULL_stmt
    (251) simple_stmt -> . assign_stmt
    (252) simple_stmt -> . exit_stmt
    (253) simple_stmt -> . return_stmt
    (254) simple_stmt -> . goto_stmt
    (255) simple_stmt -> . procedure_call
    (256) simple_stmt -> . delay_stmt
    (257) simple_stmt -> . abort_stmt
    (258) simple_stmt -> . raise_stmt
    (259) simple_stmt -> . code_stmt
    (260) simple_stmt -> . requeue_stmt
    (261) simple_stmt -> . error SEMICOLON
    (262) compound_stmt -> . if_stmt
    (263) compound_stmt -> . case_stmt
    (264) compound_stmt -> . loop_stmt
    (265) compound_stmt -> . block
    (266) compound_stmt -> . accept_stmt
    (267) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (269) NULL_stmt -> . NULL SEMICOLON
    (270) assign_stmt -> . name IS_ASSIGNED expression SEMICOLON
    (302) exit_stmt -> . EXIT name_opt when_opt SEMICOLON
    (307) return_stmt -> . RETURN SEMICOLON
    (308) return_stmt -> . RETURN expression SEMICOLON
    (309) goto_stmt -> . GOTO name SEMICOLON
    (332) procedure_call -> . name SEMICOLON
    (404) delay_stmt -> . DELAY expression SEMICOLON
    (405) delay_stmt -> . DELAY UNTIL expression SEMICOLON
    (425) abort_stmt -> . ABORT name_s SEMICOLON
    (464) raise_stmt -> . RAISE name_opt SEMICOLON
    (510) code_stmt -> . qualified SEMICOLON
    (465) requeue_stmt -> . REQUEUE name SEMICOLON
    (466) requeue_stmt -> . REQUEUE name WITH ABORT SEMICOLON
    (271) if_stmt -> . IF cond_clause else_opt END IF SEMICOLON
    (278) case_stmt -> . case_hdr alternative_s END CASE SEMICOLON
    (283) loop_stmt -> . label_opt iteration basic_loop id_opt SEMICOLON
    (295) block -> . label_opt block_decl block_body END id_opt SEMICOLON
    (399) accept_stmt -> . accept_hdr SEMICOLON
    (400) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt SEMICOLON
    (406) select_stmt -> . select_wait
    (407) select_stmt -> . async_select
    (408) select_stmt -> . timed_entry_call
    (409) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (240) qualified -> . name TICK parenthesized_primary
    (279) case_hdr -> . CASE expression IS
    (284) label_opt -> .
    (285) label_opt -> . IDENTIFIER COLON
    (401) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (410) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON
    (420) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON
    (421) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON
    (422) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    LLB             shift and go to state 289
    error           shift and go to state 309
    PRAGMA          shift and go to state 4
    NULL            shift and go to state 311
    EXIT            shift and go to state 308
    RETURN          shift and go to state 295
    GOTO            shift and go to state 276
    DELAY           shift and go to state 272
    ABORT           shift and go to state 282
    RAISE           shift and go to state 306
    REQUEUE         shift and go to state 298
    IF              shift and go to state 317
    CASE            shift and go to state 297
    WHILE           reduce using rule 284 (label_opt -> .)
    DECLARE         reduce using rule 284 (label_opt -> .)
    FOR             reduce using rule 284 (label_opt -> .)
    LOOP            reduce using rule 284 (label_opt -> .)
    BEGIN           reduce using rule 284 (label_opt -> .)
    IDENTIFIER      shift and go to state 300
    ACCEPT          shift and go to state 284
    SELECT          shift and go to state 286
    STRING          shift and go to state 137

    indexed_comp                   shift and go to state 119
    accept_stmt                    shift and go to state 283
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 316
    abort_stmt                     shift and go to state 310
    return_stmt                    shift and go to state 294
    procedure_call                 shift and go to state 285
    label                          shift and go to state 288
    statement_s                    shift and go to state 312
    simple_name                    shift and go to state 153
    code_stmt                      shift and go to state 313
    handled_stmt_s                 shift and go to state 581
    case_stmt                      shift and go to state 287
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 146
    assign_stmt                    shift and go to state 320
    exit_stmt                      shift and go to state 315
    select_stmt                    shift and go to state 274
    statement                      shift and go to state 299
    compound_stmt                  shift and go to state 290
    case_hdr                       shift and go to state 292
    delay_stmt                     shift and go to state 301
    accept_hdr                     shift and go to state 302
    unlabeled                      shift and go to state 314
    simple_stmt                    shift and go to state 277
    loop_stmt                      shift and go to state 278
    pragma                         shift and go to state 303
    async_select                   shift and go to state 273
    requeue_stmt                   shift and go to state 304
    raise_stmt                     shift and go to state 305
    name                           shift and go to state 281
    if_stmt                        shift and go to state 280
    cond_entry_call                shift and go to state 318
    timed_entry_call               shift and go to state 307
    qualified                      shift and go to state 279
    label_opt                      shift and go to state 275
    goto_stmt                      shift and go to state 291
    NULL_stmt                      shift and go to state 319
    block                          shift and go to state 293

state 457

    (304) name_opt -> name .
    (168) indexed_comp -> name . LPAREN value_s RPAREN
    (175) selected_comp -> name . DOT simple_name
    (176) selected_comp -> name . DOT used_char
    (177) selected_comp -> name . DOT operator_symbol
    (178) selected_comp -> name . DOT ALL
    (179) attribute -> name . TICK attribute_id

    SEMICOLON       reduce using rule 304 (name_opt -> name .)
    WHEN            reduce using rule 304 (name_opt -> name .)
    LPAREN          shift and go to state 240
    DOT             shift and go to state 242
    TICK            shift and go to state 251


state 458

    (464) raise_stmt -> RAISE name_opt . SEMICOLON

    SEMICOLON       shift and go to state 582


state 459

    (303) name_opt -> empty .

    SEMICOLON       reduce using rule 303 (name_opt -> empty .)
    WHEN            reduce using rule 303 (name_opt -> empty .)


state 460

    (302) exit_stmt -> EXIT name_opt . when_opt SEMICOLON
    (305) when_opt -> .
    (306) when_opt -> . WHEN condition

    SEMICOLON       reduce using rule 305 (when_opt -> .)
    WHEN            shift and go to state 584

    when_opt                       shift and go to state 583

state 461

    (261) simple_stmt -> error SEMICOLON .

    EXCEPTION       reduce using rule 261 (simple_stmt -> error SEMICOLON .)
    LLB             reduce using rule 261 (simple_stmt -> error SEMICOLON .)
    error           reduce using rule 261 (simple_stmt -> error SEMICOLON .)
    PRAGMA          reduce using rule 261 (simple_stmt -> error SEMICOLON .)
    NULL            reduce using rule 261 (simple_stmt -> error SEMICOLON .)
    EXIT            reduce using rule 261 (simple_stmt -> error SEMICOLON .)
    RETURN          reduce using rule 261 (simple_stmt -> error SEMICOLON .)
    GOTO            reduce using rule 261 (simple_stmt -> error SEMICOLON .)
    DELAY           reduce using rule 261 (simple_stmt -> error SEMICOLON .)
    ABORT           reduce using rule 261 (simple_stmt -> error SEMICOLON .)
    RAISE           reduce using rule 261 (simple_stmt -> error SEMICOLON .)
    REQUEUE         reduce using rule 261 (simple_stmt -> error SEMICOLON .)
    IF              reduce using rule 261 (simple_stmt -> error SEMICOLON .)
    CASE            reduce using rule 261 (simple_stmt -> error SEMICOLON .)
    IDENTIFIER      reduce using rule 261 (simple_stmt -> error SEMICOLON .)
    ACCEPT          reduce using rule 261 (simple_stmt -> error SEMICOLON .)
    SELECT          reduce using rule 261 (simple_stmt -> error SEMICOLON .)
    STRING          reduce using rule 261 (simple_stmt -> error SEMICOLON .)
    WHILE           reduce using rule 261 (simple_stmt -> error SEMICOLON .)
    DECLARE         reduce using rule 261 (simple_stmt -> error SEMICOLON .)
    FOR             reduce using rule 261 (simple_stmt -> error SEMICOLON .)
    LOOP            reduce using rule 261 (simple_stmt -> error SEMICOLON .)
    BEGIN           reduce using rule 261 (simple_stmt -> error SEMICOLON .)
    END             reduce using rule 261 (simple_stmt -> error SEMICOLON .)
    OR              reduce using rule 261 (simple_stmt -> error SEMICOLON .)
    ELSE            reduce using rule 261 (simple_stmt -> error SEMICOLON .)
    ELSIF           reduce using rule 261 (simple_stmt -> error SEMICOLON .)
    THEN            reduce using rule 261 (simple_stmt -> error SEMICOLON .)
    WHEN            reduce using rule 261 (simple_stmt -> error SEMICOLON .)


state 462

    (269) NULL_stmt -> NULL SEMICOLON .

    EXCEPTION       reduce using rule 269 (NULL_stmt -> NULL SEMICOLON .)
    LLB             reduce using rule 269 (NULL_stmt -> NULL SEMICOLON .)
    error           reduce using rule 269 (NULL_stmt -> NULL SEMICOLON .)
    PRAGMA          reduce using rule 269 (NULL_stmt -> NULL SEMICOLON .)
    NULL            reduce using rule 269 (NULL_stmt -> NULL SEMICOLON .)
    EXIT            reduce using rule 269 (NULL_stmt -> NULL SEMICOLON .)
    RETURN          reduce using rule 269 (NULL_stmt -> NULL SEMICOLON .)
    GOTO            reduce using rule 269 (NULL_stmt -> NULL SEMICOLON .)
    DELAY           reduce using rule 269 (NULL_stmt -> NULL SEMICOLON .)
    ABORT           reduce using rule 269 (NULL_stmt -> NULL SEMICOLON .)
    RAISE           reduce using rule 269 (NULL_stmt -> NULL SEMICOLON .)
    REQUEUE         reduce using rule 269 (NULL_stmt -> NULL SEMICOLON .)
    IF              reduce using rule 269 (NULL_stmt -> NULL SEMICOLON .)
    CASE            reduce using rule 269 (NULL_stmt -> NULL SEMICOLON .)
    IDENTIFIER      reduce using rule 269 (NULL_stmt -> NULL SEMICOLON .)
    ACCEPT          reduce using rule 269 (NULL_stmt -> NULL SEMICOLON .)
    SELECT          reduce using rule 269 (NULL_stmt -> NULL SEMICOLON .)
    STRING          reduce using rule 269 (NULL_stmt -> NULL SEMICOLON .)
    WHILE           reduce using rule 269 (NULL_stmt -> NULL SEMICOLON .)
    DECLARE         reduce using rule 269 (NULL_stmt -> NULL SEMICOLON .)
    FOR             reduce using rule 269 (NULL_stmt -> NULL SEMICOLON .)
    LOOP            reduce using rule 269 (NULL_stmt -> NULL SEMICOLON .)
    BEGIN           reduce using rule 269 (NULL_stmt -> NULL SEMICOLON .)
    END             reduce using rule 269 (NULL_stmt -> NULL SEMICOLON .)
    OR              reduce using rule 269 (NULL_stmt -> NULL SEMICOLON .)
    ELSE            reduce using rule 269 (NULL_stmt -> NULL SEMICOLON .)
    ELSIF           reduce using rule 269 (NULL_stmt -> NULL SEMICOLON .)
    THEN            reduce using rule 269 (NULL_stmt -> NULL SEMICOLON .)
    WHEN            reduce using rule 269 (NULL_stmt -> NULL SEMICOLON .)


state 463

    (301) except_handler_part_opt -> except_handler_part .
    (457) except_handler_part -> except_handler_part . exception_handler
    (458) exception_handler -> . WHEN except_choice_s ARROW statement_s
    (459) exception_handler -> . WHEN IDENTIFIER COLON except_choice_s ARROW statement_s

    END             reduce using rule 301 (except_handler_part_opt -> except_handler_part .)
    WHEN            shift and go to state 586

    exception_handler              shift and go to state 585

state 464

    (299) handled_stmt_s -> statement_s except_handler_part_opt .

    END             reduce using rule 299 (handled_stmt_s -> statement_s except_handler_part_opt .)


state 465

    (244) statement_s -> statement_s statement .

    LLB             reduce using rule 244 (statement_s -> statement_s statement .)
    error           reduce using rule 244 (statement_s -> statement_s statement .)
    PRAGMA          reduce using rule 244 (statement_s -> statement_s statement .)
    NULL            reduce using rule 244 (statement_s -> statement_s statement .)
    EXIT            reduce using rule 244 (statement_s -> statement_s statement .)
    RETURN          reduce using rule 244 (statement_s -> statement_s statement .)
    GOTO            reduce using rule 244 (statement_s -> statement_s statement .)
    DELAY           reduce using rule 244 (statement_s -> statement_s statement .)
    ABORT           reduce using rule 244 (statement_s -> statement_s statement .)
    RAISE           reduce using rule 244 (statement_s -> statement_s statement .)
    REQUEUE         reduce using rule 244 (statement_s -> statement_s statement .)
    IF              reduce using rule 244 (statement_s -> statement_s statement .)
    CASE            reduce using rule 244 (statement_s -> statement_s statement .)
    IDENTIFIER      reduce using rule 244 (statement_s -> statement_s statement .)
    ACCEPT          reduce using rule 244 (statement_s -> statement_s statement .)
    SELECT          reduce using rule 244 (statement_s -> statement_s statement .)
    STRING          reduce using rule 244 (statement_s -> statement_s statement .)
    WHILE           reduce using rule 244 (statement_s -> statement_s statement .)
    DECLARE         reduce using rule 244 (statement_s -> statement_s statement .)
    FOR             reduce using rule 244 (statement_s -> statement_s statement .)
    LOOP            reduce using rule 244 (statement_s -> statement_s statement .)
    BEGIN           reduce using rule 244 (statement_s -> statement_s statement .)
    ELSE            reduce using rule 244 (statement_s -> statement_s statement .)
    ELSIF           reduce using rule 244 (statement_s -> statement_s statement .)
    END             reduce using rule 244 (statement_s -> statement_s statement .)
    WHEN            reduce using rule 244 (statement_s -> statement_s statement .)
    OR              reduce using rule 244 (statement_s -> statement_s statement .)
    EXCEPTION       reduce using rule 244 (statement_s -> statement_s statement .)
    THEN            reduce using rule 244 (statement_s -> statement_s statement .)


state 466

    (456) except_handler_part -> EXCEPTION . exception_handler
    (458) exception_handler -> . WHEN except_choice_s ARROW statement_s
    (459) exception_handler -> . WHEN IDENTIFIER COLON except_choice_s ARROW statement_s

    WHEN            shift and go to state 586

    exception_handler              shift and go to state 587

state 467

    (271) if_stmt -> IF cond_clause . else_opt END IF SEMICOLON
    (275) else_opt -> .
    (276) else_opt -> . ELSE statement_s
    (277) else_opt -> . ELSIF cond_clause else_opt

    END             reduce using rule 275 (else_opt -> .)
    ELSE            shift and go to state 588
    ELSIF           shift and go to state 590

    else_opt                       shift and go to state 589

state 468

    (272) cond_clause -> cond_part . statement_s
    (243) statement_s -> . statement
    (244) statement_s -> . statement_s statement
    (245) statement -> . unlabeled
    (246) statement -> . label statement
    (247) unlabeled -> . simple_stmt
    (248) unlabeled -> . compound_stmt
    (249) unlabeled -> . pragma
    (268) label -> . LLB IDENTIFIER RLB
    (250) simple_stmt -> . NULL_stmt
    (251) simple_stmt -> . assign_stmt
    (252) simple_stmt -> . exit_stmt
    (253) simple_stmt -> . return_stmt
    (254) simple_stmt -> . goto_stmt
    (255) simple_stmt -> . procedure_call
    (256) simple_stmt -> . delay_stmt
    (257) simple_stmt -> . abort_stmt
    (258) simple_stmt -> . raise_stmt
    (259) simple_stmt -> . code_stmt
    (260) simple_stmt -> . requeue_stmt
    (261) simple_stmt -> . error SEMICOLON
    (262) compound_stmt -> . if_stmt
    (263) compound_stmt -> . case_stmt
    (264) compound_stmt -> . loop_stmt
    (265) compound_stmt -> . block
    (266) compound_stmt -> . accept_stmt
    (267) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (269) NULL_stmt -> . NULL SEMICOLON
    (270) assign_stmt -> . name IS_ASSIGNED expression SEMICOLON
    (302) exit_stmt -> . EXIT name_opt when_opt SEMICOLON
    (307) return_stmt -> . RETURN SEMICOLON
    (308) return_stmt -> . RETURN expression SEMICOLON
    (309) goto_stmt -> . GOTO name SEMICOLON
    (332) procedure_call -> . name SEMICOLON
    (404) delay_stmt -> . DELAY expression SEMICOLON
    (405) delay_stmt -> . DELAY UNTIL expression SEMICOLON
    (425) abort_stmt -> . ABORT name_s SEMICOLON
    (464) raise_stmt -> . RAISE name_opt SEMICOLON
    (510) code_stmt -> . qualified SEMICOLON
    (465) requeue_stmt -> . REQUEUE name SEMICOLON
    (466) requeue_stmt -> . REQUEUE name WITH ABORT SEMICOLON
    (271) if_stmt -> . IF cond_clause else_opt END IF SEMICOLON
    (278) case_stmt -> . case_hdr alternative_s END CASE SEMICOLON
    (283) loop_stmt -> . label_opt iteration basic_loop id_opt SEMICOLON
    (295) block -> . label_opt block_decl block_body END id_opt SEMICOLON
    (399) accept_stmt -> . accept_hdr SEMICOLON
    (400) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt SEMICOLON
    (406) select_stmt -> . select_wait
    (407) select_stmt -> . async_select
    (408) select_stmt -> . timed_entry_call
    (409) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (240) qualified -> . name TICK parenthesized_primary
    (279) case_hdr -> . CASE expression IS
    (284) label_opt -> .
    (285) label_opt -> . IDENTIFIER COLON
    (401) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (410) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON
    (420) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON
    (421) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON
    (422) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    LLB             shift and go to state 289
    error           shift and go to state 309
    PRAGMA          shift and go to state 4
    NULL            shift and go to state 311
    EXIT            shift and go to state 308
    RETURN          shift and go to state 295
    GOTO            shift and go to state 276
    DELAY           shift and go to state 272
    ABORT           shift and go to state 282
    RAISE           shift and go to state 306
    REQUEUE         shift and go to state 298
    IF              shift and go to state 317
    CASE            shift and go to state 297
    WHILE           reduce using rule 284 (label_opt -> .)
    DECLARE         reduce using rule 284 (label_opt -> .)
    FOR             reduce using rule 284 (label_opt -> .)
    LOOP            reduce using rule 284 (label_opt -> .)
    BEGIN           reduce using rule 284 (label_opt -> .)
    IDENTIFIER      shift and go to state 300
    ACCEPT          shift and go to state 284
    SELECT          shift and go to state 286
    STRING          shift and go to state 137

    indexed_comp                   shift and go to state 119
    accept_stmt                    shift and go to state 283
    label_opt                      shift and go to state 275
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 316
    abort_stmt                     shift and go to state 310
    return_stmt                    shift and go to state 294
    procedure_call                 shift and go to state 285
    assign_stmt                    shift and go to state 320
    statement_s                    shift and go to state 591
    simple_name                    shift and go to state 153
    code_stmt                      shift and go to state 313
    case_stmt                      shift and go to state 287
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 146
    label                          shift and go to state 288
    exit_stmt                      shift and go to state 315
    select_stmt                    shift and go to state 274
    statement                      shift and go to state 299
    compound_stmt                  shift and go to state 290
    case_hdr                       shift and go to state 292
    delay_stmt                     shift and go to state 301
    unlabeled                      shift and go to state 314
    simple_stmt                    shift and go to state 277
    loop_stmt                      shift and go to state 278
    qualified                      shift and go to state 279
    pragma                         shift and go to state 303
    async_select                   shift and go to state 273
    requeue_stmt                   shift and go to state 304
    raise_stmt                     shift and go to state 305
    name                           shift and go to state 281
    if_stmt                        shift and go to state 280
    accept_hdr                     shift and go to state 302
    cond_entry_call                shift and go to state 318
    timed_entry_call               shift and go to state 307
    goto_stmt                      shift and go to state 291
    NULL_stmt                      shift and go to state 319
    block                          shift and go to state 293

state 469

    (273) cond_part -> condition . THEN

    THEN            shift and go to state 592


state 470

    (274) condition -> expression .
    (196) expression -> expression . logical relation
    (197) expression -> expression . short_circuit relation
    (198) logical -> . AND
    (199) logical -> . OR
    (200) logical -> . XOR
    (201) short_circuit -> . AND THEN
    (202) short_circuit -> . OR ELSE

    SEMICOLON       reduce using rule 274 (condition -> expression .)
    IS              reduce using rule 274 (condition -> expression .)
    THEN            reduce using rule 274 (condition -> expression .)
    ARROW           reduce using rule 274 (condition -> expression .)
    LOOP            reduce using rule 274 (condition -> expression .)
    AND             shift and go to state 244
    OR              shift and go to state 248
    XOR             shift and go to state 245

    logical                        shift and go to state 246
    short_circuit                  shift and go to state 247

state 471

    (294) id_opt -> designator .

    SEMICOLON       reduce using rule 294 (id_opt -> designator .)


state 472

    (331) subprog_body -> subprog_spec_is_push decl_part block_body END id_opt . SEMICOLON

    SEMICOLON       shift and go to state 593


state 473

    (504) record_type_spec -> FOR mark USE RECORD . align_opt comp_loc_s END RECORD SEMICOLON
    (505) align_opt -> .
    (506) align_opt -> . AT MOD expression SEMICOLON

    END             reduce using rule 505 (align_opt -> .)
    IDENTIFIER      reduce using rule 505 (align_opt -> .)
    AT              shift and go to state 595

    align_opt                      shift and go to state 594

state 474

    (509) address_spec -> FOR mark USE AT . expression SEMICOLON
    (195) expression -> . relation
    (196) expression -> . expression logical relation
    (197) expression -> . expression short_circuit relation
    (203) relation -> . simple_expression
    (204) relation -> . simple_expression relational simple_expression
    (205) relation -> . simple_expression membership range
    (206) relation -> . simple_expression membership name
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    relation                       shift and go to state 127
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    factor                         shift and go to state 136
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    term                           shift and go to state 144
    name                           shift and go to state 145
    operator_symbol                shift and go to state 146
    expression                     shift and go to state 596

state 475

    (503) attrib_def -> FOR mark USE expression . SEMICOLON
    (196) expression -> expression . logical relation
    (197) expression -> expression . short_circuit relation
    (198) logical -> . AND
    (199) logical -> . OR
    (200) logical -> . XOR
    (201) short_circuit -> . AND THEN
    (202) short_circuit -> . OR ELSE

    SEMICOLON       shift and go to state 597
    AND             shift and go to state 244
    OR              shift and go to state 248
    XOR             shift and go to state 245

    short_circuit                  shift and go to state 247
    logical                        shift and go to state 246

state 476

    (159) mark -> mark TICK attribute_id .

    TICK            reduce using rule 159 (mark -> mark TICK attribute_id .)
    DOT             reduce using rule 159 (mark -> mark TICK attribute_id .)
    IS_ASSIGNED     reduce using rule 159 (mark -> mark TICK attribute_id .)
    SEMICOLON       reduce using rule 159 (mark -> mark TICK attribute_id .)
    RPAREN          reduce using rule 159 (mark -> mark TICK attribute_id .)
    USE             reduce using rule 159 (mark -> mark TICK attribute_id .)
    AT              reduce using rule 159 (mark -> mark TICK attribute_id .)


state 477

    (160) mark -> mark DOT simple_name .

    TICK            reduce using rule 160 (mark -> mark DOT simple_name .)
    DOT             reduce using rule 160 (mark -> mark DOT simple_name .)
    IS_ASSIGNED     reduce using rule 160 (mark -> mark DOT simple_name .)
    SEMICOLON       reduce using rule 160 (mark -> mark DOT simple_name .)
    RPAREN          reduce using rule 160 (mark -> mark DOT simple_name .)
    USE             reduce using rule 160 (mark -> mark DOT simple_name .)
    AT              reduce using rule 160 (mark -> mark DOT simple_name .)


state 478

    (365) task_body -> TASK BODY simple_name IS . decl_part block_body END id_opt SEMICOLON
    (451) body_stub -> TASK BODY simple_name IS . SEPARATE SEMICOLON
    (135) decl_part -> .
    (136) decl_part -> . decl_item_or_body_s1
    (145) decl_item_or_body_s1 -> . decl_item_or_body
    (146) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (147) decl_item_or_body -> . body
    (148) decl_item_or_body -> . decl_item
    (149) body -> . subprog_body
    (150) body -> . pkg_body
    (151) body -> . task_body
    (152) body -> . prot_body
    (141) decl_item -> . decl
    (142) decl_item -> . use_clause
    (143) decl_item -> . rep_spec
    (144) decl_item -> . pragma
    (331) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt SEMICOLON
    (340) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt SEMICOLON
    (365) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt SEMICOLON
    (382) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt SEMICOLON
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error SEMICOLON
    (346) use_clause -> . USE name_s SEMICOLON
    (347) use_clause -> . USE TYPE name_s SEMICOLON
    (500) rep_spec -> . attrib_def
    (501) rep_spec -> . record_type_spec
    (502) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (330) subprog_spec_is_push -> . subprog_spec IS
    (23) object_decl -> . def_id_s COLON object_qualifier_opt object_subtype_def init_opt SEMICOLON
    (35) number_decl -> . def_id_s COLON CONSTANT IS_ASSIGNED expression SEMICOLON
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion SEMICOLON
    (48) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind SEMICOLON
    (310) subprog_decl -> . subprog_spec SEMICOLON
    (311) subprog_decl -> . generic_subp_inst SEMICOLON
    (312) subprog_decl -> . subprog_spec_is_push ABSTRACT SEMICOLON
    (333) pkg_decl -> . pkg_spec SEMICOLON
    (334) pkg_decl -> . generic_pkg_inst SEMICOLON
    (358) task_decl -> . task_spec SEMICOLON
    (366) prot_decl -> . prot_spec SEMICOLON
    (455) exception_decl -> . def_id_s COLON EXCEPTION SEMICOLON
    (350) rename_decl -> . def_id_s COLON object_qualifier_opt subtype_ind renames SEMICOLON
    (351) rename_decl -> . def_id_s COLON EXCEPTION renames SEMICOLON
    (352) rename_decl -> . rename_unit
    (467) generic_decl -> . generic_formal_part subprog_spec SEMICOLON
    (468) generic_decl -> . generic_formal_part pkg_spec SEMICOLON
    (451) body_stub -> . TASK BODY simple_name IS SEPARATE SEMICOLON
    (452) body_stub -> . PACKAGE BODY compound_name IS SEPARATE SEMICOLON
    (453) body_stub -> . subprog_spec IS SEPARATE SEMICOLON
    (454) body_stub -> . PROTECTED BODY simple_name IS SEPARATE SEMICOLON
    (503) attrib_def -> . FOR mark USE expression SEMICOLON
    (504) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD SEMICOLON
    (509) address_spec -> . FOR mark USE AT expression SEMICOLON
    (313) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (314) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (315) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s COMMA def_id
    (497) generic_subp_inst -> . subprog_spec IS generic_inst
    (335) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (498) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (359) task_spec -> . TASK simple_name task_def
    (360) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (367) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (368) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (353) rename_unit -> . PACKAGE compound_name renames SEMICOLON
    (354) rename_unit -> . subprog_spec renames SEMICOLON
    (355) rename_unit -> . generic_formal_part PACKAGE compound_name renames SEMICOLON
    (356) rename_unit -> . generic_formal_part subprog_spec renames SEMICOLON
    (469) generic_formal_part -> . GENERIC
    (470) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    SEPARATE        shift and go to state 598
    BEGIN           reduce using rule 135 (decl_part -> .)
    PACKAGE         shift and go to state 80
    TASK            shift and go to state 74
    PROTECTED       shift and go to state 58
    error           shift and go to state 85
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 87
    SUBTYPE         shift and go to state 91
    FOR             shift and go to state 70
    PROCEDURE       shift and go to state 30
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 79

    decl                           shift and go to state 57
    subprog_body                   shift and go to state 66
    task_decl                      shift and go to state 67
    type_decl                      shift and go to state 63
    rep_spec                       shift and go to state 89
    task_body                      shift and go to state 90
    subtype_decl                   shift and go to state 68
    exception_decl                 shift and go to state 92
    address_spec                   shift and go to state 59
    decl_item                      shift and go to state 60
    subprog_spec_is_push           shift and go to state 93
    decl_part                      shift and go to state 599
    prot_decl                      shift and go to state 62
    record_type_spec               shift and go to state 75
    generic_decl                   shift and go to state 76
    def_id                         shift and go to state 96
    attrib_def                     shift and go to state 77
    subprog_spec                   shift and go to state 94
    def_id_s                       shift and go to state 95
    decl_item_or_body_s1           shift and go to state 78
    task_spec                      shift and go to state 72
    body                           shift and go to state 69
    object_decl                    shift and go to state 71
    body_stub                      shift and go to state 81
    pkg_spec                       shift and go to state 37
    rename_decl                    shift and go to state 97
    generic_subp_inst              shift and go to state 28
    pragma                         shift and go to state 82
    rename_unit                    shift and go to state 98
    subprog_decl                   shift and go to state 65
    pkg_decl                       shift and go to state 64
    prot_spec                      shift and go to state 83
    generic_formal_part            shift and go to state 33
    prot_body                      shift and go to state 99
    use_clause                     shift and go to state 73
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 84
    decl_item_or_body              shift and go to state 86
    number_decl                    shift and go to state 100

state 479

    (360) task_spec -> TASK TYPE simple_name discrim_part_opt . task_def
    (361) task_def -> .
    (362) task_def -> . IS entry_decl_s rep_spec_s task_private_opt END id_opt

    SEMICOLON       reduce using rule 361 (task_def -> .)
    IS              shift and go to state 327

    task_def                       shift and go to state 600

state 480

    (362) task_def -> IS entry_decl_s . rep_spec_s task_private_opt END id_opt
    (389) entry_decl_s -> entry_decl_s . entry_decl pragma_s
    (396) rep_spec_s -> .
    (397) rep_spec_s -> . rep_spec_s rep_spec pragma_s
    (390) entry_decl -> . ENTRY IDENTIFIER formal_part_opt SEMICOLON
    (391) entry_decl -> . ENTRY IDENTIFIER LPAREN discrete_range RPAREN formal_part_opt SEMICOLON

    PRIVATE         reduce using rule 396 (rep_spec_s -> .)
    FOR             reduce using rule 396 (rep_spec_s -> .)
    END             reduce using rule 396 (rep_spec_s -> .)
    ENTRY           shift and go to state 547

    rep_spec_s                     shift and go to state 601
    entry_decl                     shift and go to state 602

state 481

    (388) entry_decl_s -> pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON

    ENTRY           reduce using rule 388 (entry_decl_s -> pragma_s .)
    FOR             reduce using rule 388 (entry_decl_s -> pragma_s .)
    END             reduce using rule 388 (entry_decl_s -> pragma_s .)
    PRIVATE         reduce using rule 388 (entry_decl_s -> pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 482

    (340) pkg_body -> PACKAGE BODY compound_name IS . decl_part body_opt END c_id_opt SEMICOLON
    (452) body_stub -> PACKAGE BODY compound_name IS . SEPARATE SEMICOLON
    (135) decl_part -> .
    (136) decl_part -> . decl_item_or_body_s1
    (145) decl_item_or_body_s1 -> . decl_item_or_body
    (146) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (147) decl_item_or_body -> . body
    (148) decl_item_or_body -> . decl_item
    (149) body -> . subprog_body
    (150) body -> . pkg_body
    (151) body -> . task_body
    (152) body -> . prot_body
    (141) decl_item -> . decl
    (142) decl_item -> . use_clause
    (143) decl_item -> . rep_spec
    (144) decl_item -> . pragma
    (331) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt SEMICOLON
    (340) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt SEMICOLON
    (365) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt SEMICOLON
    (382) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt SEMICOLON
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error SEMICOLON
    (346) use_clause -> . USE name_s SEMICOLON
    (347) use_clause -> . USE TYPE name_s SEMICOLON
    (500) rep_spec -> . attrib_def
    (501) rep_spec -> . record_type_spec
    (502) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (330) subprog_spec_is_push -> . subprog_spec IS
    (23) object_decl -> . def_id_s COLON object_qualifier_opt object_subtype_def init_opt SEMICOLON
    (35) number_decl -> . def_id_s COLON CONSTANT IS_ASSIGNED expression SEMICOLON
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion SEMICOLON
    (48) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind SEMICOLON
    (310) subprog_decl -> . subprog_spec SEMICOLON
    (311) subprog_decl -> . generic_subp_inst SEMICOLON
    (312) subprog_decl -> . subprog_spec_is_push ABSTRACT SEMICOLON
    (333) pkg_decl -> . pkg_spec SEMICOLON
    (334) pkg_decl -> . generic_pkg_inst SEMICOLON
    (358) task_decl -> . task_spec SEMICOLON
    (366) prot_decl -> . prot_spec SEMICOLON
    (455) exception_decl -> . def_id_s COLON EXCEPTION SEMICOLON
    (350) rename_decl -> . def_id_s COLON object_qualifier_opt subtype_ind renames SEMICOLON
    (351) rename_decl -> . def_id_s COLON EXCEPTION renames SEMICOLON
    (352) rename_decl -> . rename_unit
    (467) generic_decl -> . generic_formal_part subprog_spec SEMICOLON
    (468) generic_decl -> . generic_formal_part pkg_spec SEMICOLON
    (451) body_stub -> . TASK BODY simple_name IS SEPARATE SEMICOLON
    (452) body_stub -> . PACKAGE BODY compound_name IS SEPARATE SEMICOLON
    (453) body_stub -> . subprog_spec IS SEPARATE SEMICOLON
    (454) body_stub -> . PROTECTED BODY simple_name IS SEPARATE SEMICOLON
    (503) attrib_def -> . FOR mark USE expression SEMICOLON
    (504) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD SEMICOLON
    (509) address_spec -> . FOR mark USE AT expression SEMICOLON
    (313) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (314) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (315) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s COMMA def_id
    (497) generic_subp_inst -> . subprog_spec IS generic_inst
    (335) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (498) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (359) task_spec -> . TASK simple_name task_def
    (360) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (367) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (368) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (353) rename_unit -> . PACKAGE compound_name renames SEMICOLON
    (354) rename_unit -> . subprog_spec renames SEMICOLON
    (355) rename_unit -> . generic_formal_part PACKAGE compound_name renames SEMICOLON
    (356) rename_unit -> . generic_formal_part subprog_spec renames SEMICOLON
    (469) generic_formal_part -> . GENERIC
    (470) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    SEPARATE        shift and go to state 603
    BEGIN           reduce using rule 135 (decl_part -> .)
    END             reduce using rule 135 (decl_part -> .)
    PACKAGE         shift and go to state 80
    TASK            shift and go to state 74
    PROTECTED       shift and go to state 58
    error           shift and go to state 85
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 87
    SUBTYPE         shift and go to state 91
    FOR             shift and go to state 70
    PROCEDURE       shift and go to state 30
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 79

    decl                           shift and go to state 57
    subprog_body                   shift and go to state 66
    task_decl                      shift and go to state 67
    type_decl                      shift and go to state 63
    rep_spec                       shift and go to state 89
    task_body                      shift and go to state 90
    subtype_decl                   shift and go to state 68
    exception_decl                 shift and go to state 92
    address_spec                   shift and go to state 59
    subprog_spec_is_push           shift and go to state 93
    decl_part                      shift and go to state 409
    prot_decl                      shift and go to state 62
    record_type_spec               shift and go to state 75
    generic_decl                   shift and go to state 76
    def_id                         shift and go to state 96
    attrib_def                     shift and go to state 77
    subprog_spec                   shift and go to state 94
    def_id_s                       shift and go to state 95
    decl_item_or_body_s1           shift and go to state 78
    decl_item                      shift and go to state 60
    task_spec                      shift and go to state 72
    body                           shift and go to state 69
    object_decl                    shift and go to state 71
    body_stub                      shift and go to state 81
    pkg_spec                       shift and go to state 37
    rename_decl                    shift and go to state 97
    generic_subp_inst              shift and go to state 28
    pragma                         shift and go to state 82
    rename_unit                    shift and go to state 98
    subprog_decl                   shift and go to state 65
    pkg_decl                       shift and go to state 64
    prot_spec                      shift and go to state 83
    generic_formal_part            shift and go to state 33
    prot_body                      shift and go to state 99
    use_clause                     shift and go to state 73
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 84
    decl_item_or_body              shift and go to state 86
    number_decl                    shift and go to state 100

state 483

    (41) type_completion -> IS . type_def
    (42) type_def -> . enumeration_type
    (43) type_def -> . integer_type
    (44) type_def -> . real_type
    (45) type_def -> . array_type
    (46) type_def -> . record_type
    (47) type_def -> . access_type
    (63) enumeration_type -> . LPAREN enum_id_s RPAREN
    (68) integer_type -> . range_spec
    (69) integer_type -> . MOD expression
    (73) real_type -> . float_type
    (74) real_type -> . fixed_type
    (78) array_type -> . unconstr_array_type
    (79) array_type -> . constr_array_type
    (95) record_type -> . tagged_opt limited_opt record_def
    (128) access_type -> . ACCESS subtype_ind
    (129) access_type -> . ACCESS CONSTANT subtype_ind
    (130) access_type -> . ACCESS ALL subtype_ind
    (131) access_type -> . ACCESS prot_opt PROCEDURE formal_part_opt
    (132) access_type -> . ACCESS prot_opt FUNCTION formal_part_opt RETURN mark
    (70) range_spec -> . range_constraint
    (75) float_type -> . DIGITS expression range_spec_opt
    (76) fixed_type -> . DELTA expression range_spec
    (77) fixed_type -> . DELTA expression DIGITS expression range_spec_opt
    (80) unconstr_array_type -> . ARRAY LPAREN index_s RPAREN OF component_subtype_def
    (81) constr_array_type -> . ARRAY iter_index_constraint OF component_subtype_def
    (98) tagged_opt -> .
    (99) tagged_opt -> . TAGGED
    (100) tagged_opt -> . ABSTRACT TAGGED
    (59) range_constraint -> . RANGE range

    LPAREN          shift and go to state 616
    MOD             shift and go to state 622
    ACCESS          shift and go to state 620
    DIGITS          shift and go to state 610
    DELTA           shift and go to state 614
    ARRAY           shift and go to state 497
    LIMITED         reduce using rule 98 (tagged_opt -> .)
    RECORD          reduce using rule 98 (tagged_opt -> .)
    NULL            reduce using rule 98 (tagged_opt -> .)
    TAGGED          shift and go to state 613
    ABSTRACT        shift and go to state 604
    RANGE           shift and go to state 371

    access_type                    shift and go to state 605
    record_type                    shift and go to state 606
    real_type                      shift and go to state 607
    range_constraint               shift and go to state 608
    enumeration_type               shift and go to state 609
    float_type                     shift and go to state 611
    tagged_opt                     shift and go to state 612
    integer_type                   shift and go to state 615
    array_type                     shift and go to state 617
    range_spec                     shift and go to state 618
    type_def                       shift and go to state 619
    constr_array_type              shift and go to state 500
    fixed_type                     shift and go to state 621
    unconstr_array_type            shift and go to state 502

state 484

    (36) type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion . SEMICOLON

    SEMICOLON       shift and go to state 623


state 485

    (39) discrim_part_opt -> LPAREN BOX . RPAREN

    RPAREN          shift and go to state 624


state 486

    (111) discrim_spec_s -> discrim_spec .

    RPAREN          reduce using rule 111 (discrim_spec_s -> discrim_spec .)
    SEMICOLON       reduce using rule 111 (discrim_spec_s -> discrim_spec .)


state 487

    (110) discrim_part -> LPAREN discrim_spec_s . RPAREN
    (112) discrim_spec_s -> discrim_spec_s . SEMICOLON discrim_spec

    RPAREN          shift and go to state 626
    SEMICOLON       shift and go to state 625


state 488

    (113) discrim_spec -> def_id_s . COLON access_opt mark init_opt
    (25) def_id_s -> def_id_s . COMMA def_id

    COLON           shift and go to state 627
    COMMA           shift and go to state 186


state 489

    (114) discrim_spec -> error .

    RPAREN          reduce using rule 114 (discrim_spec -> error .)
    SEMICOLON       reduce using rule 114 (discrim_spec -> error .)


state 490

    (49) subtype_ind -> name . constraint
    (50) subtype_ind -> name .
    (168) indexed_comp -> name . LPAREN value_s RPAREN
    (175) selected_comp -> name . DOT simple_name
    (176) selected_comp -> name . DOT used_char
    (177) selected_comp -> name . DOT operator_symbol
    (178) selected_comp -> name . DOT ALL
    (179) attribute -> name . TICK attribute_id
    (51) constraint -> . range_constraint
    (52) constraint -> . decimal_digits_constraint
    (59) range_constraint -> . RANGE range
    (53) decimal_digits_constraint -> . DIGITS expression range_constr_opt

    SEMICOLON       reduce using rule 50 (subtype_ind -> name .)
    RENAMES         reduce using rule 50 (subtype_ind -> name .)
    IS_ASSIGNED     reduce using rule 50 (subtype_ind -> name .)
    WITH            reduce using rule 50 (subtype_ind -> name .)
    LPAREN          shift and go to state 240
    DOT             shift and go to state 242
    TICK            shift and go to state 251
    RANGE           shift and go to state 371
    DIGITS          shift and go to state 628

    constraint                     shift and go to state 629
    range_constraint               shift and go to state 630
    decimal_digits_constraint      shift and go to state 631

state 491

    (48) subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind . SEMICOLON

    SEMICOLON       shift and go to state 632


state 492

    (453) body_stub -> subprog_spec IS SEPARATE SEMICOLON .

    PACKAGE         reduce using rule 453 (body_stub -> subprog_spec IS SEPARATE SEMICOLON .)
    TASK            reduce using rule 453 (body_stub -> subprog_spec IS SEPARATE SEMICOLON .)
    PROTECTED       reduce using rule 453 (body_stub -> subprog_spec IS SEPARATE SEMICOLON .)
    error           reduce using rule 453 (body_stub -> subprog_spec IS SEPARATE SEMICOLON .)
    USE             reduce using rule 453 (body_stub -> subprog_spec IS SEPARATE SEMICOLON .)
    PRAGMA          reduce using rule 453 (body_stub -> subprog_spec IS SEPARATE SEMICOLON .)
    TYPE            reduce using rule 453 (body_stub -> subprog_spec IS SEPARATE SEMICOLON .)
    SUBTYPE         reduce using rule 453 (body_stub -> subprog_spec IS SEPARATE SEMICOLON .)
    FOR             reduce using rule 453 (body_stub -> subprog_spec IS SEPARATE SEMICOLON .)
    PROCEDURE       reduce using rule 453 (body_stub -> subprog_spec IS SEPARATE SEMICOLON .)
    FUNCTION        reduce using rule 453 (body_stub -> subprog_spec IS SEPARATE SEMICOLON .)
    GENERIC         reduce using rule 453 (body_stub -> subprog_spec IS SEPARATE SEMICOLON .)
    IDENTIFIER      reduce using rule 453 (body_stub -> subprog_spec IS SEPARATE SEMICOLON .)
    BEGIN           reduce using rule 453 (body_stub -> subprog_spec IS SEPARATE SEMICOLON .)
    END             reduce using rule 453 (body_stub -> subprog_spec IS SEPARATE SEMICOLON .)
    PRIVATE         reduce using rule 453 (body_stub -> subprog_spec IS SEPARATE SEMICOLON .)


state 493

    (35) number_decl -> def_id_s COLON CONSTANT IS_ASSIGNED . expression SEMICOLON
    (195) expression -> . relation
    (196) expression -> . expression logical relation
    (197) expression -> . expression short_circuit relation
    (203) relation -> . simple_expression
    (204) relation -> . simple_expression relational simple_expression
    (205) relation -> . simple_expression membership range
    (206) relation -> . simple_expression membership name
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    relation                       shift and go to state 127
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    factor                         shift and go to state 136
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    term                           shift and go to state 144
    name                           shift and go to state 145
    operator_symbol                shift and go to state 146
    expression                     shift and go to state 633

state 494

    (455) exception_decl -> def_id_s COLON EXCEPTION SEMICOLON .

    PACKAGE         reduce using rule 455 (exception_decl -> def_id_s COLON EXCEPTION SEMICOLON .)
    TASK            reduce using rule 455 (exception_decl -> def_id_s COLON EXCEPTION SEMICOLON .)
    PROTECTED       reduce using rule 455 (exception_decl -> def_id_s COLON EXCEPTION SEMICOLON .)
    error           reduce using rule 455 (exception_decl -> def_id_s COLON EXCEPTION SEMICOLON .)
    USE             reduce using rule 455 (exception_decl -> def_id_s COLON EXCEPTION SEMICOLON .)
    PRAGMA          reduce using rule 455 (exception_decl -> def_id_s COLON EXCEPTION SEMICOLON .)
    TYPE            reduce using rule 455 (exception_decl -> def_id_s COLON EXCEPTION SEMICOLON .)
    SUBTYPE         reduce using rule 455 (exception_decl -> def_id_s COLON EXCEPTION SEMICOLON .)
    FOR             reduce using rule 455 (exception_decl -> def_id_s COLON EXCEPTION SEMICOLON .)
    PROCEDURE       reduce using rule 455 (exception_decl -> def_id_s COLON EXCEPTION SEMICOLON .)
    FUNCTION        reduce using rule 455 (exception_decl -> def_id_s COLON EXCEPTION SEMICOLON .)
    GENERIC         reduce using rule 455 (exception_decl -> def_id_s COLON EXCEPTION SEMICOLON .)
    IDENTIFIER      reduce using rule 455 (exception_decl -> def_id_s COLON EXCEPTION SEMICOLON .)
    BEGIN           reduce using rule 455 (exception_decl -> def_id_s COLON EXCEPTION SEMICOLON .)
    END             reduce using rule 455 (exception_decl -> def_id_s COLON EXCEPTION SEMICOLON .)
    PRIVATE         reduce using rule 455 (exception_decl -> def_id_s COLON EXCEPTION SEMICOLON .)


state 495

    (351) rename_decl -> def_id_s COLON EXCEPTION renames . SEMICOLON

    SEMICOLON       shift and go to state 634


state 496

    (30) object_qualifier_opt -> ALIASED CONSTANT .

    ARRAY           reduce using rule 30 (object_qualifier_opt -> ALIASED CONSTANT .)
    IDENTIFIER      reduce using rule 30 (object_qualifier_opt -> ALIASED CONSTANT .)
    STRING          reduce using rule 30 (object_qualifier_opt -> ALIASED CONSTANT .)


state 497

    (80) unconstr_array_type -> ARRAY . LPAREN index_s RPAREN OF component_subtype_def
    (81) constr_array_type -> ARRAY . iter_index_constraint OF component_subtype_def
    (88) iter_index_constraint -> . LPAREN iter_discrete_range_s RPAREN

    LPAREN          shift and go to state 636

    iter_index_constraint          shift and go to state 635

state 498

    (32) object_subtype_def -> array_type .

    IS_ASSIGNED     reduce using rule 32 (object_subtype_def -> array_type .)
    SEMICOLON       reduce using rule 32 (object_subtype_def -> array_type .)


state 499

    (23) object_decl -> def_id_s COLON object_qualifier_opt object_subtype_def . init_opt SEMICOLON
    (33) init_opt -> .
    (34) init_opt -> . IS_ASSIGNED expression

    SEMICOLON       reduce using rule 33 (init_opt -> .)
    IS_ASSIGNED     shift and go to state 637

    init_opt                       shift and go to state 638

state 500

    (79) array_type -> constr_array_type .

    SEMICOLON       reduce using rule 79 (array_type -> constr_array_type .)
    IS_ASSIGNED     reduce using rule 79 (array_type -> constr_array_type .)


state 501

    (350) rename_decl -> def_id_s COLON object_qualifier_opt subtype_ind . renames SEMICOLON
    (31) object_subtype_def -> subtype_ind .
    (357) renames -> . RENAMES name

    IS_ASSIGNED     reduce using rule 31 (object_subtype_def -> subtype_ind .)
    SEMICOLON       reduce using rule 31 (object_subtype_def -> subtype_ind .)
    RENAMES         shift and go to state 51

    renames                        shift and go to state 639

state 502

    (78) array_type -> unconstr_array_type .

    SEMICOLON       reduce using rule 78 (array_type -> unconstr_array_type .)
    IS_ASSIGNED     reduce using rule 78 (array_type -> unconstr_array_type .)


state 503

    (474) generic_formal -> WITH FUNCTION designator formal_part_opt . RETURN name subp_default SEMICOLON

    RETURN          shift and go to state 640


state 504

    (475) generic_formal -> WITH PACKAGE simple_name IS . NEW name LPAREN BOX RPAREN SEMICOLON
    (476) generic_formal -> WITH PACKAGE simple_name IS . NEW name SEMICOLON

    NEW             shift and go to state 641


state 505

    (473) generic_formal -> WITH PROCEDURE simple_name formal_part_opt . subp_default SEMICOLON
    (481) subp_default -> .
    (482) subp_default -> . IS name
    (483) subp_default -> . IS BOX

    SEMICOLON       reduce using rule 481 (subp_default -> .)
    IS              shift and go to state 642

    subp_default                   shift and go to state 643

state 506

    (328) mode -> IN OUT .

    IDENTIFIER      reduce using rule 328 (mode -> IN OUT .)


state 507

    (323) param -> def_id_s COLON mode mark . init_opt
    (159) mark -> mark . TICK attribute_id
    (160) mark -> mark . DOT simple_name
    (33) init_opt -> .
    (34) init_opt -> . IS_ASSIGNED expression

    TICK            shift and go to state 323
    DOT             shift and go to state 324
    SEMICOLON       reduce using rule 33 (init_opt -> .)
    RPAREN          reduce using rule 33 (init_opt -> .)
    IS_ASSIGNED     shift and go to state 637

    init_opt                       shift and go to state 644

state 508

    (355) rename_unit -> generic_formal_part PACKAGE compound_name renames SEMICOLON .

    PACKAGE         reduce using rule 355 (rename_unit -> generic_formal_part PACKAGE compound_name renames SEMICOLON .)
    TASK            reduce using rule 355 (rename_unit -> generic_formal_part PACKAGE compound_name renames SEMICOLON .)
    PROTECTED       reduce using rule 355 (rename_unit -> generic_formal_part PACKAGE compound_name renames SEMICOLON .)
    error           reduce using rule 355 (rename_unit -> generic_formal_part PACKAGE compound_name renames SEMICOLON .)
    USE             reduce using rule 355 (rename_unit -> generic_formal_part PACKAGE compound_name renames SEMICOLON .)
    PRAGMA          reduce using rule 355 (rename_unit -> generic_formal_part PACKAGE compound_name renames SEMICOLON .)
    TYPE            reduce using rule 355 (rename_unit -> generic_formal_part PACKAGE compound_name renames SEMICOLON .)
    SUBTYPE         reduce using rule 355 (rename_unit -> generic_formal_part PACKAGE compound_name renames SEMICOLON .)
    FOR             reduce using rule 355 (rename_unit -> generic_formal_part PACKAGE compound_name renames SEMICOLON .)
    PROCEDURE       reduce using rule 355 (rename_unit -> generic_formal_part PACKAGE compound_name renames SEMICOLON .)
    FUNCTION        reduce using rule 355 (rename_unit -> generic_formal_part PACKAGE compound_name renames SEMICOLON .)
    GENERIC         reduce using rule 355 (rename_unit -> generic_formal_part PACKAGE compound_name renames SEMICOLON .)
    IDENTIFIER      reduce using rule 355 (rename_unit -> generic_formal_part PACKAGE compound_name renames SEMICOLON .)
    BEGIN           reduce using rule 355 (rename_unit -> generic_formal_part PACKAGE compound_name renames SEMICOLON .)
    PRIVATE         reduce using rule 355 (rename_unit -> generic_formal_part PACKAGE compound_name renames SEMICOLON .)
    END             reduce using rule 355 (rename_unit -> generic_formal_part PACKAGE compound_name renames SEMICOLON .)
    WITH            reduce using rule 355 (rename_unit -> generic_formal_part PACKAGE compound_name renames SEMICOLON .)
    SEPARATE        reduce using rule 355 (rename_unit -> generic_formal_part PACKAGE compound_name renames SEMICOLON .)
    $end            reduce using rule 355 (rename_unit -> generic_formal_part PACKAGE compound_name renames SEMICOLON .)


state 509

    (472) generic_formal -> TYPE simple_name generic_discrim_part_opt IS . generic_type_def SEMICOLON
    (484) generic_type_def -> . LPAREN BOX RPAREN
    (485) generic_type_def -> . RANGE BOX
    (486) generic_type_def -> . MOD BOX
    (487) generic_type_def -> . DELTA BOX
    (488) generic_type_def -> . DELTA BOX DIGITS BOX
    (489) generic_type_def -> . DIGITS BOX
    (490) generic_type_def -> . array_type
    (491) generic_type_def -> . access_type
    (492) generic_type_def -> . private_type
    (493) generic_type_def -> . generic_derived_type
    (78) array_type -> . unconstr_array_type
    (79) array_type -> . constr_array_type
    (128) access_type -> . ACCESS subtype_ind
    (129) access_type -> . ACCESS CONSTANT subtype_ind
    (130) access_type -> . ACCESS ALL subtype_ind
    (131) access_type -> . ACCESS prot_opt PROCEDURE formal_part_opt
    (132) access_type -> . ACCESS prot_opt FUNCTION formal_part_opt RETURN mark
    (343) private_type -> . tagged_opt limited_opt PRIVATE
    (494) generic_derived_type -> . NEW subtype_ind
    (495) generic_derived_type -> . NEW subtype_ind WITH PRIVATE
    (496) generic_derived_type -> . ABSTRACT NEW subtype_ind WITH PRIVATE
    (80) unconstr_array_type -> . ARRAY LPAREN index_s RPAREN OF component_subtype_def
    (81) constr_array_type -> . ARRAY iter_index_constraint OF component_subtype_def
    (98) tagged_opt -> .
    (99) tagged_opt -> . TAGGED
    (100) tagged_opt -> . ABSTRACT TAGGED

    LPAREN          shift and go to state 654
    RANGE           shift and go to state 652
    MOD             shift and go to state 657
    DELTA           shift and go to state 656
    DIGITS          shift and go to state 649
    ACCESS          shift and go to state 620
    NEW             shift and go to state 647
    ABSTRACT        shift and go to state 645
    ARRAY           shift and go to state 497
    LIMITED         reduce using rule 98 (tagged_opt -> .)
    PRIVATE         reduce using rule 98 (tagged_opt -> .)
    TAGGED          shift and go to state 613

    private_type                   shift and go to state 651
    tagged_opt                     shift and go to state 650
    constr_array_type              shift and go to state 500
    access_type                    shift and go to state 653
    generic_derived_type           shift and go to state 648
    generic_type_def               shift and go to state 646
    array_type                     shift and go to state 655
    unconstr_array_type            shift and go to state 502

state 510

    (480) generic_discrim_part_opt -> LPAREN BOX . RPAREN

    RPAREN          shift and go to state 658


state 511

    (314) subprog_spec -> FUNCTION designator formal_part_opt RETURN name .
    (168) indexed_comp -> name . LPAREN value_s RPAREN
    (175) selected_comp -> name . DOT simple_name
    (176) selected_comp -> name . DOT used_char
    (177) selected_comp -> name . DOT operator_symbol
    (178) selected_comp -> name . DOT ALL
    (179) attribute -> name . TICK attribute_id

    SEMICOLON       reduce using rule 314 (subprog_spec -> FUNCTION designator formal_part_opt RETURN name .)
    IS              reduce using rule 314 (subprog_spec -> FUNCTION designator formal_part_opt RETURN name .)
    RENAMES         reduce using rule 314 (subprog_spec -> FUNCTION designator formal_part_opt RETURN name .)
    LPAREN          shift and go to state 240
    DOT             shift and go to state 242
    TICK            shift and go to state 251


state 512

    (60) range -> simple_expression DOUBLEDOT simple_expression .
    (217) simple_expression -> simple_expression . adding term
    (220) adding -> . PLUS
    (221) adding -> . MINUS
    (222) adding -> . AMPERSAND

    RPAREN          reduce using rule 60 (range -> simple_expression DOUBLEDOT simple_expression .)
    COMMA           reduce using rule 60 (range -> simple_expression DOUBLEDOT simple_expression .)
    ARROW           reduce using rule 60 (range -> simple_expression DOUBLEDOT simple_expression .)
    |               reduce using rule 60 (range -> simple_expression DOUBLEDOT simple_expression .)
    SEMICOLON       reduce using rule 60 (range -> simple_expression DOUBLEDOT simple_expression .)
    RENAMES         reduce using rule 60 (range -> simple_expression DOUBLEDOT simple_expression .)
    IS_ASSIGNED     reduce using rule 60 (range -> simple_expression DOUBLEDOT simple_expression .)
    WITH            reduce using rule 60 (range -> simple_expression DOUBLEDOT simple_expression .)
    LOOP            reduce using rule 60 (range -> simple_expression DOUBLEDOT simple_expression .)
    AND             reduce using rule 60 (range -> simple_expression DOUBLEDOT simple_expression .)
    OR              reduce using rule 60 (range -> simple_expression DOUBLEDOT simple_expression .)
    XOR             reduce using rule 60 (range -> simple_expression DOUBLEDOT simple_expression .)
    IS              reduce using rule 60 (range -> simple_expression DOUBLEDOT simple_expression .)
    THEN            reduce using rule 60 (range -> simple_expression DOUBLEDOT simple_expression .)
    RANGE           reduce using rule 60 (range -> simple_expression DOUBLEDOT simple_expression .)
    DIGITS          reduce using rule 60 (range -> simple_expression DOUBLEDOT simple_expression .)
    PLUS            shift and go to state 212
    MINUS           shift and go to state 217
    AMPERSAND       shift and go to state 207

    adding                         shift and go to state 204

state 513

    (191) aggregate -> LPAREN NULL RECORD RPAREN .

    POW             reduce using rule 191 (aggregate -> LPAREN NULL RECORD RPAREN .)
    TIMES           reduce using rule 191 (aggregate -> LPAREN NULL RECORD RPAREN .)
    DIVIDE          reduce using rule 191 (aggregate -> LPAREN NULL RECORD RPAREN .)
    MOD             reduce using rule 191 (aggregate -> LPAREN NULL RECORD RPAREN .)
    REM             reduce using rule 191 (aggregate -> LPAREN NULL RECORD RPAREN .)
    EQ              reduce using rule 191 (aggregate -> LPAREN NULL RECORD RPAREN .)
    NE              reduce using rule 191 (aggregate -> LPAREN NULL RECORD RPAREN .)
    LT              reduce using rule 191 (aggregate -> LPAREN NULL RECORD RPAREN .)
    LE              reduce using rule 191 (aggregate -> LPAREN NULL RECORD RPAREN .)
    GT              reduce using rule 191 (aggregate -> LPAREN NULL RECORD RPAREN .)
    GE              reduce using rule 191 (aggregate -> LPAREN NULL RECORD RPAREN .)
    IN              reduce using rule 191 (aggregate -> LPAREN NULL RECORD RPAREN .)
    NOT             reduce using rule 191 (aggregate -> LPAREN NULL RECORD RPAREN .)
    PLUS            reduce using rule 191 (aggregate -> LPAREN NULL RECORD RPAREN .)
    MINUS           reduce using rule 191 (aggregate -> LPAREN NULL RECORD RPAREN .)
    AMPERSAND       reduce using rule 191 (aggregate -> LPAREN NULL RECORD RPAREN .)
    AND             reduce using rule 191 (aggregate -> LPAREN NULL RECORD RPAREN .)
    OR              reduce using rule 191 (aggregate -> LPAREN NULL RECORD RPAREN .)
    XOR             reduce using rule 191 (aggregate -> LPAREN NULL RECORD RPAREN .)
    THEN            reduce using rule 191 (aggregate -> LPAREN NULL RECORD RPAREN .)
    RPAREN          reduce using rule 191 (aggregate -> LPAREN NULL RECORD RPAREN .)
    COMMA           reduce using rule 191 (aggregate -> LPAREN NULL RECORD RPAREN .)
    DOUBLEDOT       reduce using rule 191 (aggregate -> LPAREN NULL RECORD RPAREN .)
    WITH            reduce using rule 191 (aggregate -> LPAREN NULL RECORD RPAREN .)
    ARROW           reduce using rule 191 (aggregate -> LPAREN NULL RECORD RPAREN .)
    |               reduce using rule 191 (aggregate -> LPAREN NULL RECORD RPAREN .)
    SEMICOLON       reduce using rule 191 (aggregate -> LPAREN NULL RECORD RPAREN .)
    IS              reduce using rule 191 (aggregate -> LPAREN NULL RECORD RPAREN .)
    LOOP            reduce using rule 191 (aggregate -> LPAREN NULL RECORD RPAREN .)
    RANGE           reduce using rule 191 (aggregate -> LPAREN NULL RECORD RPAREN .)
    DIGITS          reduce using rule 191 (aggregate -> LPAREN NULL RECORD RPAREN .)
    RENAMES         reduce using rule 191 (aggregate -> LPAREN NULL RECORD RPAREN .)
    IS_ASSIGNED     reduce using rule 191 (aggregate -> LPAREN NULL RECORD RPAREN .)


state 514

    (122) choice_s -> choice_s | choice .

    ARROW           reduce using rule 122 (choice_s -> choice_s | choice .)
    |               reduce using rule 122 (choice_s -> choice_s | choice .)


state 515

    (124) choice -> discrete_with_range .

    ARROW           reduce using rule 124 (choice -> discrete_with_range .)
    |               reduce using rule 124 (choice -> discrete_with_range .)


state 516

    (123) choice -> expression .
    (196) expression -> expression . logical relation
    (197) expression -> expression . short_circuit relation
    (198) logical -> . AND
    (199) logical -> . OR
    (200) logical -> . XOR
    (201) short_circuit -> . AND THEN
    (202) short_circuit -> . OR ELSE

    ARROW           reduce using rule 123 (choice -> expression .)
    |               reduce using rule 123 (choice -> expression .)
    AND             shift and go to state 244
    OR              shift and go to state 248
    XOR             shift and go to state 245

    logical                        shift and go to state 246
    short_circuit                  shift and go to state 247

state 517

    (194) comp_assoc -> choice_s ARROW expression .
    (196) expression -> expression . logical relation
    (197) expression -> expression . short_circuit relation
    (198) logical -> . AND
    (199) logical -> . OR
    (200) logical -> . XOR
    (201) short_circuit -> . AND THEN
    (202) short_circuit -> . OR ELSE

    RPAREN          reduce using rule 194 (comp_assoc -> choice_s ARROW expression .)
    COMMA           reduce using rule 194 (comp_assoc -> choice_s ARROW expression .)
    AND             shift and go to state 244
    OR              shift and go to state 248
    XOR             shift and go to state 245

    short_circuit                  shift and go to state 247
    logical                        shift and go to state 246

state 518

    (193) value_s_2 -> value_s_2 COMMA value .

    RPAREN          reduce using rule 193 (value_s_2 -> value_s_2 COMMA value .)
    COMMA           reduce using rule 193 (value_s_2 -> value_s_2 COMMA value .)


state 519

    (61) range -> name . TICK RANGE
    (62) range -> name . TICK RANGE LPAREN expression RPAREN
    (168) indexed_comp -> name . LPAREN value_s RPAREN
    (175) selected_comp -> name . DOT simple_name
    (176) selected_comp -> name . DOT used_char
    (177) selected_comp -> name . DOT operator_symbol
    (178) selected_comp -> name . DOT ALL
    (179) attribute -> name . TICK attribute_id
    (237) primary -> name .
    (240) qualified -> name . TICK parenthesized_primary

    TICK            shift and go to state 373
    LPAREN          shift and go to state 240
    DOT             shift and go to state 242
    POW             reduce using rule 237 (primary -> name .)
    TIMES           reduce using rule 237 (primary -> name .)
    DIVIDE          reduce using rule 237 (primary -> name .)
    MOD             reduce using rule 237 (primary -> name .)
    REM             reduce using rule 237 (primary -> name .)
    DOUBLEDOT       reduce using rule 237 (primary -> name .)
    PLUS            reduce using rule 237 (primary -> name .)
    MINUS           reduce using rule 237 (primary -> name .)
    AMPERSAND       reduce using rule 237 (primary -> name .)


state 520

    (59) range_constraint -> RANGE range .

    RPAREN          reduce using rule 59 (range_constraint -> RANGE range .)
    COMMA           reduce using rule 59 (range_constraint -> RANGE range .)
    SEMICOLON       reduce using rule 59 (range_constraint -> RANGE range .)
    LOOP            reduce using rule 59 (range_constraint -> RANGE range .)
    RENAMES         reduce using rule 59 (range_constraint -> RANGE range .)
    IS_ASSIGNED     reduce using rule 59 (range_constraint -> RANGE range .)
    WITH            reduce using rule 59 (range_constraint -> RANGE range .)
    ARROW           reduce using rule 59 (range_constraint -> RANGE range .)
    |               reduce using rule 59 (range_constraint -> RANGE range .)


state 521

    (61) range -> name TICK RANGE .
    (62) range -> name TICK RANGE . LPAREN expression RPAREN

    RPAREN          reduce using rule 61 (range -> name TICK RANGE .)
    COMMA           reduce using rule 61 (range -> name TICK RANGE .)
    ARROW           reduce using rule 61 (range -> name TICK RANGE .)
    |               reduce using rule 61 (range -> name TICK RANGE .)
    SEMICOLON       reduce using rule 61 (range -> name TICK RANGE .)
    RENAMES         reduce using rule 61 (range -> name TICK RANGE .)
    IS_ASSIGNED     reduce using rule 61 (range -> name TICK RANGE .)
    WITH            reduce using rule 61 (range -> name TICK RANGE .)
    LOOP            reduce using rule 61 (range -> name TICK RANGE .)
    AND             reduce using rule 61 (range -> name TICK RANGE .)
    OR              reduce using rule 61 (range -> name TICK RANGE .)
    XOR             reduce using rule 61 (range -> name TICK RANGE .)
    IS              reduce using rule 61 (range -> name TICK RANGE .)
    THEN            reduce using rule 61 (range -> name TICK RANGE .)
    RANGE           reduce using rule 61 (range -> name TICK RANGE .)
    DIGITS          reduce using rule 61 (range -> name TICK RANGE .)
    LPAREN          shift and go to state 659


state 522

    (192) value_s_2 -> value COMMA value .

    RPAREN          reduce using rule 192 (value_s_2 -> value COMMA value .)
    COMMA           reduce using rule 192 (value_s_2 -> value COMMA value .)


state 523

    (190) aggregate -> LPAREN expression WITH NULL . RECORD RPAREN
    (186) literal -> NULL .

    RECORD          shift and go to state 660
    POW             reduce using rule 186 (literal -> NULL .)
    TIMES           reduce using rule 186 (literal -> NULL .)
    DIVIDE          reduce using rule 186 (literal -> NULL .)
    MOD             reduce using rule 186 (literal -> NULL .)
    REM             reduce using rule 186 (literal -> NULL .)
    DOUBLEDOT       reduce using rule 186 (literal -> NULL .)
    EQ              reduce using rule 186 (literal -> NULL .)
    NE              reduce using rule 186 (literal -> NULL .)
    LT              reduce using rule 186 (literal -> NULL .)
    LE              reduce using rule 186 (literal -> NULL .)
    GT              reduce using rule 186 (literal -> NULL .)
    GE              reduce using rule 186 (literal -> NULL .)
    IN              reduce using rule 186 (literal -> NULL .)
    NOT             reduce using rule 186 (literal -> NULL .)
    PLUS            reduce using rule 186 (literal -> NULL .)
    MINUS           reduce using rule 186 (literal -> NULL .)
    AMPERSAND       reduce using rule 186 (literal -> NULL .)
    AND             reduce using rule 186 (literal -> NULL .)
    OR              reduce using rule 186 (literal -> NULL .)
    XOR             reduce using rule 186 (literal -> NULL .)
    RPAREN          reduce using rule 186 (literal -> NULL .)
    COMMA           reduce using rule 186 (literal -> NULL .)
    ARROW           reduce using rule 186 (literal -> NULL .)
    |               reduce using rule 186 (literal -> NULL .)


state 524

    (189) aggregate -> LPAREN expression WITH value_s . RPAREN
    (170) value_s -> value_s . COMMA value

    RPAREN          shift and go to state 661
    COMMA           shift and go to state 526


state 525

    (168) indexed_comp -> name LPAREN value_s RPAREN .

    IS_ASSIGNED     reduce using rule 168 (indexed_comp -> name LPAREN value_s RPAREN .)
    SEMICOLON       reduce using rule 168 (indexed_comp -> name LPAREN value_s RPAREN .)
    TICK            reduce using rule 168 (indexed_comp -> name LPAREN value_s RPAREN .)
    LPAREN          reduce using rule 168 (indexed_comp -> name LPAREN value_s RPAREN .)
    DOT             reduce using rule 168 (indexed_comp -> name LPAREN value_s RPAREN .)
    TIMES           reduce using rule 168 (indexed_comp -> name LPAREN value_s RPAREN .)
    DIVIDE          reduce using rule 168 (indexed_comp -> name LPAREN value_s RPAREN .)
    MOD             reduce using rule 168 (indexed_comp -> name LPAREN value_s RPAREN .)
    REM             reduce using rule 168 (indexed_comp -> name LPAREN value_s RPAREN .)
    EQ              reduce using rule 168 (indexed_comp -> name LPAREN value_s RPAREN .)
    NE              reduce using rule 168 (indexed_comp -> name LPAREN value_s RPAREN .)
    LT              reduce using rule 168 (indexed_comp -> name LPAREN value_s RPAREN .)
    LE              reduce using rule 168 (indexed_comp -> name LPAREN value_s RPAREN .)
    GT              reduce using rule 168 (indexed_comp -> name LPAREN value_s RPAREN .)
    GE              reduce using rule 168 (indexed_comp -> name LPAREN value_s RPAREN .)
    IN              reduce using rule 168 (indexed_comp -> name LPAREN value_s RPAREN .)
    NOT             reduce using rule 168 (indexed_comp -> name LPAREN value_s RPAREN .)
    PLUS            reduce using rule 168 (indexed_comp -> name LPAREN value_s RPAREN .)
    MINUS           reduce using rule 168 (indexed_comp -> name LPAREN value_s RPAREN .)
    AMPERSAND       reduce using rule 168 (indexed_comp -> name LPAREN value_s RPAREN .)
    AND             reduce using rule 168 (indexed_comp -> name LPAREN value_s RPAREN .)
    OR              reduce using rule 168 (indexed_comp -> name LPAREN value_s RPAREN .)
    XOR             reduce using rule 168 (indexed_comp -> name LPAREN value_s RPAREN .)
    RPAREN          reduce using rule 168 (indexed_comp -> name LPAREN value_s RPAREN .)
    COMMA           reduce using rule 168 (indexed_comp -> name LPAREN value_s RPAREN .)
    DOUBLEDOT       reduce using rule 168 (indexed_comp -> name LPAREN value_s RPAREN .)
    WITH            reduce using rule 168 (indexed_comp -> name LPAREN value_s RPAREN .)
    ARROW           reduce using rule 168 (indexed_comp -> name LPAREN value_s RPAREN .)
    |               reduce using rule 168 (indexed_comp -> name LPAREN value_s RPAREN .)
    IS              reduce using rule 168 (indexed_comp -> name LPAREN value_s RPAREN .)
    THEN            reduce using rule 168 (indexed_comp -> name LPAREN value_s RPAREN .)
    LOOP            reduce using rule 168 (indexed_comp -> name LPAREN value_s RPAREN .)
    RANGE           reduce using rule 168 (indexed_comp -> name LPAREN value_s RPAREN .)
    DIGITS          reduce using rule 168 (indexed_comp -> name LPAREN value_s RPAREN .)
    RENAMES         reduce using rule 168 (indexed_comp -> name LPAREN value_s RPAREN .)
    POW             reduce using rule 168 (indexed_comp -> name LPAREN value_s RPAREN .)
    WHEN            reduce using rule 168 (indexed_comp -> name LPAREN value_s RPAREN .)


state 526

    (170) value_s -> value_s COMMA . value
    (171) value -> . expression
    (172) value -> . comp_assoc
    (173) value -> . discrete_with_range
    (174) value -> . error
    (195) expression -> . relation
    (196) expression -> . expression logical relation
    (197) expression -> . expression short_circuit relation
    (194) comp_assoc -> . choice_s ARROW expression
    (126) discrete_with_range -> . name range_constraint
    (127) discrete_with_range -> . range
    (203) relation -> . simple_expression
    (204) relation -> . simple_expression relational simple_expression
    (205) relation -> . simple_expression membership range
    (206) relation -> . simple_expression membership name
    (121) choice_s -> . choice
    (122) choice_s -> . choice_s | choice
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (60) range -> . simple_expression DOUBLEDOT simple_expression
    (61) range -> . name TICK RANGE
    (62) range -> . name TICK RANGE LPAREN expression RPAREN
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (123) choice -> . expression
    (124) choice -> . discrete_with_range
    (125) choice -> . OTHERS
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN

    error           shift and go to state 233
    OTHERS          shift and go to state 222
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137
    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    relation                       shift and go to state 127
    simple_expression              shift and go to state 379
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    choice_s                       shift and go to state 225
    comp_assoc                     shift and go to state 380
    factor                         shift and go to state 136
    choice                         shift and go to state 227
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    discrete_with_range            shift and go to state 229
    term                           shift and go to state 144
    name                           shift and go to state 230
    operator_symbol                shift and go to state 146
    value                          shift and go to state 662
    range                          shift and go to state 232
    expression                     shift and go to state 382

state 527

    (382) prot_body -> PROTECTED BODY . simple_name IS prot_op_body_s END id_opt SEMICOLON
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 40

    simple_name                    shift and go to state 663

state 528

    (365) task_body -> TASK BODY . simple_name IS decl_part block_body END id_opt SEMICOLON
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 40

    simple_name                    shift and go to state 664

state 529

    (330) subprog_spec_is_push -> subprog_spec IS .

    PACKAGE         reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    TASK            reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    PROTECTED       reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    error           reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    USE             reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    PRAGMA          reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    TYPE            reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    SUBTYPE         reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    FOR             reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    PROCEDURE       reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    FUNCTION        reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    GENERIC         reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    IDENTIFIER      reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)
    BEGIN           reduce using rule 330 (subprog_spec_is_push -> subprog_spec IS .)


state 530

    (340) pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt . END c_id_opt SEMICOLON

    END             shift and go to state 665


state 531

    (342) body_opt -> block_body .

    END             reduce using rule 342 (body_opt -> block_body .)


state 532

    (454) body_stub -> PROTECTED BODY simple_name . IS SEPARATE SEMICOLON

    IS              shift and go to state 666


state 533

    (337) private_part -> PRIVATE decl_item_s .

    END             reduce using rule 337 (private_part -> PRIVATE decl_item_s .)


state 534

    (335) pkg_spec -> PACKAGE compound_name IS decl_item_s private_part END . c_id_opt
    (338) c_id_opt -> .
    (339) c_id_opt -> . compound_name
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name DOT simple_name
    (161) simple_name -> . IDENTIFIER

    SEMICOLON       reduce using rule 338 (c_id_opt -> .)
    IDENTIFIER      shift and go to state 40

    simple_name                    shift and go to state 41
    compound_name                  shift and go to state 667
    c_id_opt                       shift and go to state 668

state 535

    (451) body_stub -> TASK BODY simple_name . IS SEPARATE SEMICOLON

    IS              shift and go to state 669


state 536

    (452) body_stub -> PACKAGE BODY compound_name . IS SEPARATE SEMICOLON
    (163) compound_name -> compound_name . DOT simple_name

    IS              shift and go to state 670
    DOT             shift and go to state 118


state 537

    (322) param_s -> param_s SEMICOLON param .

    RPAREN          reduce using rule 322 (param_s -> param_s SEMICOLON param .)
    SEMICOLON       reduce using rule 322 (param_s -> param_s SEMICOLON param .)


state 538

    (454) body_stub -> PROTECTED BODY simple_name IS SEPARATE . SEMICOLON

    SEMICOLON       shift and go to state 671


state 539

    (382) prot_body -> PROTECTED BODY simple_name IS prot_op_body_s . END id_opt SEMICOLON
    (384) prot_op_body_s -> prot_op_body_s . prot_op_body pragma_s
    (385) prot_op_body -> . entry_body
    (386) prot_op_body -> . subprog_body
    (387) prot_op_body -> . subprog_spec SEMICOLON
    (392) entry_body -> . ENTRY IDENTIFIER formal_part_opt WHEN condition entry_body_part
    (393) entry_body -> . ENTRY IDENTIFIER LPAREN iter_part discrete_range RPAREN formal_part_opt WHEN condition entry_body_part
    (331) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt SEMICOLON
    (313) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (314) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (315) subprog_spec -> . FUNCTION designator
    (330) subprog_spec_is_push -> . subprog_spec IS

    END             shift and go to state 674
    ENTRY           shift and go to state 677
    PROCEDURE       shift and go to state 30
    FUNCTION        shift and go to state 36

    subprog_body                   shift and go to state 672
    prot_op_body                   shift and go to state 676
    entry_body                     shift and go to state 675
    subprog_spec                   shift and go to state 673
    subprog_spec_is_push           shift and go to state 406

state 540

    (383) prot_op_body_s -> pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON

    END             reduce using rule 383 (prot_op_body_s -> pragma_s .)
    ENTRY           reduce using rule 383 (prot_op_body_s -> pragma_s .)
    PROCEDURE       reduce using rule 383 (prot_op_body_s -> pragma_s .)
    FUNCTION        reduce using rule 383 (prot_op_body_s -> pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 541

    (377) prot_op_decl -> pragma .

    PRIVATE         reduce using rule 377 (prot_op_decl -> pragma .)
    ENTRY           reduce using rule 377 (prot_op_decl -> pragma .)
    PROCEDURE       reduce using rule 377 (prot_op_decl -> pragma .)
    FUNCTION        reduce using rule 377 (prot_op_decl -> pragma .)
    PRAGMA          reduce using rule 377 (prot_op_decl -> pragma .)
    FOR             reduce using rule 377 (prot_op_decl -> pragma .)
    END             reduce using rule 377 (prot_op_decl -> pragma .)
    error           reduce using rule 377 (prot_op_decl -> pragma .)
    IDENTIFIER      reduce using rule 377 (prot_op_decl -> pragma .)


state 542

    (376) prot_op_decl -> rep_spec .

    PRIVATE         reduce using rule 376 (prot_op_decl -> rep_spec .)
    ENTRY           reduce using rule 376 (prot_op_decl -> rep_spec .)
    PROCEDURE       reduce using rule 376 (prot_op_decl -> rep_spec .)
    FUNCTION        reduce using rule 376 (prot_op_decl -> rep_spec .)
    PRAGMA          reduce using rule 376 (prot_op_decl -> rep_spec .)
    FOR             reduce using rule 376 (prot_op_decl -> rep_spec .)
    END             reduce using rule 376 (prot_op_decl -> rep_spec .)
    error           reduce using rule 376 (prot_op_decl -> rep_spec .)
    IDENTIFIER      reduce using rule 376 (prot_op_decl -> rep_spec .)


state 543

    (374) prot_op_decl -> entry_decl .

    PRIVATE         reduce using rule 374 (prot_op_decl -> entry_decl .)
    ENTRY           reduce using rule 374 (prot_op_decl -> entry_decl .)
    PROCEDURE       reduce using rule 374 (prot_op_decl -> entry_decl .)
    FUNCTION        reduce using rule 374 (prot_op_decl -> entry_decl .)
    PRAGMA          reduce using rule 374 (prot_op_decl -> entry_decl .)
    FOR             reduce using rule 374 (prot_op_decl -> entry_decl .)
    END             reduce using rule 374 (prot_op_decl -> entry_decl .)
    error           reduce using rule 374 (prot_op_decl -> entry_decl .)
    IDENTIFIER      reduce using rule 374 (prot_op_decl -> entry_decl .)


state 544

    (371) prot_private_opt -> PRIVATE . prot_elem_decl_s
    (378) prot_elem_decl_s -> .
    (379) prot_elem_decl_s -> . prot_elem_decl_s prot_elem_decl

    error           reduce using rule 378 (prot_elem_decl_s -> .)
    ENTRY           reduce using rule 378 (prot_elem_decl_s -> .)
    PROCEDURE       reduce using rule 378 (prot_elem_decl_s -> .)
    FUNCTION        reduce using rule 378 (prot_elem_decl_s -> .)
    PRAGMA          reduce using rule 378 (prot_elem_decl_s -> .)
    FOR             reduce using rule 378 (prot_elem_decl_s -> .)
    IDENTIFIER      reduce using rule 378 (prot_elem_decl_s -> .)
    END             reduce using rule 378 (prot_elem_decl_s -> .)

    prot_elem_decl_s               shift and go to state 678

state 545

    (375) prot_op_decl -> subprog_spec . SEMICOLON

    SEMICOLON       shift and go to state 679


state 546

    (369) prot_def -> IS prot_op_decl_s prot_private_opt . END id_opt

    END             shift and go to state 680


state 547

    (390) entry_decl -> ENTRY . IDENTIFIER formal_part_opt SEMICOLON
    (391) entry_decl -> ENTRY . IDENTIFIER LPAREN discrete_range RPAREN formal_part_opt SEMICOLON

    IDENTIFIER      shift and go to state 681


state 548

    (373) prot_op_decl_s -> prot_op_decl_s prot_op_decl .

    PRIVATE         reduce using rule 373 (prot_op_decl_s -> prot_op_decl_s prot_op_decl .)
    ENTRY           reduce using rule 373 (prot_op_decl_s -> prot_op_decl_s prot_op_decl .)
    PROCEDURE       reduce using rule 373 (prot_op_decl_s -> prot_op_decl_s prot_op_decl .)
    FUNCTION        reduce using rule 373 (prot_op_decl_s -> prot_op_decl_s prot_op_decl .)
    PRAGMA          reduce using rule 373 (prot_op_decl_s -> prot_op_decl_s prot_op_decl .)
    FOR             reduce using rule 373 (prot_op_decl_s -> prot_op_decl_s prot_op_decl .)
    END             reduce using rule 373 (prot_op_decl_s -> prot_op_decl_s prot_op_decl .)


state 549

    (368) prot_spec -> PROTECTED TYPE simple_name discrim_part_opt prot_def .

    SEMICOLON       reduce using rule 368 (prot_spec -> PROTECTED TYPE simple_name discrim_part_opt prot_def .)


state 550

    (405) delay_stmt -> DELAY UNTIL expression . SEMICOLON
    (196) expression -> expression . logical relation
    (197) expression -> expression . short_circuit relation
    (198) logical -> . AND
    (199) logical -> . OR
    (200) logical -> . XOR
    (201) short_circuit -> . AND THEN
    (202) short_circuit -> . OR ELSE

    SEMICOLON       shift and go to state 682
    AND             shift and go to state 244
    OR              shift and go to state 248
    XOR             shift and go to state 245

    logical                        shift and go to state 246
    short_circuit                  shift and go to state 247

state 551

    (404) delay_stmt -> DELAY expression SEMICOLON .

    LLB             reduce using rule 404 (delay_stmt -> DELAY expression SEMICOLON .)
    error           reduce using rule 404 (delay_stmt -> DELAY expression SEMICOLON .)
    PRAGMA          reduce using rule 404 (delay_stmt -> DELAY expression SEMICOLON .)
    NULL            reduce using rule 404 (delay_stmt -> DELAY expression SEMICOLON .)
    EXIT            reduce using rule 404 (delay_stmt -> DELAY expression SEMICOLON .)
    RETURN          reduce using rule 404 (delay_stmt -> DELAY expression SEMICOLON .)
    GOTO            reduce using rule 404 (delay_stmt -> DELAY expression SEMICOLON .)
    DELAY           reduce using rule 404 (delay_stmt -> DELAY expression SEMICOLON .)
    ABORT           reduce using rule 404 (delay_stmt -> DELAY expression SEMICOLON .)
    RAISE           reduce using rule 404 (delay_stmt -> DELAY expression SEMICOLON .)
    REQUEUE         reduce using rule 404 (delay_stmt -> DELAY expression SEMICOLON .)
    IF              reduce using rule 404 (delay_stmt -> DELAY expression SEMICOLON .)
    CASE            reduce using rule 404 (delay_stmt -> DELAY expression SEMICOLON .)
    IDENTIFIER      reduce using rule 404 (delay_stmt -> DELAY expression SEMICOLON .)
    ACCEPT          reduce using rule 404 (delay_stmt -> DELAY expression SEMICOLON .)
    SELECT          reduce using rule 404 (delay_stmt -> DELAY expression SEMICOLON .)
    STRING          reduce using rule 404 (delay_stmt -> DELAY expression SEMICOLON .)
    WHILE           reduce using rule 404 (delay_stmt -> DELAY expression SEMICOLON .)
    DECLARE         reduce using rule 404 (delay_stmt -> DELAY expression SEMICOLON .)
    FOR             reduce using rule 404 (delay_stmt -> DELAY expression SEMICOLON .)
    LOOP            reduce using rule 404 (delay_stmt -> DELAY expression SEMICOLON .)
    BEGIN           reduce using rule 404 (delay_stmt -> DELAY expression SEMICOLON .)
    WHEN            reduce using rule 404 (delay_stmt -> DELAY expression SEMICOLON .)
    END             reduce using rule 404 (delay_stmt -> DELAY expression SEMICOLON .)
    EXCEPTION       reduce using rule 404 (delay_stmt -> DELAY expression SEMICOLON .)
    ELSE            reduce using rule 404 (delay_stmt -> DELAY expression SEMICOLON .)
    ELSIF           reduce using rule 404 (delay_stmt -> DELAY expression SEMICOLON .)
    OR              reduce using rule 404 (delay_stmt -> DELAY expression SEMICOLON .)
    THEN            reduce using rule 404 (delay_stmt -> DELAY expression SEMICOLON .)


state 552

    (289) iteration -> iter_part reverse_opt . discrete_range
    (91) discrete_range -> . name range_constr_opt
    (92) discrete_range -> . range
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (60) range -> . simple_expression DOUBLEDOT simple_expression
    (61) range -> . name TICK RANGE
    (62) range -> . name TICK RANGE LPAREN expression RPAREN
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN

    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137
    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    simple_expression              shift and go to state 356
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    factor                         shift and go to state 136
    parenthesized_primary          shift and go to state 141
    discrete_range                 shift and go to state 683
    aggregate                      shift and go to state 126
    term                           shift and go to state 144
    name                           shift and go to state 684
    operator_symbol                shift and go to state 146
    range                          shift and go to state 685
    qualified                      shift and go to state 147

state 553

    (291) reverse_opt -> REVERSE .

    IDENTIFIER      reduce using rule 291 (reverse_opt -> REVERSE .)
    STRING          reduce using rule 291 (reverse_opt -> REVERSE .)
    PLUS            reduce using rule 291 (reverse_opt -> REVERSE .)
    MINUS           reduce using rule 291 (reverse_opt -> REVERSE .)
    NOT             reduce using rule 291 (reverse_opt -> REVERSE .)
    ABS             reduce using rule 291 (reverse_opt -> REVERSE .)
    NUMBER          reduce using rule 291 (reverse_opt -> REVERSE .)
    NULL            reduce using rule 291 (reverse_opt -> REVERSE .)
    NEW             reduce using rule 291 (reverse_opt -> REVERSE .)
    LPAREN          reduce using rule 291 (reverse_opt -> REVERSE .)
    CHARACTER       reduce using rule 291 (reverse_opt -> REVERSE .)


state 554

    (286) iter_part -> FOR IDENTIFIER . IN

    IN              shift and go to state 686


state 555

    (283) loop_stmt -> label_opt iteration basic_loop . id_opt SEMICOLON
    (293) id_opt -> .
    (294) id_opt -> . designator
    (316) designator -> . compound_name
    (317) designator -> . STRING
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name DOT simple_name
    (161) simple_name -> . IDENTIFIER

    SEMICOLON       reduce using rule 293 (id_opt -> .)
    STRING          shift and go to state 114
    IDENTIFIER      shift and go to state 40

    designator                     shift and go to state 471
    id_opt                         shift and go to state 687
    compound_name                  shift and go to state 113
    simple_name                    shift and go to state 41

state 556

    (292) basic_loop -> LOOP . statement_s END LOOP
    (243) statement_s -> . statement
    (244) statement_s -> . statement_s statement
    (245) statement -> . unlabeled
    (246) statement -> . label statement
    (247) unlabeled -> . simple_stmt
    (248) unlabeled -> . compound_stmt
    (249) unlabeled -> . pragma
    (268) label -> . LLB IDENTIFIER RLB
    (250) simple_stmt -> . NULL_stmt
    (251) simple_stmt -> . assign_stmt
    (252) simple_stmt -> . exit_stmt
    (253) simple_stmt -> . return_stmt
    (254) simple_stmt -> . goto_stmt
    (255) simple_stmt -> . procedure_call
    (256) simple_stmt -> . delay_stmt
    (257) simple_stmt -> . abort_stmt
    (258) simple_stmt -> . raise_stmt
    (259) simple_stmt -> . code_stmt
    (260) simple_stmt -> . requeue_stmt
    (261) simple_stmt -> . error SEMICOLON
    (262) compound_stmt -> . if_stmt
    (263) compound_stmt -> . case_stmt
    (264) compound_stmt -> . loop_stmt
    (265) compound_stmt -> . block
    (266) compound_stmt -> . accept_stmt
    (267) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (269) NULL_stmt -> . NULL SEMICOLON
    (270) assign_stmt -> . name IS_ASSIGNED expression SEMICOLON
    (302) exit_stmt -> . EXIT name_opt when_opt SEMICOLON
    (307) return_stmt -> . RETURN SEMICOLON
    (308) return_stmt -> . RETURN expression SEMICOLON
    (309) goto_stmt -> . GOTO name SEMICOLON
    (332) procedure_call -> . name SEMICOLON
    (404) delay_stmt -> . DELAY expression SEMICOLON
    (405) delay_stmt -> . DELAY UNTIL expression SEMICOLON
    (425) abort_stmt -> . ABORT name_s SEMICOLON
    (464) raise_stmt -> . RAISE name_opt SEMICOLON
    (510) code_stmt -> . qualified SEMICOLON
    (465) requeue_stmt -> . REQUEUE name SEMICOLON
    (466) requeue_stmt -> . REQUEUE name WITH ABORT SEMICOLON
    (271) if_stmt -> . IF cond_clause else_opt END IF SEMICOLON
    (278) case_stmt -> . case_hdr alternative_s END CASE SEMICOLON
    (283) loop_stmt -> . label_opt iteration basic_loop id_opt SEMICOLON
    (295) block -> . label_opt block_decl block_body END id_opt SEMICOLON
    (399) accept_stmt -> . accept_hdr SEMICOLON
    (400) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt SEMICOLON
    (406) select_stmt -> . select_wait
    (407) select_stmt -> . async_select
    (408) select_stmt -> . timed_entry_call
    (409) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (240) qualified -> . name TICK parenthesized_primary
    (279) case_hdr -> . CASE expression IS
    (284) label_opt -> .
    (285) label_opt -> . IDENTIFIER COLON
    (401) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (410) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON
    (420) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON
    (421) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON
    (422) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    LLB             shift and go to state 289
    error           shift and go to state 309
    PRAGMA          shift and go to state 4
    NULL            shift and go to state 311
    EXIT            shift and go to state 308
    RETURN          shift and go to state 295
    GOTO            shift and go to state 276
    DELAY           shift and go to state 272
    ABORT           shift and go to state 282
    RAISE           shift and go to state 306
    REQUEUE         shift and go to state 298
    IF              shift and go to state 317
    CASE            shift and go to state 297
    WHILE           reduce using rule 284 (label_opt -> .)
    DECLARE         reduce using rule 284 (label_opt -> .)
    FOR             reduce using rule 284 (label_opt -> .)
    LOOP            reduce using rule 284 (label_opt -> .)
    BEGIN           reduce using rule 284 (label_opt -> .)
    IDENTIFIER      shift and go to state 300
    ACCEPT          shift and go to state 284
    SELECT          shift and go to state 286
    STRING          shift and go to state 137

    indexed_comp                   shift and go to state 119
    accept_stmt                    shift and go to state 283
    label_opt                      shift and go to state 275
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 316
    abort_stmt                     shift and go to state 310
    return_stmt                    shift and go to state 294
    procedure_call                 shift and go to state 285
    assign_stmt                    shift and go to state 320
    statement_s                    shift and go to state 688
    simple_name                    shift and go to state 153
    code_stmt                      shift and go to state 313
    case_stmt                      shift and go to state 287
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 146
    label                          shift and go to state 288
    exit_stmt                      shift and go to state 315
    select_stmt                    shift and go to state 274
    statement                      shift and go to state 299
    compound_stmt                  shift and go to state 290
    case_hdr                       shift and go to state 292
    delay_stmt                     shift and go to state 301
    unlabeled                      shift and go to state 314
    simple_stmt                    shift and go to state 277
    loop_stmt                      shift and go to state 278
    qualified                      shift and go to state 279
    pragma                         shift and go to state 303
    async_select                   shift and go to state 273
    requeue_stmt                   shift and go to state 304
    raise_stmt                     shift and go to state 305
    name                           shift and go to state 281
    if_stmt                        shift and go to state 280
    accept_hdr                     shift and go to state 302
    cond_entry_call                shift and go to state 318
    timed_entry_call               shift and go to state 307
    goto_stmt                      shift and go to state 291
    NULL_stmt                      shift and go to state 319
    block                          shift and go to state 293

state 557

    (295) block -> label_opt block_decl block_body . END id_opt SEMICOLON

    END             shift and go to state 689


state 558

    (288) iteration -> WHILE condition .

    LOOP            reduce using rule 288 (iteration -> WHILE condition .)


state 559

    (297) block_decl -> DECLARE decl_part .

    BEGIN           reduce using rule 297 (block_decl -> DECLARE decl_part .)


state 560

    (309) goto_stmt -> GOTO name SEMICOLON .

    LLB             reduce using rule 309 (goto_stmt -> GOTO name SEMICOLON .)
    error           reduce using rule 309 (goto_stmt -> GOTO name SEMICOLON .)
    PRAGMA          reduce using rule 309 (goto_stmt -> GOTO name SEMICOLON .)
    NULL            reduce using rule 309 (goto_stmt -> GOTO name SEMICOLON .)
    EXIT            reduce using rule 309 (goto_stmt -> GOTO name SEMICOLON .)
    RETURN          reduce using rule 309 (goto_stmt -> GOTO name SEMICOLON .)
    GOTO            reduce using rule 309 (goto_stmt -> GOTO name SEMICOLON .)
    DELAY           reduce using rule 309 (goto_stmt -> GOTO name SEMICOLON .)
    ABORT           reduce using rule 309 (goto_stmt -> GOTO name SEMICOLON .)
    RAISE           reduce using rule 309 (goto_stmt -> GOTO name SEMICOLON .)
    REQUEUE         reduce using rule 309 (goto_stmt -> GOTO name SEMICOLON .)
    IF              reduce using rule 309 (goto_stmt -> GOTO name SEMICOLON .)
    CASE            reduce using rule 309 (goto_stmt -> GOTO name SEMICOLON .)
    IDENTIFIER      reduce using rule 309 (goto_stmt -> GOTO name SEMICOLON .)
    ACCEPT          reduce using rule 309 (goto_stmt -> GOTO name SEMICOLON .)
    SELECT          reduce using rule 309 (goto_stmt -> GOTO name SEMICOLON .)
    STRING          reduce using rule 309 (goto_stmt -> GOTO name SEMICOLON .)
    WHILE           reduce using rule 309 (goto_stmt -> GOTO name SEMICOLON .)
    DECLARE         reduce using rule 309 (goto_stmt -> GOTO name SEMICOLON .)
    FOR             reduce using rule 309 (goto_stmt -> GOTO name SEMICOLON .)
    LOOP            reduce using rule 309 (goto_stmt -> GOTO name SEMICOLON .)
    BEGIN           reduce using rule 309 (goto_stmt -> GOTO name SEMICOLON .)
    WHEN            reduce using rule 309 (goto_stmt -> GOTO name SEMICOLON .)
    END             reduce using rule 309 (goto_stmt -> GOTO name SEMICOLON .)
    ELSE            reduce using rule 309 (goto_stmt -> GOTO name SEMICOLON .)
    ELSIF           reduce using rule 309 (goto_stmt -> GOTO name SEMICOLON .)
    EXCEPTION       reduce using rule 309 (goto_stmt -> GOTO name SEMICOLON .)
    OR              reduce using rule 309 (goto_stmt -> GOTO name SEMICOLON .)
    THEN            reduce using rule 309 (goto_stmt -> GOTO name SEMICOLON .)


state 561

    (270) assign_stmt -> name IS_ASSIGNED expression . SEMICOLON
    (196) expression -> expression . logical relation
    (197) expression -> expression . short_circuit relation
    (198) logical -> . AND
    (199) logical -> . OR
    (200) logical -> . XOR
    (201) short_circuit -> . AND THEN
    (202) short_circuit -> . OR ELSE

    SEMICOLON       shift and go to state 690
    AND             shift and go to state 244
    OR              shift and go to state 248
    XOR             shift and go to state 245

    logical                        shift and go to state 246
    short_circuit                  shift and go to state 247

state 562

    (425) abort_stmt -> ABORT name_s SEMICOLON .

    LLB             reduce using rule 425 (abort_stmt -> ABORT name_s SEMICOLON .)
    error           reduce using rule 425 (abort_stmt -> ABORT name_s SEMICOLON .)
    PRAGMA          reduce using rule 425 (abort_stmt -> ABORT name_s SEMICOLON .)
    NULL            reduce using rule 425 (abort_stmt -> ABORT name_s SEMICOLON .)
    EXIT            reduce using rule 425 (abort_stmt -> ABORT name_s SEMICOLON .)
    RETURN          reduce using rule 425 (abort_stmt -> ABORT name_s SEMICOLON .)
    GOTO            reduce using rule 425 (abort_stmt -> ABORT name_s SEMICOLON .)
    DELAY           reduce using rule 425 (abort_stmt -> ABORT name_s SEMICOLON .)
    ABORT           reduce using rule 425 (abort_stmt -> ABORT name_s SEMICOLON .)
    RAISE           reduce using rule 425 (abort_stmt -> ABORT name_s SEMICOLON .)
    REQUEUE         reduce using rule 425 (abort_stmt -> ABORT name_s SEMICOLON .)
    IF              reduce using rule 425 (abort_stmt -> ABORT name_s SEMICOLON .)
    CASE            reduce using rule 425 (abort_stmt -> ABORT name_s SEMICOLON .)
    IDENTIFIER      reduce using rule 425 (abort_stmt -> ABORT name_s SEMICOLON .)
    ACCEPT          reduce using rule 425 (abort_stmt -> ABORT name_s SEMICOLON .)
    SELECT          reduce using rule 425 (abort_stmt -> ABORT name_s SEMICOLON .)
    STRING          reduce using rule 425 (abort_stmt -> ABORT name_s SEMICOLON .)
    WHILE           reduce using rule 425 (abort_stmt -> ABORT name_s SEMICOLON .)
    DECLARE         reduce using rule 425 (abort_stmt -> ABORT name_s SEMICOLON .)
    FOR             reduce using rule 425 (abort_stmt -> ABORT name_s SEMICOLON .)
    LOOP            reduce using rule 425 (abort_stmt -> ABORT name_s SEMICOLON .)
    BEGIN           reduce using rule 425 (abort_stmt -> ABORT name_s SEMICOLON .)
    ELSE            reduce using rule 425 (abort_stmt -> ABORT name_s SEMICOLON .)
    ELSIF           reduce using rule 425 (abort_stmt -> ABORT name_s SEMICOLON .)
    END             reduce using rule 425 (abort_stmt -> ABORT name_s SEMICOLON .)
    WHEN            reduce using rule 425 (abort_stmt -> ABORT name_s SEMICOLON .)
    OR              reduce using rule 425 (abort_stmt -> ABORT name_s SEMICOLON .)
    THEN            reduce using rule 425 (abort_stmt -> ABORT name_s SEMICOLON .)
    EXCEPTION       reduce using rule 425 (abort_stmt -> ABORT name_s SEMICOLON .)


state 563

    (403) entry_name -> entry_name LPAREN . expression RPAREN
    (320) formal_part -> LPAREN . param_s RPAREN
    (195) expression -> . relation
    (196) expression -> . expression logical relation
    (197) expression -> . expression short_circuit relation
    (321) param_s -> . param
    (322) param_s -> . param_s SEMICOLON param
    (203) relation -> . simple_expression
    (204) relation -> . simple_expression relational simple_expression
    (205) relation -> . simple_expression membership range
    (206) relation -> . simple_expression membership name
    (323) param -> . def_id_s COLON mode mark init_opt
    (324) param -> . error
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s COMMA def_id
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (26) def_id -> . IDENTIFIER
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    error           shift and go to state 108
    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    IDENTIFIER      shift and go to state 691
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122
    STRING          shift and go to state 137

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    param                          shift and go to state 266
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    param_s                        shift and go to state 267
    literal                        shift and go to state 135
    def_id_s                       shift and go to state 104
    factor                         shift and go to state 136
    def_id                         shift and go to state 96
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    term                           shift and go to state 144
    name                           shift and go to state 145
    operator_symbol                shift and go to state 146
    relation                       shift and go to state 127
    expression                     shift and go to state 692

state 564

    (401) accept_hdr -> ACCEPT entry_name formal_part_opt .

    SEMICOLON       reduce using rule 401 (accept_hdr -> ACCEPT entry_name formal_part_opt .)
    DO              reduce using rule 401 (accept_hdr -> ACCEPT entry_name formal_part_opt .)


state 565

    (415) select_alt -> accept_stmt stmts_opt .

    OR              reduce using rule 415 (select_alt -> accept_stmt stmts_opt .)
    ELSE            reduce using rule 415 (select_alt -> accept_stmt stmts_opt .)
    ELSIF           reduce using rule 415 (select_alt -> accept_stmt stmts_opt .)
    END             reduce using rule 415 (select_alt -> accept_stmt stmts_opt .)


state 566

    (424) stmts_opt -> statement_s .
    (244) statement_s -> statement_s . statement
    (245) statement -> . unlabeled
    (246) statement -> . label statement
    (247) unlabeled -> . simple_stmt
    (248) unlabeled -> . compound_stmt
    (249) unlabeled -> . pragma
    (268) label -> . LLB IDENTIFIER RLB
    (250) simple_stmt -> . NULL_stmt
    (251) simple_stmt -> . assign_stmt
    (252) simple_stmt -> . exit_stmt
    (253) simple_stmt -> . return_stmt
    (254) simple_stmt -> . goto_stmt
    (255) simple_stmt -> . procedure_call
    (256) simple_stmt -> . delay_stmt
    (257) simple_stmt -> . abort_stmt
    (258) simple_stmt -> . raise_stmt
    (259) simple_stmt -> . code_stmt
    (260) simple_stmt -> . requeue_stmt
    (261) simple_stmt -> . error SEMICOLON
    (262) compound_stmt -> . if_stmt
    (263) compound_stmt -> . case_stmt
    (264) compound_stmt -> . loop_stmt
    (265) compound_stmt -> . block
    (266) compound_stmt -> . accept_stmt
    (267) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (269) NULL_stmt -> . NULL SEMICOLON
    (270) assign_stmt -> . name IS_ASSIGNED expression SEMICOLON
    (302) exit_stmt -> . EXIT name_opt when_opt SEMICOLON
    (307) return_stmt -> . RETURN SEMICOLON
    (308) return_stmt -> . RETURN expression SEMICOLON
    (309) goto_stmt -> . GOTO name SEMICOLON
    (332) procedure_call -> . name SEMICOLON
    (404) delay_stmt -> . DELAY expression SEMICOLON
    (405) delay_stmt -> . DELAY UNTIL expression SEMICOLON
    (425) abort_stmt -> . ABORT name_s SEMICOLON
    (464) raise_stmt -> . RAISE name_opt SEMICOLON
    (510) code_stmt -> . qualified SEMICOLON
    (465) requeue_stmt -> . REQUEUE name SEMICOLON
    (466) requeue_stmt -> . REQUEUE name WITH ABORT SEMICOLON
    (271) if_stmt -> . IF cond_clause else_opt END IF SEMICOLON
    (278) case_stmt -> . case_hdr alternative_s END CASE SEMICOLON
    (283) loop_stmt -> . label_opt iteration basic_loop id_opt SEMICOLON
    (295) block -> . label_opt block_decl block_body END id_opt SEMICOLON
    (399) accept_stmt -> . accept_hdr SEMICOLON
    (400) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt SEMICOLON
    (406) select_stmt -> . select_wait
    (407) select_stmt -> . async_select
    (408) select_stmt -> . timed_entry_call
    (409) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (240) qualified -> . name TICK parenthesized_primary
    (279) case_hdr -> . CASE expression IS
    (284) label_opt -> .
    (285) label_opt -> . IDENTIFIER COLON
    (401) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (410) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON
    (420) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON
    (421) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON
    (422) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    OR              reduce using rule 424 (stmts_opt -> statement_s .)
    ELSE            reduce using rule 424 (stmts_opt -> statement_s .)
    THEN            reduce using rule 424 (stmts_opt -> statement_s .)
    ELSIF           reduce using rule 424 (stmts_opt -> statement_s .)
    END             reduce using rule 424 (stmts_opt -> statement_s .)
    LLB             shift and go to state 289
    error           shift and go to state 309
    PRAGMA          shift and go to state 4
    NULL            shift and go to state 311
    EXIT            shift and go to state 308
    RETURN          shift and go to state 295
    GOTO            shift and go to state 276
    DELAY           shift and go to state 272
    ABORT           shift and go to state 282
    RAISE           shift and go to state 306
    REQUEUE         shift and go to state 298
    IF              shift and go to state 317
    CASE            shift and go to state 297
    WHILE           reduce using rule 284 (label_opt -> .)
    DECLARE         reduce using rule 284 (label_opt -> .)
    FOR             reduce using rule 284 (label_opt -> .)
    LOOP            reduce using rule 284 (label_opt -> .)
    BEGIN           reduce using rule 284 (label_opt -> .)
    IDENTIFIER      shift and go to state 300
    ACCEPT          shift and go to state 284
    SELECT          shift and go to state 286
    STRING          shift and go to state 137

    indexed_comp                   shift and go to state 119
    accept_stmt                    shift and go to state 283
    label_opt                      shift and go to state 275
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 316
    abort_stmt                     shift and go to state 310
    return_stmt                    shift and go to state 294
    procedure_call                 shift and go to state 285
    assign_stmt                    shift and go to state 320
    simple_name                    shift and go to state 153
    code_stmt                      shift and go to state 313
    case_stmt                      shift and go to state 287
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 146
    label                          shift and go to state 288
    exit_stmt                      shift and go to state 315
    select_stmt                    shift and go to state 274
    statement                      shift and go to state 465
    compound_stmt                  shift and go to state 290
    case_hdr                       shift and go to state 292
    delay_stmt                     shift and go to state 301
    unlabeled                      shift and go to state 314
    simple_stmt                    shift and go to state 277
    loop_stmt                      shift and go to state 278
    qualified                      shift and go to state 279
    pragma                         shift and go to state 303
    async_select                   shift and go to state 273
    requeue_stmt                   shift and go to state 304
    raise_stmt                     shift and go to state 305
    name                           shift and go to state 281
    if_stmt                        shift and go to state 280
    accept_hdr                     shift and go to state 302
    cond_entry_call                shift and go to state 318
    timed_entry_call               shift and go to state 307
    goto_stmt                      shift and go to state 291
    NULL_stmt                      shift and go to state 319
    block                          shift and go to state 293

state 567

    (421) timed_entry_call -> SELECT entry_call stmts_opt . OR delay_stmt stmts_opt END SELECT SEMICOLON
    (422) cond_entry_call -> SELECT entry_call stmts_opt . ELSE statement_s END SELECT SEMICOLON
    (419) delay_or_entry_alt -> entry_call stmts_opt .

    OR              shift and go to state 694
    ELSE            shift and go to state 693
    THEN            reduce using rule 419 (delay_or_entry_alt -> entry_call stmts_opt .)


state 568

    (420) async_select -> SELECT delay_or_entry_alt THEN . ABORT statement_s END SELECT SEMICOLON

    ABORT           shift and go to state 695


state 569

    (412) guarded_select_alt -> WHEN condition . ARROW select_alt

    ARROW           shift and go to state 696


state 570

    (410) select_wait -> SELECT guarded_select_alt or_select . else_opt END SELECT SEMICOLON
    (414) or_select -> or_select . OR guarded_select_alt
    (275) else_opt -> .
    (276) else_opt -> . ELSE statement_s
    (277) else_opt -> . ELSIF cond_clause else_opt

    OR              shift and go to state 698
    END             reduce using rule 275 (else_opt -> .)
    ELSE            shift and go to state 588
    ELSIF           shift and go to state 590

    else_opt                       shift and go to state 697

state 571

    (418) delay_or_entry_alt -> delay_stmt stmts_opt .
    (416) select_alt -> delay_stmt stmts_opt .

    THEN            reduce using rule 418 (delay_or_entry_alt -> delay_stmt stmts_opt .)
    OR              reduce using rule 416 (select_alt -> delay_stmt stmts_opt .)
    ELSE            reduce using rule 416 (select_alt -> delay_stmt stmts_opt .)
    ELSIF           reduce using rule 416 (select_alt -> delay_stmt stmts_opt .)
    END             reduce using rule 416 (select_alt -> delay_stmt stmts_opt .)


state 572

    (417) select_alt -> TERMINATE SEMICOLON .

    OR              reduce using rule 417 (select_alt -> TERMINATE SEMICOLON .)
    ELSE            reduce using rule 417 (select_alt -> TERMINATE SEMICOLON .)
    ELSIF           reduce using rule 417 (select_alt -> TERMINATE SEMICOLON .)
    END             reduce using rule 417 (select_alt -> TERMINATE SEMICOLON .)


state 573

    (268) label -> LLB IDENTIFIER RLB .

    LLB             reduce using rule 268 (label -> LLB IDENTIFIER RLB .)
    error           reduce using rule 268 (label -> LLB IDENTIFIER RLB .)
    PRAGMA          reduce using rule 268 (label -> LLB IDENTIFIER RLB .)
    NULL            reduce using rule 268 (label -> LLB IDENTIFIER RLB .)
    EXIT            reduce using rule 268 (label -> LLB IDENTIFIER RLB .)
    RETURN          reduce using rule 268 (label -> LLB IDENTIFIER RLB .)
    GOTO            reduce using rule 268 (label -> LLB IDENTIFIER RLB .)
    DELAY           reduce using rule 268 (label -> LLB IDENTIFIER RLB .)
    ABORT           reduce using rule 268 (label -> LLB IDENTIFIER RLB .)
    RAISE           reduce using rule 268 (label -> LLB IDENTIFIER RLB .)
    REQUEUE         reduce using rule 268 (label -> LLB IDENTIFIER RLB .)
    IF              reduce using rule 268 (label -> LLB IDENTIFIER RLB .)
    CASE            reduce using rule 268 (label -> LLB IDENTIFIER RLB .)
    IDENTIFIER      reduce using rule 268 (label -> LLB IDENTIFIER RLB .)
    ACCEPT          reduce using rule 268 (label -> LLB IDENTIFIER RLB .)
    SELECT          reduce using rule 268 (label -> LLB IDENTIFIER RLB .)
    STRING          reduce using rule 268 (label -> LLB IDENTIFIER RLB .)
    WHILE           reduce using rule 268 (label -> LLB IDENTIFIER RLB .)
    DECLARE         reduce using rule 268 (label -> LLB IDENTIFIER RLB .)
    FOR             reduce using rule 268 (label -> LLB IDENTIFIER RLB .)
    LOOP            reduce using rule 268 (label -> LLB IDENTIFIER RLB .)
    BEGIN           reduce using rule 268 (label -> LLB IDENTIFIER RLB .)


state 574

    (278) case_stmt -> case_hdr alternative_s END . CASE SEMICOLON

    CASE            shift and go to state 699


state 575

    (282) alternative -> WHEN . choice_s ARROW statement_s
    (121) choice_s -> . choice
    (122) choice_s -> . choice_s | choice
    (123) choice -> . expression
    (124) choice -> . discrete_with_range
    (125) choice -> . OTHERS
    (195) expression -> . relation
    (196) expression -> . expression logical relation
    (197) expression -> . expression short_circuit relation
    (126) discrete_with_range -> . name range_constraint
    (127) discrete_with_range -> . range
    (203) relation -> . simple_expression
    (204) relation -> . simple_expression relational simple_expression
    (205) relation -> . simple_expression membership range
    (206) relation -> . simple_expression membership name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (60) range -> . simple_expression DOUBLEDOT simple_expression
    (61) range -> . name TICK RANGE
    (62) range -> . name TICK RANGE LPAREN expression RPAREN
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN

    OTHERS          shift and go to state 222
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137
    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    relation                       shift and go to state 127
    simple_expression              shift and go to state 379
    indexed_comp                   shift and go to state 119
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    allocator                      shift and go to state 132
    choice_s                       shift and go to state 700
    factor                         shift and go to state 136
    choice                         shift and go to state 227
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    discrete_with_range            shift and go to state 515
    term                           shift and go to state 144
    name                           shift and go to state 230
    operator_symbol                shift and go to state 146
    range                          shift and go to state 232
    expression                     shift and go to state 516

state 576

    (281) alternative_s -> alternative_s alternative .

    END             reduce using rule 281 (alternative_s -> alternative_s alternative .)
    WHEN            reduce using rule 281 (alternative_s -> alternative_s alternative .)


state 577

    (308) return_stmt -> RETURN expression SEMICOLON .

    LLB             reduce using rule 308 (return_stmt -> RETURN expression SEMICOLON .)
    error           reduce using rule 308 (return_stmt -> RETURN expression SEMICOLON .)
    PRAGMA          reduce using rule 308 (return_stmt -> RETURN expression SEMICOLON .)
    NULL            reduce using rule 308 (return_stmt -> RETURN expression SEMICOLON .)
    EXIT            reduce using rule 308 (return_stmt -> RETURN expression SEMICOLON .)
    RETURN          reduce using rule 308 (return_stmt -> RETURN expression SEMICOLON .)
    GOTO            reduce using rule 308 (return_stmt -> RETURN expression SEMICOLON .)
    DELAY           reduce using rule 308 (return_stmt -> RETURN expression SEMICOLON .)
    ABORT           reduce using rule 308 (return_stmt -> RETURN expression SEMICOLON .)
    RAISE           reduce using rule 308 (return_stmt -> RETURN expression SEMICOLON .)
    REQUEUE         reduce using rule 308 (return_stmt -> RETURN expression SEMICOLON .)
    IF              reduce using rule 308 (return_stmt -> RETURN expression SEMICOLON .)
    CASE            reduce using rule 308 (return_stmt -> RETURN expression SEMICOLON .)
    IDENTIFIER      reduce using rule 308 (return_stmt -> RETURN expression SEMICOLON .)
    ACCEPT          reduce using rule 308 (return_stmt -> RETURN expression SEMICOLON .)
    SELECT          reduce using rule 308 (return_stmt -> RETURN expression SEMICOLON .)
    STRING          reduce using rule 308 (return_stmt -> RETURN expression SEMICOLON .)
    WHILE           reduce using rule 308 (return_stmt -> RETURN expression SEMICOLON .)
    DECLARE         reduce using rule 308 (return_stmt -> RETURN expression SEMICOLON .)
    FOR             reduce using rule 308 (return_stmt -> RETURN expression SEMICOLON .)
    LOOP            reduce using rule 308 (return_stmt -> RETURN expression SEMICOLON .)
    BEGIN           reduce using rule 308 (return_stmt -> RETURN expression SEMICOLON .)
    THEN            reduce using rule 308 (return_stmt -> RETURN expression SEMICOLON .)
    OR              reduce using rule 308 (return_stmt -> RETURN expression SEMICOLON .)
    ELSE            reduce using rule 308 (return_stmt -> RETURN expression SEMICOLON .)
    ELSIF           reduce using rule 308 (return_stmt -> RETURN expression SEMICOLON .)
    END             reduce using rule 308 (return_stmt -> RETURN expression SEMICOLON .)
    EXCEPTION       reduce using rule 308 (return_stmt -> RETURN expression SEMICOLON .)
    WHEN            reduce using rule 308 (return_stmt -> RETURN expression SEMICOLON .)


state 578

    (279) case_hdr -> CASE expression IS .

    END             reduce using rule 279 (case_hdr -> CASE expression IS .)
    WHEN            reduce using rule 279 (case_hdr -> CASE expression IS .)


state 579

    (465) requeue_stmt -> REQUEUE name SEMICOLON .

    LLB             reduce using rule 465 (requeue_stmt -> REQUEUE name SEMICOLON .)
    error           reduce using rule 465 (requeue_stmt -> REQUEUE name SEMICOLON .)
    PRAGMA          reduce using rule 465 (requeue_stmt -> REQUEUE name SEMICOLON .)
    NULL            reduce using rule 465 (requeue_stmt -> REQUEUE name SEMICOLON .)
    EXIT            reduce using rule 465 (requeue_stmt -> REQUEUE name SEMICOLON .)
    RETURN          reduce using rule 465 (requeue_stmt -> REQUEUE name SEMICOLON .)
    GOTO            reduce using rule 465 (requeue_stmt -> REQUEUE name SEMICOLON .)
    DELAY           reduce using rule 465 (requeue_stmt -> REQUEUE name SEMICOLON .)
    ABORT           reduce using rule 465 (requeue_stmt -> REQUEUE name SEMICOLON .)
    RAISE           reduce using rule 465 (requeue_stmt -> REQUEUE name SEMICOLON .)
    REQUEUE         reduce using rule 465 (requeue_stmt -> REQUEUE name SEMICOLON .)
    IF              reduce using rule 465 (requeue_stmt -> REQUEUE name SEMICOLON .)
    CASE            reduce using rule 465 (requeue_stmt -> REQUEUE name SEMICOLON .)
    IDENTIFIER      reduce using rule 465 (requeue_stmt -> REQUEUE name SEMICOLON .)
    ACCEPT          reduce using rule 465 (requeue_stmt -> REQUEUE name SEMICOLON .)
    SELECT          reduce using rule 465 (requeue_stmt -> REQUEUE name SEMICOLON .)
    STRING          reduce using rule 465 (requeue_stmt -> REQUEUE name SEMICOLON .)
    WHILE           reduce using rule 465 (requeue_stmt -> REQUEUE name SEMICOLON .)
    DECLARE         reduce using rule 465 (requeue_stmt -> REQUEUE name SEMICOLON .)
    FOR             reduce using rule 465 (requeue_stmt -> REQUEUE name SEMICOLON .)
    LOOP            reduce using rule 465 (requeue_stmt -> REQUEUE name SEMICOLON .)
    BEGIN           reduce using rule 465 (requeue_stmt -> REQUEUE name SEMICOLON .)
    ELSE            reduce using rule 465 (requeue_stmt -> REQUEUE name SEMICOLON .)
    ELSIF           reduce using rule 465 (requeue_stmt -> REQUEUE name SEMICOLON .)
    END             reduce using rule 465 (requeue_stmt -> REQUEUE name SEMICOLON .)
    WHEN            reduce using rule 465 (requeue_stmt -> REQUEUE name SEMICOLON .)
    EXCEPTION       reduce using rule 465 (requeue_stmt -> REQUEUE name SEMICOLON .)
    OR              reduce using rule 465 (requeue_stmt -> REQUEUE name SEMICOLON .)
    THEN            reduce using rule 465 (requeue_stmt -> REQUEUE name SEMICOLON .)


state 580

    (466) requeue_stmt -> REQUEUE name WITH . ABORT SEMICOLON

    ABORT           shift and go to state 701


state 581

    (400) accept_stmt -> accept_hdr DO handled_stmt_s . END id_opt SEMICOLON

    END             shift and go to state 702


state 582

    (464) raise_stmt -> RAISE name_opt SEMICOLON .

    LLB             reduce using rule 464 (raise_stmt -> RAISE name_opt SEMICOLON .)
    error           reduce using rule 464 (raise_stmt -> RAISE name_opt SEMICOLON .)
    PRAGMA          reduce using rule 464 (raise_stmt -> RAISE name_opt SEMICOLON .)
    NULL            reduce using rule 464 (raise_stmt -> RAISE name_opt SEMICOLON .)
    EXIT            reduce using rule 464 (raise_stmt -> RAISE name_opt SEMICOLON .)
    RETURN          reduce using rule 464 (raise_stmt -> RAISE name_opt SEMICOLON .)
    GOTO            reduce using rule 464 (raise_stmt -> RAISE name_opt SEMICOLON .)
    DELAY           reduce using rule 464 (raise_stmt -> RAISE name_opt SEMICOLON .)
    ABORT           reduce using rule 464 (raise_stmt -> RAISE name_opt SEMICOLON .)
    RAISE           reduce using rule 464 (raise_stmt -> RAISE name_opt SEMICOLON .)
    REQUEUE         reduce using rule 464 (raise_stmt -> RAISE name_opt SEMICOLON .)
    IF              reduce using rule 464 (raise_stmt -> RAISE name_opt SEMICOLON .)
    CASE            reduce using rule 464 (raise_stmt -> RAISE name_opt SEMICOLON .)
    IDENTIFIER      reduce using rule 464 (raise_stmt -> RAISE name_opt SEMICOLON .)
    ACCEPT          reduce using rule 464 (raise_stmt -> RAISE name_opt SEMICOLON .)
    SELECT          reduce using rule 464 (raise_stmt -> RAISE name_opt SEMICOLON .)
    STRING          reduce using rule 464 (raise_stmt -> RAISE name_opt SEMICOLON .)
    WHILE           reduce using rule 464 (raise_stmt -> RAISE name_opt SEMICOLON .)
    DECLARE         reduce using rule 464 (raise_stmt -> RAISE name_opt SEMICOLON .)
    FOR             reduce using rule 464 (raise_stmt -> RAISE name_opt SEMICOLON .)
    LOOP            reduce using rule 464 (raise_stmt -> RAISE name_opt SEMICOLON .)
    BEGIN           reduce using rule 464 (raise_stmt -> RAISE name_opt SEMICOLON .)
    END             reduce using rule 464 (raise_stmt -> RAISE name_opt SEMICOLON .)
    EXCEPTION       reduce using rule 464 (raise_stmt -> RAISE name_opt SEMICOLON .)
    WHEN            reduce using rule 464 (raise_stmt -> RAISE name_opt SEMICOLON .)
    ELSE            reduce using rule 464 (raise_stmt -> RAISE name_opt SEMICOLON .)
    ELSIF           reduce using rule 464 (raise_stmt -> RAISE name_opt SEMICOLON .)
    OR              reduce using rule 464 (raise_stmt -> RAISE name_opt SEMICOLON .)
    THEN            reduce using rule 464 (raise_stmt -> RAISE name_opt SEMICOLON .)


state 583

    (302) exit_stmt -> EXIT name_opt when_opt . SEMICOLON

    SEMICOLON       shift and go to state 703


state 584

    (306) when_opt -> WHEN . condition
    (274) condition -> . expression
    (195) expression -> . relation
    (196) expression -> . expression logical relation
    (197) expression -> . expression short_circuit relation
    (203) relation -> . simple_expression
    (204) relation -> . simple_expression relational simple_expression
    (205) relation -> . simple_expression membership range
    (206) relation -> . simple_expression membership name
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    relation                       shift and go to state 127
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    factor                         shift and go to state 136
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    condition                      shift and go to state 704
    term                           shift and go to state 144
    name                           shift and go to state 145
    operator_symbol                shift and go to state 146
    expression                     shift and go to state 470

state 585

    (457) except_handler_part -> except_handler_part exception_handler .

    WHEN            reduce using rule 457 (except_handler_part -> except_handler_part exception_handler .)
    END             reduce using rule 457 (except_handler_part -> except_handler_part exception_handler .)


state 586

    (458) exception_handler -> WHEN . except_choice_s ARROW statement_s
    (459) exception_handler -> WHEN . IDENTIFIER COLON except_choice_s ARROW statement_s
    (460) except_choice_s -> . except_choice
    (461) except_choice_s -> . except_choice_s | except_choice
    (462) except_choice -> . name
    (463) except_choice -> . OTHERS
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 705
    OTHERS          shift and go to state 707
    STRING          shift and go to state 137

    name                           shift and go to state 708
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 146
    except_choice_s                shift and go to state 709
    except_choice                  shift and go to state 706
    indexed_comp                   shift and go to state 119
    simple_name                    shift and go to state 153

state 587

    (456) except_handler_part -> EXCEPTION exception_handler .

    WHEN            reduce using rule 456 (except_handler_part -> EXCEPTION exception_handler .)
    END             reduce using rule 456 (except_handler_part -> EXCEPTION exception_handler .)


state 588

    (276) else_opt -> ELSE . statement_s
    (243) statement_s -> . statement
    (244) statement_s -> . statement_s statement
    (245) statement -> . unlabeled
    (246) statement -> . label statement
    (247) unlabeled -> . simple_stmt
    (248) unlabeled -> . compound_stmt
    (249) unlabeled -> . pragma
    (268) label -> . LLB IDENTIFIER RLB
    (250) simple_stmt -> . NULL_stmt
    (251) simple_stmt -> . assign_stmt
    (252) simple_stmt -> . exit_stmt
    (253) simple_stmt -> . return_stmt
    (254) simple_stmt -> . goto_stmt
    (255) simple_stmt -> . procedure_call
    (256) simple_stmt -> . delay_stmt
    (257) simple_stmt -> . abort_stmt
    (258) simple_stmt -> . raise_stmt
    (259) simple_stmt -> . code_stmt
    (260) simple_stmt -> . requeue_stmt
    (261) simple_stmt -> . error SEMICOLON
    (262) compound_stmt -> . if_stmt
    (263) compound_stmt -> . case_stmt
    (264) compound_stmt -> . loop_stmt
    (265) compound_stmt -> . block
    (266) compound_stmt -> . accept_stmt
    (267) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (269) NULL_stmt -> . NULL SEMICOLON
    (270) assign_stmt -> . name IS_ASSIGNED expression SEMICOLON
    (302) exit_stmt -> . EXIT name_opt when_opt SEMICOLON
    (307) return_stmt -> . RETURN SEMICOLON
    (308) return_stmt -> . RETURN expression SEMICOLON
    (309) goto_stmt -> . GOTO name SEMICOLON
    (332) procedure_call -> . name SEMICOLON
    (404) delay_stmt -> . DELAY expression SEMICOLON
    (405) delay_stmt -> . DELAY UNTIL expression SEMICOLON
    (425) abort_stmt -> . ABORT name_s SEMICOLON
    (464) raise_stmt -> . RAISE name_opt SEMICOLON
    (510) code_stmt -> . qualified SEMICOLON
    (465) requeue_stmt -> . REQUEUE name SEMICOLON
    (466) requeue_stmt -> . REQUEUE name WITH ABORT SEMICOLON
    (271) if_stmt -> . IF cond_clause else_opt END IF SEMICOLON
    (278) case_stmt -> . case_hdr alternative_s END CASE SEMICOLON
    (283) loop_stmt -> . label_opt iteration basic_loop id_opt SEMICOLON
    (295) block -> . label_opt block_decl block_body END id_opt SEMICOLON
    (399) accept_stmt -> . accept_hdr SEMICOLON
    (400) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt SEMICOLON
    (406) select_stmt -> . select_wait
    (407) select_stmt -> . async_select
    (408) select_stmt -> . timed_entry_call
    (409) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (240) qualified -> . name TICK parenthesized_primary
    (279) case_hdr -> . CASE expression IS
    (284) label_opt -> .
    (285) label_opt -> . IDENTIFIER COLON
    (401) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (410) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON
    (420) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON
    (421) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON
    (422) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    LLB             shift and go to state 289
    error           shift and go to state 309
    PRAGMA          shift and go to state 4
    NULL            shift and go to state 311
    EXIT            shift and go to state 308
    RETURN          shift and go to state 295
    GOTO            shift and go to state 276
    DELAY           shift and go to state 272
    ABORT           shift and go to state 282
    RAISE           shift and go to state 306
    REQUEUE         shift and go to state 298
    IF              shift and go to state 317
    CASE            shift and go to state 297
    WHILE           reduce using rule 284 (label_opt -> .)
    DECLARE         reduce using rule 284 (label_opt -> .)
    FOR             reduce using rule 284 (label_opt -> .)
    LOOP            reduce using rule 284 (label_opt -> .)
    BEGIN           reduce using rule 284 (label_opt -> .)
    IDENTIFIER      shift and go to state 300
    ACCEPT          shift and go to state 284
    SELECT          shift and go to state 286
    STRING          shift and go to state 137

    indexed_comp                   shift and go to state 119
    accept_stmt                    shift and go to state 283
    label_opt                      shift and go to state 275
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 316
    abort_stmt                     shift and go to state 310
    return_stmt                    shift and go to state 294
    procedure_call                 shift and go to state 285
    assign_stmt                    shift and go to state 320
    statement_s                    shift and go to state 710
    simple_name                    shift and go to state 153
    code_stmt                      shift and go to state 313
    case_stmt                      shift and go to state 287
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 146
    label                          shift and go to state 288
    exit_stmt                      shift and go to state 315
    select_stmt                    shift and go to state 274
    statement                      shift and go to state 299
    compound_stmt                  shift and go to state 290
    case_hdr                       shift and go to state 292
    delay_stmt                     shift and go to state 301
    unlabeled                      shift and go to state 314
    simple_stmt                    shift and go to state 277
    loop_stmt                      shift and go to state 278
    qualified                      shift and go to state 279
    pragma                         shift and go to state 303
    async_select                   shift and go to state 273
    requeue_stmt                   shift and go to state 304
    raise_stmt                     shift and go to state 305
    name                           shift and go to state 281
    if_stmt                        shift and go to state 280
    accept_hdr                     shift and go to state 302
    cond_entry_call                shift and go to state 318
    timed_entry_call               shift and go to state 307
    goto_stmt                      shift and go to state 291
    NULL_stmt                      shift and go to state 319
    block                          shift and go to state 293

state 589

    (271) if_stmt -> IF cond_clause else_opt . END IF SEMICOLON

    END             shift and go to state 711


state 590

    (277) else_opt -> ELSIF . cond_clause else_opt
    (272) cond_clause -> . cond_part statement_s
    (273) cond_part -> . condition THEN
    (274) condition -> . expression
    (195) expression -> . relation
    (196) expression -> . expression logical relation
    (197) expression -> . expression short_circuit relation
    (203) relation -> . simple_expression
    (204) relation -> . simple_expression relational simple_expression
    (205) relation -> . simple_expression membership range
    (206) relation -> . simple_expression membership name
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    relation                       shift and go to state 127
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    cond_clause                    shift and go to state 712
    cond_part                      shift and go to state 468
    literal                        shift and go to state 135
    factor                         shift and go to state 136
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    condition                      shift and go to state 469
    term                           shift and go to state 144
    name                           shift and go to state 145
    operator_symbol                shift and go to state 146
    expression                     shift and go to state 470

state 591

    (272) cond_clause -> cond_part statement_s .
    (244) statement_s -> statement_s . statement
    (245) statement -> . unlabeled
    (246) statement -> . label statement
    (247) unlabeled -> . simple_stmt
    (248) unlabeled -> . compound_stmt
    (249) unlabeled -> . pragma
    (268) label -> . LLB IDENTIFIER RLB
    (250) simple_stmt -> . NULL_stmt
    (251) simple_stmt -> . assign_stmt
    (252) simple_stmt -> . exit_stmt
    (253) simple_stmt -> . return_stmt
    (254) simple_stmt -> . goto_stmt
    (255) simple_stmt -> . procedure_call
    (256) simple_stmt -> . delay_stmt
    (257) simple_stmt -> . abort_stmt
    (258) simple_stmt -> . raise_stmt
    (259) simple_stmt -> . code_stmt
    (260) simple_stmt -> . requeue_stmt
    (261) simple_stmt -> . error SEMICOLON
    (262) compound_stmt -> . if_stmt
    (263) compound_stmt -> . case_stmt
    (264) compound_stmt -> . loop_stmt
    (265) compound_stmt -> . block
    (266) compound_stmt -> . accept_stmt
    (267) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (269) NULL_stmt -> . NULL SEMICOLON
    (270) assign_stmt -> . name IS_ASSIGNED expression SEMICOLON
    (302) exit_stmt -> . EXIT name_opt when_opt SEMICOLON
    (307) return_stmt -> . RETURN SEMICOLON
    (308) return_stmt -> . RETURN expression SEMICOLON
    (309) goto_stmt -> . GOTO name SEMICOLON
    (332) procedure_call -> . name SEMICOLON
    (404) delay_stmt -> . DELAY expression SEMICOLON
    (405) delay_stmt -> . DELAY UNTIL expression SEMICOLON
    (425) abort_stmt -> . ABORT name_s SEMICOLON
    (464) raise_stmt -> . RAISE name_opt SEMICOLON
    (510) code_stmt -> . qualified SEMICOLON
    (465) requeue_stmt -> . REQUEUE name SEMICOLON
    (466) requeue_stmt -> . REQUEUE name WITH ABORT SEMICOLON
    (271) if_stmt -> . IF cond_clause else_opt END IF SEMICOLON
    (278) case_stmt -> . case_hdr alternative_s END CASE SEMICOLON
    (283) loop_stmt -> . label_opt iteration basic_loop id_opt SEMICOLON
    (295) block -> . label_opt block_decl block_body END id_opt SEMICOLON
    (399) accept_stmt -> . accept_hdr SEMICOLON
    (400) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt SEMICOLON
    (406) select_stmt -> . select_wait
    (407) select_stmt -> . async_select
    (408) select_stmt -> . timed_entry_call
    (409) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (240) qualified -> . name TICK parenthesized_primary
    (279) case_hdr -> . CASE expression IS
    (284) label_opt -> .
    (285) label_opt -> . IDENTIFIER COLON
    (401) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (410) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON
    (420) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON
    (421) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON
    (422) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    ELSE            reduce using rule 272 (cond_clause -> cond_part statement_s .)
    ELSIF           reduce using rule 272 (cond_clause -> cond_part statement_s .)
    END             reduce using rule 272 (cond_clause -> cond_part statement_s .)
    LLB             shift and go to state 289
    error           shift and go to state 309
    PRAGMA          shift and go to state 4
    NULL            shift and go to state 311
    EXIT            shift and go to state 308
    RETURN          shift and go to state 295
    GOTO            shift and go to state 276
    DELAY           shift and go to state 272
    ABORT           shift and go to state 282
    RAISE           shift and go to state 306
    REQUEUE         shift and go to state 298
    IF              shift and go to state 317
    CASE            shift and go to state 297
    WHILE           reduce using rule 284 (label_opt -> .)
    DECLARE         reduce using rule 284 (label_opt -> .)
    FOR             reduce using rule 284 (label_opt -> .)
    LOOP            reduce using rule 284 (label_opt -> .)
    BEGIN           reduce using rule 284 (label_opt -> .)
    IDENTIFIER      shift and go to state 300
    ACCEPT          shift and go to state 284
    SELECT          shift and go to state 286
    STRING          shift and go to state 137

    indexed_comp                   shift and go to state 119
    accept_stmt                    shift and go to state 283
    label_opt                      shift and go to state 275
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 316
    abort_stmt                     shift and go to state 310
    return_stmt                    shift and go to state 294
    procedure_call                 shift and go to state 285
    assign_stmt                    shift and go to state 320
    simple_name                    shift and go to state 153
    code_stmt                      shift and go to state 313
    case_stmt                      shift and go to state 287
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 146
    label                          shift and go to state 288
    exit_stmt                      shift and go to state 315
    select_stmt                    shift and go to state 274
    statement                      shift and go to state 465
    compound_stmt                  shift and go to state 290
    case_hdr                       shift and go to state 292
    delay_stmt                     shift and go to state 301
    unlabeled                      shift and go to state 314
    simple_stmt                    shift and go to state 277
    loop_stmt                      shift and go to state 278
    qualified                      shift and go to state 279
    pragma                         shift and go to state 303
    async_select                   shift and go to state 273
    requeue_stmt                   shift and go to state 304
    raise_stmt                     shift and go to state 305
    name                           shift and go to state 281
    if_stmt                        shift and go to state 280
    accept_hdr                     shift and go to state 302
    cond_entry_call                shift and go to state 318
    timed_entry_call               shift and go to state 307
    goto_stmt                      shift and go to state 291
    NULL_stmt                      shift and go to state 319
    block                          shift and go to state 293

state 592

    (273) cond_part -> condition THEN .

    LLB             reduce using rule 273 (cond_part -> condition THEN .)
    error           reduce using rule 273 (cond_part -> condition THEN .)
    PRAGMA          reduce using rule 273 (cond_part -> condition THEN .)
    NULL            reduce using rule 273 (cond_part -> condition THEN .)
    EXIT            reduce using rule 273 (cond_part -> condition THEN .)
    RETURN          reduce using rule 273 (cond_part -> condition THEN .)
    GOTO            reduce using rule 273 (cond_part -> condition THEN .)
    DELAY           reduce using rule 273 (cond_part -> condition THEN .)
    ABORT           reduce using rule 273 (cond_part -> condition THEN .)
    RAISE           reduce using rule 273 (cond_part -> condition THEN .)
    REQUEUE         reduce using rule 273 (cond_part -> condition THEN .)
    IF              reduce using rule 273 (cond_part -> condition THEN .)
    CASE            reduce using rule 273 (cond_part -> condition THEN .)
    IDENTIFIER      reduce using rule 273 (cond_part -> condition THEN .)
    ACCEPT          reduce using rule 273 (cond_part -> condition THEN .)
    SELECT          reduce using rule 273 (cond_part -> condition THEN .)
    STRING          reduce using rule 273 (cond_part -> condition THEN .)
    WHILE           reduce using rule 273 (cond_part -> condition THEN .)
    DECLARE         reduce using rule 273 (cond_part -> condition THEN .)
    FOR             reduce using rule 273 (cond_part -> condition THEN .)
    LOOP            reduce using rule 273 (cond_part -> condition THEN .)
    BEGIN           reduce using rule 273 (cond_part -> condition THEN .)


state 593

    (331) subprog_body -> subprog_spec_is_push decl_part block_body END id_opt SEMICOLON .

    PRIVATE         reduce using rule 331 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt SEMICOLON .)
    WITH            reduce using rule 331 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt SEMICOLON .)
    PACKAGE         reduce using rule 331 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt SEMICOLON .)
    SEPARATE        reduce using rule 331 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt SEMICOLON .)
    PROCEDURE       reduce using rule 331 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt SEMICOLON .)
    FUNCTION        reduce using rule 331 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt SEMICOLON .)
    GENERIC         reduce using rule 331 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt SEMICOLON .)
    $end            reduce using rule 331 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt SEMICOLON .)
    TASK            reduce using rule 331 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt SEMICOLON .)
    PROTECTED       reduce using rule 331 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt SEMICOLON .)
    error           reduce using rule 331 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt SEMICOLON .)
    USE             reduce using rule 331 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt SEMICOLON .)
    PRAGMA          reduce using rule 331 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt SEMICOLON .)
    TYPE            reduce using rule 331 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt SEMICOLON .)
    SUBTYPE         reduce using rule 331 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt SEMICOLON .)
    FOR             reduce using rule 331 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt SEMICOLON .)
    IDENTIFIER      reduce using rule 331 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt SEMICOLON .)
    BEGIN           reduce using rule 331 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt SEMICOLON .)
    END             reduce using rule 331 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt SEMICOLON .)
    ENTRY           reduce using rule 331 (subprog_body -> subprog_spec_is_push decl_part block_body END id_opt SEMICOLON .)


state 594

    (504) record_type_spec -> FOR mark USE RECORD align_opt . comp_loc_s END RECORD SEMICOLON
    (507) comp_loc_s -> .
    (508) comp_loc_s -> . comp_loc_s mark AT expression RANGE range SEMICOLON

    END             reduce using rule 507 (comp_loc_s -> .)
    IDENTIFIER      reduce using rule 507 (comp_loc_s -> .)

    comp_loc_s                     shift and go to state 713

state 595

    (506) align_opt -> AT . MOD expression SEMICOLON

    MOD             shift and go to state 714


state 596

    (509) address_spec -> FOR mark USE AT expression . SEMICOLON
    (196) expression -> expression . logical relation
    (197) expression -> expression . short_circuit relation
    (198) logical -> . AND
    (199) logical -> . OR
    (200) logical -> . XOR
    (201) short_circuit -> . AND THEN
    (202) short_circuit -> . OR ELSE

    SEMICOLON       shift and go to state 715
    AND             shift and go to state 244
    OR              shift and go to state 248
    XOR             shift and go to state 245

    short_circuit                  shift and go to state 247
    logical                        shift and go to state 246

state 597

    (503) attrib_def -> FOR mark USE expression SEMICOLON .

    PRAGMA          reduce using rule 503 (attrib_def -> FOR mark USE expression SEMICOLON .)
    FOR             reduce using rule 503 (attrib_def -> FOR mark USE expression SEMICOLON .)
    END             reduce using rule 503 (attrib_def -> FOR mark USE expression SEMICOLON .)
    error           reduce using rule 503 (attrib_def -> FOR mark USE expression SEMICOLON .)
    USE             reduce using rule 503 (attrib_def -> FOR mark USE expression SEMICOLON .)
    TYPE            reduce using rule 503 (attrib_def -> FOR mark USE expression SEMICOLON .)
    SUBTYPE         reduce using rule 503 (attrib_def -> FOR mark USE expression SEMICOLON .)
    TASK            reduce using rule 503 (attrib_def -> FOR mark USE expression SEMICOLON .)
    PACKAGE         reduce using rule 503 (attrib_def -> FOR mark USE expression SEMICOLON .)
    PROTECTED       reduce using rule 503 (attrib_def -> FOR mark USE expression SEMICOLON .)
    PROCEDURE       reduce using rule 503 (attrib_def -> FOR mark USE expression SEMICOLON .)
    FUNCTION        reduce using rule 503 (attrib_def -> FOR mark USE expression SEMICOLON .)
    GENERIC         reduce using rule 503 (attrib_def -> FOR mark USE expression SEMICOLON .)
    IDENTIFIER      reduce using rule 503 (attrib_def -> FOR mark USE expression SEMICOLON .)
    PRIVATE         reduce using rule 503 (attrib_def -> FOR mark USE expression SEMICOLON .)
    BEGIN           reduce using rule 503 (attrib_def -> FOR mark USE expression SEMICOLON .)
    ENTRY           reduce using rule 503 (attrib_def -> FOR mark USE expression SEMICOLON .)


state 598

    (451) body_stub -> TASK BODY simple_name IS SEPARATE . SEMICOLON

    SEMICOLON       shift and go to state 716


state 599

    (365) task_body -> TASK BODY simple_name IS decl_part . block_body END id_opt SEMICOLON
    (298) block_body -> . BEGIN handled_stmt_s

    BEGIN           shift and go to state 168

    block_body                     shift and go to state 717

state 600

    (360) task_spec -> TASK TYPE simple_name discrim_part_opt task_def .

    SEMICOLON       reduce using rule 360 (task_spec -> TASK TYPE simple_name discrim_part_opt task_def .)


state 601

    (362) task_def -> IS entry_decl_s rep_spec_s . task_private_opt END id_opt
    (397) rep_spec_s -> rep_spec_s . rep_spec pragma_s
    (363) task_private_opt -> .
    (364) task_private_opt -> . PRIVATE entry_decl_s rep_spec_s
    (500) rep_spec -> . attrib_def
    (501) rep_spec -> . record_type_spec
    (502) rep_spec -> . address_spec
    (503) attrib_def -> . FOR mark USE expression SEMICOLON
    (504) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD SEMICOLON
    (509) address_spec -> . FOR mark USE AT expression SEMICOLON

    END             reduce using rule 363 (task_private_opt -> .)
    PRIVATE         shift and go to state 719
    FOR             shift and go to state 70

    record_type_spec               shift and go to state 75
    rep_spec                       shift and go to state 718
    attrib_def                     shift and go to state 77
    address_spec                   shift and go to state 59
    task_private_opt               shift and go to state 720

state 602

    (389) entry_decl_s -> entry_decl_s entry_decl . pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    ENTRY           reduce using rule 8 (pragma_s -> .)
    PRIVATE         reduce using rule 8 (pragma_s -> .)
    FOR             reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 721

state 603

    (452) body_stub -> PACKAGE BODY compound_name IS SEPARATE . SEMICOLON

    SEMICOLON       shift and go to state 722


state 604

    (100) tagged_opt -> ABSTRACT . TAGGED

    TAGGED          shift and go to state 723


state 605

    (47) type_def -> access_type .

    SEMICOLON       reduce using rule 47 (type_def -> access_type .)


state 606

    (46) type_def -> record_type .

    SEMICOLON       reduce using rule 46 (type_def -> record_type .)


state 607

    (44) type_def -> real_type .

    SEMICOLON       reduce using rule 44 (type_def -> real_type .)


state 608

    (70) range_spec -> range_constraint .

    SEMICOLON       reduce using rule 70 (range_spec -> range_constraint .)


state 609

    (42) type_def -> enumeration_type .

    SEMICOLON       reduce using rule 42 (type_def -> enumeration_type .)


state 610

    (75) float_type -> DIGITS . expression range_spec_opt
    (195) expression -> . relation
    (196) expression -> . expression logical relation
    (197) expression -> . expression short_circuit relation
    (203) relation -> . simple_expression
    (204) relation -> . simple_expression relational simple_expression
    (205) relation -> . simple_expression membership range
    (206) relation -> . simple_expression membership name
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    relation                       shift and go to state 127
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    factor                         shift and go to state 136
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    term                           shift and go to state 144
    name                           shift and go to state 145
    operator_symbol                shift and go to state 146
    expression                     shift and go to state 724

state 611

    (73) real_type -> float_type .

    SEMICOLON       reduce using rule 73 (real_type -> float_type .)


state 612

    (95) record_type -> tagged_opt . limited_opt record_def
    (344) limited_opt -> .
    (345) limited_opt -> . LIMITED

    RECORD          reduce using rule 344 (limited_opt -> .)
    NULL            reduce using rule 344 (limited_opt -> .)
    LIMITED         shift and go to state 725

    limited_opt                    shift and go to state 726

state 613

    (99) tagged_opt -> TAGGED .

    LIMITED         reduce using rule 99 (tagged_opt -> TAGGED .)
    RECORD          reduce using rule 99 (tagged_opt -> TAGGED .)
    NULL            reduce using rule 99 (tagged_opt -> TAGGED .)
    PRIVATE         reduce using rule 99 (tagged_opt -> TAGGED .)


state 614

    (76) fixed_type -> DELTA . expression range_spec
    (77) fixed_type -> DELTA . expression DIGITS expression range_spec_opt
    (195) expression -> . relation
    (196) expression -> . expression logical relation
    (197) expression -> . expression short_circuit relation
    (203) relation -> . simple_expression
    (204) relation -> . simple_expression relational simple_expression
    (205) relation -> . simple_expression membership range
    (206) relation -> . simple_expression membership name
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    relation                       shift and go to state 127
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    factor                         shift and go to state 136
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    term                           shift and go to state 144
    name                           shift and go to state 145
    operator_symbol                shift and go to state 146
    expression                     shift and go to state 727

state 615

    (43) type_def -> integer_type .

    SEMICOLON       reduce using rule 43 (type_def -> integer_type .)


state 616

    (63) enumeration_type -> LPAREN . enum_id_s RPAREN
    (64) enum_id_s -> . enum_id
    (65) enum_id_s -> . enum_id_s COMMA enum_id
    (66) enum_id -> . IDENTIFIER
    (67) enum_id -> . CHARACTER

    IDENTIFIER      shift and go to state 730
    CHARACTER       shift and go to state 729

    enum_id                        shift and go to state 731
    enum_id_s                      shift and go to state 728

state 617

    (45) type_def -> array_type .

    SEMICOLON       reduce using rule 45 (type_def -> array_type .)


state 618

    (68) integer_type -> range_spec .

    SEMICOLON       reduce using rule 68 (integer_type -> range_spec .)


state 619

    (41) type_completion -> IS type_def .

    SEMICOLON       reduce using rule 41 (type_completion -> IS type_def .)


state 620

    (128) access_type -> ACCESS . subtype_ind
    (129) access_type -> ACCESS . CONSTANT subtype_ind
    (130) access_type -> ACCESS . ALL subtype_ind
    (131) access_type -> ACCESS . prot_opt PROCEDURE formal_part_opt
    (132) access_type -> ACCESS . prot_opt FUNCTION formal_part_opt RETURN mark
    (49) subtype_ind -> . name constraint
    (50) subtype_ind -> . name
    (133) prot_opt -> .
    (134) prot_opt -> . PROTECTED
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    CONSTANT        shift and go to state 732
    ALL             shift and go to state 735
    PROCEDURE       reduce using rule 133 (prot_opt -> .)
    FUNCTION        reduce using rule 133 (prot_opt -> .)
    PROTECTED       shift and go to state 734
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    name                           shift and go to state 490
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 146
    prot_opt                       shift and go to state 733
    subtype_ind                    shift and go to state 736
    indexed_comp                   shift and go to state 119
    simple_name                    shift and go to state 153

state 621

    (74) real_type -> fixed_type .

    SEMICOLON       reduce using rule 74 (real_type -> fixed_type .)


state 622

    (69) integer_type -> MOD . expression
    (195) expression -> . relation
    (196) expression -> . expression logical relation
    (197) expression -> . expression short_circuit relation
    (203) relation -> . simple_expression
    (204) relation -> . simple_expression relational simple_expression
    (205) relation -> . simple_expression membership range
    (206) relation -> . simple_expression membership name
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    relation                       shift and go to state 127
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    factor                         shift and go to state 136
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    term                           shift and go to state 144
    name                           shift and go to state 145
    operator_symbol                shift and go to state 146
    expression                     shift and go to state 737

state 623

    (36) type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion SEMICOLON .

    PACKAGE         reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion SEMICOLON .)
    TASK            reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion SEMICOLON .)
    PROTECTED       reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion SEMICOLON .)
    error           reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion SEMICOLON .)
    USE             reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion SEMICOLON .)
    PRAGMA          reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion SEMICOLON .)
    TYPE            reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion SEMICOLON .)
    SUBTYPE         reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion SEMICOLON .)
    FOR             reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion SEMICOLON .)
    PROCEDURE       reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion SEMICOLON .)
    FUNCTION        reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion SEMICOLON .)
    GENERIC         reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion SEMICOLON .)
    IDENTIFIER      reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion SEMICOLON .)
    BEGIN           reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion SEMICOLON .)
    PRIVATE         reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion SEMICOLON .)
    END             reduce using rule 36 (type_decl -> TYPE IDENTIFIER discrim_part_opt type_completion SEMICOLON .)


state 624

    (39) discrim_part_opt -> LPAREN BOX RPAREN .

    IS              reduce using rule 39 (discrim_part_opt -> LPAREN BOX RPAREN .)
    SEMICOLON       reduce using rule 39 (discrim_part_opt -> LPAREN BOX RPAREN .)


state 625

    (112) discrim_spec_s -> discrim_spec_s SEMICOLON . discrim_spec
    (113) discrim_spec -> . def_id_s COLON access_opt mark init_opt
    (114) discrim_spec -> . error
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s COMMA def_id
    (26) def_id -> . IDENTIFIER

    error           shift and go to state 489
    IDENTIFIER      shift and go to state 79

    discrim_spec                   shift and go to state 738
    def_id                         shift and go to state 96
    def_id_s                       shift and go to state 488

state 626

    (110) discrim_part -> LPAREN discrim_spec_s RPAREN .

    IS              reduce using rule 110 (discrim_part -> LPAREN discrim_spec_s RPAREN .)
    SEMICOLON       reduce using rule 110 (discrim_part -> LPAREN discrim_spec_s RPAREN .)


state 627

    (113) discrim_spec -> def_id_s COLON . access_opt mark init_opt
    (115) access_opt -> .
    (116) access_opt -> . ACCESS

    IDENTIFIER      reduce using rule 115 (access_opt -> .)
    ACCESS          shift and go to state 739

    access_opt                     shift and go to state 740

state 628

    (53) decimal_digits_constraint -> DIGITS . expression range_constr_opt
    (195) expression -> . relation
    (196) expression -> . expression logical relation
    (197) expression -> . expression short_circuit relation
    (203) relation -> . simple_expression
    (204) relation -> . simple_expression relational simple_expression
    (205) relation -> . simple_expression membership range
    (206) relation -> . simple_expression membership name
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    relation                       shift and go to state 127
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    factor                         shift and go to state 136
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    term                           shift and go to state 144
    name                           shift and go to state 145
    operator_symbol                shift and go to state 146
    expression                     shift and go to state 741

state 629

    (49) subtype_ind -> name constraint .

    SEMICOLON       reduce using rule 49 (subtype_ind -> name constraint .)
    RENAMES         reduce using rule 49 (subtype_ind -> name constraint .)
    IS_ASSIGNED     reduce using rule 49 (subtype_ind -> name constraint .)
    WITH            reduce using rule 49 (subtype_ind -> name constraint .)


state 630

    (51) constraint -> range_constraint .

    SEMICOLON       reduce using rule 51 (constraint -> range_constraint .)
    RENAMES         reduce using rule 51 (constraint -> range_constraint .)
    IS_ASSIGNED     reduce using rule 51 (constraint -> range_constraint .)
    WITH            reduce using rule 51 (constraint -> range_constraint .)


state 631

    (52) constraint -> decimal_digits_constraint .

    SEMICOLON       reduce using rule 52 (constraint -> decimal_digits_constraint .)
    RENAMES         reduce using rule 52 (constraint -> decimal_digits_constraint .)
    IS_ASSIGNED     reduce using rule 52 (constraint -> decimal_digits_constraint .)
    WITH            reduce using rule 52 (constraint -> decimal_digits_constraint .)


state 632

    (48) subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind SEMICOLON .

    PACKAGE         reduce using rule 48 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind SEMICOLON .)
    TASK            reduce using rule 48 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind SEMICOLON .)
    PROTECTED       reduce using rule 48 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind SEMICOLON .)
    error           reduce using rule 48 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind SEMICOLON .)
    USE             reduce using rule 48 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind SEMICOLON .)
    PRAGMA          reduce using rule 48 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind SEMICOLON .)
    TYPE            reduce using rule 48 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind SEMICOLON .)
    SUBTYPE         reduce using rule 48 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind SEMICOLON .)
    FOR             reduce using rule 48 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind SEMICOLON .)
    PROCEDURE       reduce using rule 48 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind SEMICOLON .)
    FUNCTION        reduce using rule 48 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind SEMICOLON .)
    GENERIC         reduce using rule 48 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind SEMICOLON .)
    IDENTIFIER      reduce using rule 48 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind SEMICOLON .)
    BEGIN           reduce using rule 48 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind SEMICOLON .)
    END             reduce using rule 48 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind SEMICOLON .)
    PRIVATE         reduce using rule 48 (subtype_decl -> SUBTYPE IDENTIFIER IS subtype_ind SEMICOLON .)


state 633

    (35) number_decl -> def_id_s COLON CONSTANT IS_ASSIGNED expression . SEMICOLON
    (196) expression -> expression . logical relation
    (197) expression -> expression . short_circuit relation
    (198) logical -> . AND
    (199) logical -> . OR
    (200) logical -> . XOR
    (201) short_circuit -> . AND THEN
    (202) short_circuit -> . OR ELSE

    SEMICOLON       shift and go to state 742
    AND             shift and go to state 244
    OR              shift and go to state 248
    XOR             shift and go to state 245

    logical                        shift and go to state 246
    short_circuit                  shift and go to state 247

state 634

    (351) rename_decl -> def_id_s COLON EXCEPTION renames SEMICOLON .

    error           reduce using rule 351 (rename_decl -> def_id_s COLON EXCEPTION renames SEMICOLON .)
    USE             reduce using rule 351 (rename_decl -> def_id_s COLON EXCEPTION renames SEMICOLON .)
    PRAGMA          reduce using rule 351 (rename_decl -> def_id_s COLON EXCEPTION renames SEMICOLON .)
    TYPE            reduce using rule 351 (rename_decl -> def_id_s COLON EXCEPTION renames SEMICOLON .)
    SUBTYPE         reduce using rule 351 (rename_decl -> def_id_s COLON EXCEPTION renames SEMICOLON .)
    TASK            reduce using rule 351 (rename_decl -> def_id_s COLON EXCEPTION renames SEMICOLON .)
    PACKAGE         reduce using rule 351 (rename_decl -> def_id_s COLON EXCEPTION renames SEMICOLON .)
    PROTECTED       reduce using rule 351 (rename_decl -> def_id_s COLON EXCEPTION renames SEMICOLON .)
    FOR             reduce using rule 351 (rename_decl -> def_id_s COLON EXCEPTION renames SEMICOLON .)
    PROCEDURE       reduce using rule 351 (rename_decl -> def_id_s COLON EXCEPTION renames SEMICOLON .)
    FUNCTION        reduce using rule 351 (rename_decl -> def_id_s COLON EXCEPTION renames SEMICOLON .)
    GENERIC         reduce using rule 351 (rename_decl -> def_id_s COLON EXCEPTION renames SEMICOLON .)
    IDENTIFIER      reduce using rule 351 (rename_decl -> def_id_s COLON EXCEPTION renames SEMICOLON .)
    PRIVATE         reduce using rule 351 (rename_decl -> def_id_s COLON EXCEPTION renames SEMICOLON .)
    END             reduce using rule 351 (rename_decl -> def_id_s COLON EXCEPTION renames SEMICOLON .)
    BEGIN           reduce using rule 351 (rename_decl -> def_id_s COLON EXCEPTION renames SEMICOLON .)


state 635

    (81) constr_array_type -> ARRAY iter_index_constraint . OF component_subtype_def

    OF              shift and go to state 743


state 636

    (80) unconstr_array_type -> ARRAY LPAREN . index_s RPAREN OF component_subtype_def
    (88) iter_index_constraint -> LPAREN . iter_discrete_range_s RPAREN
    (85) index_s -> . index
    (86) index_s -> . index_s COMMA index
    (89) iter_discrete_range_s -> . discrete_range
    (90) iter_discrete_range_s -> . iter_discrete_range_s COMMA discrete_range
    (87) index -> . name RANGE BOX
    (91) discrete_range -> . name range_constr_opt
    (92) discrete_range -> . range
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (60) range -> . simple_expression DOUBLEDOT simple_expression
    (61) range -> . name TICK RANGE
    (62) range -> . name TICK RANGE LPAREN expression RPAREN
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN

    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137
    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    iter_discrete_range_s          shift and go to state 744
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    simple_expression              shift and go to state 356
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    index                          shift and go to state 745
    index_s                        shift and go to state 746
    literal                        shift and go to state 135
    factor                         shift and go to state 136
    primary                        shift and go to state 123
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    discrete_range                 shift and go to state 747
    aggregate                      shift and go to state 126
    term                           shift and go to state 144
    name                           shift and go to state 748
    operator_symbol                shift and go to state 146
    range                          shift and go to state 685

state 637

    (34) init_opt -> IS_ASSIGNED . expression
    (195) expression -> . relation
    (196) expression -> . expression logical relation
    (197) expression -> . expression short_circuit relation
    (203) relation -> . simple_expression
    (204) relation -> . simple_expression relational simple_expression
    (205) relation -> . simple_expression membership range
    (206) relation -> . simple_expression membership name
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    relation                       shift and go to state 127
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    factor                         shift and go to state 136
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    term                           shift and go to state 144
    name                           shift and go to state 145
    operator_symbol                shift and go to state 146
    expression                     shift and go to state 749

state 638

    (23) object_decl -> def_id_s COLON object_qualifier_opt object_subtype_def init_opt . SEMICOLON

    SEMICOLON       shift and go to state 750


state 639

    (350) rename_decl -> def_id_s COLON object_qualifier_opt subtype_ind renames . SEMICOLON

    SEMICOLON       shift and go to state 751


state 640

    (474) generic_formal -> WITH FUNCTION designator formal_part_opt RETURN . name subp_default SEMICOLON
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    name                           shift and go to state 752
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    indexed_comp                   shift and go to state 119
    operator_symbol                shift and go to state 146
    simple_name                    shift and go to state 153

state 641

    (475) generic_formal -> WITH PACKAGE simple_name IS NEW . name LPAREN BOX RPAREN SEMICOLON
    (476) generic_formal -> WITH PACKAGE simple_name IS NEW . name SEMICOLON
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    name                           shift and go to state 753
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 146
    indexed_comp                   shift and go to state 119
    simple_name                    shift and go to state 153

state 642

    (482) subp_default -> IS . name
    (483) subp_default -> IS . BOX
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    BOX             shift and go to state 754
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    name                           shift and go to state 755
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 146
    indexed_comp                   shift and go to state 119
    simple_name                    shift and go to state 153

state 643

    (473) generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default . SEMICOLON

    SEMICOLON       shift and go to state 756


state 644

    (323) param -> def_id_s COLON mode mark init_opt .

    RPAREN          reduce using rule 323 (param -> def_id_s COLON mode mark init_opt .)
    SEMICOLON       reduce using rule 323 (param -> def_id_s COLON mode mark init_opt .)


state 645

    (496) generic_derived_type -> ABSTRACT . NEW subtype_ind WITH PRIVATE
    (100) tagged_opt -> ABSTRACT . TAGGED

    NEW             shift and go to state 757
    TAGGED          shift and go to state 723


state 646

    (472) generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def . SEMICOLON

    SEMICOLON       shift and go to state 758


state 647

    (494) generic_derived_type -> NEW . subtype_ind
    (495) generic_derived_type -> NEW . subtype_ind WITH PRIVATE
    (49) subtype_ind -> . name constraint
    (50) subtype_ind -> . name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    name                           shift and go to state 490
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 146
    subtype_ind                    shift and go to state 759
    indexed_comp                   shift and go to state 119
    simple_name                    shift and go to state 153

state 648

    (493) generic_type_def -> generic_derived_type .

    SEMICOLON       reduce using rule 493 (generic_type_def -> generic_derived_type .)


state 649

    (489) generic_type_def -> DIGITS . BOX

    BOX             shift and go to state 760


state 650

    (343) private_type -> tagged_opt . limited_opt PRIVATE
    (344) limited_opt -> .
    (345) limited_opt -> . LIMITED

    PRIVATE         reduce using rule 344 (limited_opt -> .)
    LIMITED         shift and go to state 725

    limited_opt                    shift and go to state 761

state 651

    (492) generic_type_def -> private_type .

    SEMICOLON       reduce using rule 492 (generic_type_def -> private_type .)


state 652

    (485) generic_type_def -> RANGE . BOX

    BOX             shift and go to state 762


state 653

    (491) generic_type_def -> access_type .

    SEMICOLON       reduce using rule 491 (generic_type_def -> access_type .)


state 654

    (484) generic_type_def -> LPAREN . BOX RPAREN

    BOX             shift and go to state 763


state 655

    (490) generic_type_def -> array_type .

    SEMICOLON       reduce using rule 490 (generic_type_def -> array_type .)


state 656

    (487) generic_type_def -> DELTA . BOX
    (488) generic_type_def -> DELTA . BOX DIGITS BOX

    BOX             shift and go to state 764


state 657

    (486) generic_type_def -> MOD . BOX

    BOX             shift and go to state 765


state 658

    (480) generic_discrim_part_opt -> LPAREN BOX RPAREN .

    IS              reduce using rule 480 (generic_discrim_part_opt -> LPAREN BOX RPAREN .)


state 659

    (62) range -> name TICK RANGE LPAREN . expression RPAREN
    (195) expression -> . relation
    (196) expression -> . expression logical relation
    (197) expression -> . expression short_circuit relation
    (203) relation -> . simple_expression
    (204) relation -> . simple_expression relational simple_expression
    (205) relation -> . simple_expression membership range
    (206) relation -> . simple_expression membership name
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    relation                       shift and go to state 127
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    factor                         shift and go to state 136
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    term                           shift and go to state 144
    name                           shift and go to state 145
    operator_symbol                shift and go to state 146
    expression                     shift and go to state 766

state 660

    (190) aggregate -> LPAREN expression WITH NULL RECORD . RPAREN

    RPAREN          shift and go to state 767


state 661

    (189) aggregate -> LPAREN expression WITH value_s RPAREN .

    POW             reduce using rule 189 (aggregate -> LPAREN expression WITH value_s RPAREN .)
    TIMES           reduce using rule 189 (aggregate -> LPAREN expression WITH value_s RPAREN .)
    DIVIDE          reduce using rule 189 (aggregate -> LPAREN expression WITH value_s RPAREN .)
    MOD             reduce using rule 189 (aggregate -> LPAREN expression WITH value_s RPAREN .)
    REM             reduce using rule 189 (aggregate -> LPAREN expression WITH value_s RPAREN .)
    EQ              reduce using rule 189 (aggregate -> LPAREN expression WITH value_s RPAREN .)
    NE              reduce using rule 189 (aggregate -> LPAREN expression WITH value_s RPAREN .)
    LT              reduce using rule 189 (aggregate -> LPAREN expression WITH value_s RPAREN .)
    LE              reduce using rule 189 (aggregate -> LPAREN expression WITH value_s RPAREN .)
    GT              reduce using rule 189 (aggregate -> LPAREN expression WITH value_s RPAREN .)
    GE              reduce using rule 189 (aggregate -> LPAREN expression WITH value_s RPAREN .)
    IN              reduce using rule 189 (aggregate -> LPAREN expression WITH value_s RPAREN .)
    NOT             reduce using rule 189 (aggregate -> LPAREN expression WITH value_s RPAREN .)
    PLUS            reduce using rule 189 (aggregate -> LPAREN expression WITH value_s RPAREN .)
    MINUS           reduce using rule 189 (aggregate -> LPAREN expression WITH value_s RPAREN .)
    AMPERSAND       reduce using rule 189 (aggregate -> LPAREN expression WITH value_s RPAREN .)
    AND             reduce using rule 189 (aggregate -> LPAREN expression WITH value_s RPAREN .)
    OR              reduce using rule 189 (aggregate -> LPAREN expression WITH value_s RPAREN .)
    XOR             reduce using rule 189 (aggregate -> LPAREN expression WITH value_s RPAREN .)
    THEN            reduce using rule 189 (aggregate -> LPAREN expression WITH value_s RPAREN .)
    RPAREN          reduce using rule 189 (aggregate -> LPAREN expression WITH value_s RPAREN .)
    COMMA           reduce using rule 189 (aggregate -> LPAREN expression WITH value_s RPAREN .)
    DOUBLEDOT       reduce using rule 189 (aggregate -> LPAREN expression WITH value_s RPAREN .)
    WITH            reduce using rule 189 (aggregate -> LPAREN expression WITH value_s RPAREN .)
    ARROW           reduce using rule 189 (aggregate -> LPAREN expression WITH value_s RPAREN .)
    |               reduce using rule 189 (aggregate -> LPAREN expression WITH value_s RPAREN .)
    SEMICOLON       reduce using rule 189 (aggregate -> LPAREN expression WITH value_s RPAREN .)
    IS              reduce using rule 189 (aggregate -> LPAREN expression WITH value_s RPAREN .)
    LOOP            reduce using rule 189 (aggregate -> LPAREN expression WITH value_s RPAREN .)
    RANGE           reduce using rule 189 (aggregate -> LPAREN expression WITH value_s RPAREN .)
    DIGITS          reduce using rule 189 (aggregate -> LPAREN expression WITH value_s RPAREN .)
    RENAMES         reduce using rule 189 (aggregate -> LPAREN expression WITH value_s RPAREN .)
    IS_ASSIGNED     reduce using rule 189 (aggregate -> LPAREN expression WITH value_s RPAREN .)


state 662

    (170) value_s -> value_s COMMA value .

    RPAREN          reduce using rule 170 (value_s -> value_s COMMA value .)
    COMMA           reduce using rule 170 (value_s -> value_s COMMA value .)


state 663

    (382) prot_body -> PROTECTED BODY simple_name . IS prot_op_body_s END id_opt SEMICOLON

    IS              shift and go to state 768


state 664

    (365) task_body -> TASK BODY simple_name . IS decl_part block_body END id_opt SEMICOLON

    IS              shift and go to state 769


state 665

    (340) pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END . c_id_opt SEMICOLON
    (338) c_id_opt -> .
    (339) c_id_opt -> . compound_name
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name DOT simple_name
    (161) simple_name -> . IDENTIFIER

    SEMICOLON       reduce using rule 338 (c_id_opt -> .)
    IDENTIFIER      shift and go to state 40

    compound_name                  shift and go to state 667
    c_id_opt                       shift and go to state 770
    simple_name                    shift and go to state 41

state 666

    (454) body_stub -> PROTECTED BODY simple_name IS . SEPARATE SEMICOLON

    SEPARATE        shift and go to state 538


state 667

    (339) c_id_opt -> compound_name .
    (163) compound_name -> compound_name . DOT simple_name

    SEMICOLON       reduce using rule 339 (c_id_opt -> compound_name .)
    DOT             shift and go to state 118


state 668

    (335) pkg_spec -> PACKAGE compound_name IS decl_item_s private_part END c_id_opt .

    SEMICOLON       reduce using rule 335 (pkg_spec -> PACKAGE compound_name IS decl_item_s private_part END c_id_opt .)


state 669

    (451) body_stub -> TASK BODY simple_name IS . SEPARATE SEMICOLON

    SEPARATE        shift and go to state 598


state 670

    (452) body_stub -> PACKAGE BODY compound_name IS . SEPARATE SEMICOLON

    SEPARATE        shift and go to state 603


state 671

    (454) body_stub -> PROTECTED BODY simple_name IS SEPARATE SEMICOLON .

    PACKAGE         reduce using rule 454 (body_stub -> PROTECTED BODY simple_name IS SEPARATE SEMICOLON .)
    TASK            reduce using rule 454 (body_stub -> PROTECTED BODY simple_name IS SEPARATE SEMICOLON .)
    PROTECTED       reduce using rule 454 (body_stub -> PROTECTED BODY simple_name IS SEPARATE SEMICOLON .)
    error           reduce using rule 454 (body_stub -> PROTECTED BODY simple_name IS SEPARATE SEMICOLON .)
    USE             reduce using rule 454 (body_stub -> PROTECTED BODY simple_name IS SEPARATE SEMICOLON .)
    PRAGMA          reduce using rule 454 (body_stub -> PROTECTED BODY simple_name IS SEPARATE SEMICOLON .)
    TYPE            reduce using rule 454 (body_stub -> PROTECTED BODY simple_name IS SEPARATE SEMICOLON .)
    SUBTYPE         reduce using rule 454 (body_stub -> PROTECTED BODY simple_name IS SEPARATE SEMICOLON .)
    FOR             reduce using rule 454 (body_stub -> PROTECTED BODY simple_name IS SEPARATE SEMICOLON .)
    PROCEDURE       reduce using rule 454 (body_stub -> PROTECTED BODY simple_name IS SEPARATE SEMICOLON .)
    FUNCTION        reduce using rule 454 (body_stub -> PROTECTED BODY simple_name IS SEPARATE SEMICOLON .)
    GENERIC         reduce using rule 454 (body_stub -> PROTECTED BODY simple_name IS SEPARATE SEMICOLON .)
    IDENTIFIER      reduce using rule 454 (body_stub -> PROTECTED BODY simple_name IS SEPARATE SEMICOLON .)
    BEGIN           reduce using rule 454 (body_stub -> PROTECTED BODY simple_name IS SEPARATE SEMICOLON .)
    END             reduce using rule 454 (body_stub -> PROTECTED BODY simple_name IS SEPARATE SEMICOLON .)
    PRIVATE         reduce using rule 454 (body_stub -> PROTECTED BODY simple_name IS SEPARATE SEMICOLON .)


state 672

    (386) prot_op_body -> subprog_body .

    PRAGMA          reduce using rule 386 (prot_op_body -> subprog_body .)
    END             reduce using rule 386 (prot_op_body -> subprog_body .)
    ENTRY           reduce using rule 386 (prot_op_body -> subprog_body .)
    PROCEDURE       reduce using rule 386 (prot_op_body -> subprog_body .)
    FUNCTION        reduce using rule 386 (prot_op_body -> subprog_body .)


state 673

    (387) prot_op_body -> subprog_spec . SEMICOLON
    (330) subprog_spec_is_push -> subprog_spec . IS

    SEMICOLON       shift and go to state 771
    IS              shift and go to state 529


state 674

    (382) prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END . id_opt SEMICOLON
    (293) id_opt -> .
    (294) id_opt -> . designator
    (316) designator -> . compound_name
    (317) designator -> . STRING
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name DOT simple_name
    (161) simple_name -> . IDENTIFIER

    SEMICOLON       reduce using rule 293 (id_opt -> .)
    STRING          shift and go to state 114
    IDENTIFIER      shift and go to state 40

    compound_name                  shift and go to state 113
    id_opt                         shift and go to state 772
    designator                     shift and go to state 471
    simple_name                    shift and go to state 41

state 675

    (385) prot_op_body -> entry_body .

    PRAGMA          reduce using rule 385 (prot_op_body -> entry_body .)
    END             reduce using rule 385 (prot_op_body -> entry_body .)
    ENTRY           reduce using rule 385 (prot_op_body -> entry_body .)
    PROCEDURE       reduce using rule 385 (prot_op_body -> entry_body .)
    FUNCTION        reduce using rule 385 (prot_op_body -> entry_body .)


state 676

    (384) prot_op_body_s -> prot_op_body_s prot_op_body . pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)
    ENTRY           reduce using rule 8 (pragma_s -> .)
    PROCEDURE       reduce using rule 8 (pragma_s -> .)
    FUNCTION        reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 773

state 677

    (392) entry_body -> ENTRY . IDENTIFIER formal_part_opt WHEN condition entry_body_part
    (393) entry_body -> ENTRY . IDENTIFIER LPAREN iter_part discrete_range RPAREN formal_part_opt WHEN condition entry_body_part

    IDENTIFIER      shift and go to state 774


state 678

    (371) prot_private_opt -> PRIVATE prot_elem_decl_s .
    (379) prot_elem_decl_s -> prot_elem_decl_s . prot_elem_decl
    (380) prot_elem_decl -> . prot_op_decl
    (381) prot_elem_decl -> . comp_decl
    (374) prot_op_decl -> . entry_decl
    (375) prot_op_decl -> . subprog_spec SEMICOLON
    (376) prot_op_decl -> . rep_spec
    (377) prot_op_decl -> . pragma
    (108) comp_decl -> . def_id_s COLON component_subtype_def init_opt SEMICOLON
    (109) comp_decl -> . error SEMICOLON
    (390) entry_decl -> . ENTRY IDENTIFIER formal_part_opt SEMICOLON
    (391) entry_decl -> . ENTRY IDENTIFIER LPAREN discrete_range RPAREN formal_part_opt SEMICOLON
    (313) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (314) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (315) subprog_spec -> . FUNCTION designator
    (500) rep_spec -> . attrib_def
    (501) rep_spec -> . record_type_spec
    (502) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s COMMA def_id
    (503) attrib_def -> . FOR mark USE expression SEMICOLON
    (504) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD SEMICOLON
    (509) address_spec -> . FOR mark USE AT expression SEMICOLON
    (26) def_id -> . IDENTIFIER

    END             reduce using rule 371 (prot_private_opt -> PRIVATE prot_elem_decl_s .)
    error           shift and go to state 779
    ENTRY           shift and go to state 547
    PROCEDURE       shift and go to state 30
    FUNCTION        shift and go to state 36
    PRAGMA          shift and go to state 4
    FOR             shift and go to state 70
    IDENTIFIER      shift and go to state 79

    rep_spec                       shift and go to state 542
    entry_decl                     shift and go to state 543
    address_spec                   shift and go to state 59
    record_type_spec               shift and go to state 75
    attrib_def                     shift and go to state 77
    subprog_spec                   shift and go to state 545
    def_id_s                       shift and go to state 775
    comp_decl                      shift and go to state 776
    def_id                         shift and go to state 96
    pragma                         shift and go to state 541
    prot_op_decl                   shift and go to state 777
    prot_elem_decl                 shift and go to state 778

state 679

    (375) prot_op_decl -> subprog_spec SEMICOLON .

    PRIVATE         reduce using rule 375 (prot_op_decl -> subprog_spec SEMICOLON .)
    ENTRY           reduce using rule 375 (prot_op_decl -> subprog_spec SEMICOLON .)
    PROCEDURE       reduce using rule 375 (prot_op_decl -> subprog_spec SEMICOLON .)
    FUNCTION        reduce using rule 375 (prot_op_decl -> subprog_spec SEMICOLON .)
    PRAGMA          reduce using rule 375 (prot_op_decl -> subprog_spec SEMICOLON .)
    FOR             reduce using rule 375 (prot_op_decl -> subprog_spec SEMICOLON .)
    END             reduce using rule 375 (prot_op_decl -> subprog_spec SEMICOLON .)
    error           reduce using rule 375 (prot_op_decl -> subprog_spec SEMICOLON .)
    IDENTIFIER      reduce using rule 375 (prot_op_decl -> subprog_spec SEMICOLON .)


state 680

    (369) prot_def -> IS prot_op_decl_s prot_private_opt END . id_opt
    (293) id_opt -> .
    (294) id_opt -> . designator
    (316) designator -> . compound_name
    (317) designator -> . STRING
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name DOT simple_name
    (161) simple_name -> . IDENTIFIER

    SEMICOLON       reduce using rule 293 (id_opt -> .)
    STRING          shift and go to state 114
    IDENTIFIER      shift and go to state 40

    designator                     shift and go to state 471
    id_opt                         shift and go to state 780
    compound_name                  shift and go to state 113
    simple_name                    shift and go to state 41

state 681

    (390) entry_decl -> ENTRY IDENTIFIER . formal_part_opt SEMICOLON
    (391) entry_decl -> ENTRY IDENTIFIER . LPAREN discrete_range RPAREN formal_part_opt SEMICOLON
    (318) formal_part_opt -> .
    (319) formal_part_opt -> . formal_part
    (320) formal_part -> . LPAREN param_s RPAREN

    LPAREN          shift and go to state 781
    SEMICOLON       reduce using rule 318 (formal_part_opt -> .)

    formal_part                    shift and go to state 162
    formal_part_opt                shift and go to state 782

state 682

    (405) delay_stmt -> DELAY UNTIL expression SEMICOLON .

    LLB             reduce using rule 405 (delay_stmt -> DELAY UNTIL expression SEMICOLON .)
    error           reduce using rule 405 (delay_stmt -> DELAY UNTIL expression SEMICOLON .)
    PRAGMA          reduce using rule 405 (delay_stmt -> DELAY UNTIL expression SEMICOLON .)
    NULL            reduce using rule 405 (delay_stmt -> DELAY UNTIL expression SEMICOLON .)
    EXIT            reduce using rule 405 (delay_stmt -> DELAY UNTIL expression SEMICOLON .)
    RETURN          reduce using rule 405 (delay_stmt -> DELAY UNTIL expression SEMICOLON .)
    GOTO            reduce using rule 405 (delay_stmt -> DELAY UNTIL expression SEMICOLON .)
    DELAY           reduce using rule 405 (delay_stmt -> DELAY UNTIL expression SEMICOLON .)
    ABORT           reduce using rule 405 (delay_stmt -> DELAY UNTIL expression SEMICOLON .)
    RAISE           reduce using rule 405 (delay_stmt -> DELAY UNTIL expression SEMICOLON .)
    REQUEUE         reduce using rule 405 (delay_stmt -> DELAY UNTIL expression SEMICOLON .)
    IF              reduce using rule 405 (delay_stmt -> DELAY UNTIL expression SEMICOLON .)
    CASE            reduce using rule 405 (delay_stmt -> DELAY UNTIL expression SEMICOLON .)
    IDENTIFIER      reduce using rule 405 (delay_stmt -> DELAY UNTIL expression SEMICOLON .)
    ACCEPT          reduce using rule 405 (delay_stmt -> DELAY UNTIL expression SEMICOLON .)
    SELECT          reduce using rule 405 (delay_stmt -> DELAY UNTIL expression SEMICOLON .)
    STRING          reduce using rule 405 (delay_stmt -> DELAY UNTIL expression SEMICOLON .)
    WHILE           reduce using rule 405 (delay_stmt -> DELAY UNTIL expression SEMICOLON .)
    DECLARE         reduce using rule 405 (delay_stmt -> DELAY UNTIL expression SEMICOLON .)
    FOR             reduce using rule 405 (delay_stmt -> DELAY UNTIL expression SEMICOLON .)
    LOOP            reduce using rule 405 (delay_stmt -> DELAY UNTIL expression SEMICOLON .)
    BEGIN           reduce using rule 405 (delay_stmt -> DELAY UNTIL expression SEMICOLON .)
    WHEN            reduce using rule 405 (delay_stmt -> DELAY UNTIL expression SEMICOLON .)
    END             reduce using rule 405 (delay_stmt -> DELAY UNTIL expression SEMICOLON .)
    EXCEPTION       reduce using rule 405 (delay_stmt -> DELAY UNTIL expression SEMICOLON .)
    ELSE            reduce using rule 405 (delay_stmt -> DELAY UNTIL expression SEMICOLON .)
    ELSIF           reduce using rule 405 (delay_stmt -> DELAY UNTIL expression SEMICOLON .)
    OR              reduce using rule 405 (delay_stmt -> DELAY UNTIL expression SEMICOLON .)
    THEN            reduce using rule 405 (delay_stmt -> DELAY UNTIL expression SEMICOLON .)


state 683

    (289) iteration -> iter_part reverse_opt discrete_range .

    LOOP            reduce using rule 289 (iteration -> iter_part reverse_opt discrete_range .)


state 684

    (91) discrete_range -> name . range_constr_opt
    (61) range -> name . TICK RANGE
    (62) range -> name . TICK RANGE LPAREN expression RPAREN
    (168) indexed_comp -> name . LPAREN value_s RPAREN
    (175) selected_comp -> name . DOT simple_name
    (176) selected_comp -> name . DOT used_char
    (177) selected_comp -> name . DOT operator_symbol
    (178) selected_comp -> name . DOT ALL
    (179) attribute -> name . TICK attribute_id
    (237) primary -> name .
    (240) qualified -> name . TICK parenthesized_primary
    (93) range_constr_opt -> .
    (94) range_constr_opt -> . range_constraint
    (59) range_constraint -> . RANGE range

    TICK            shift and go to state 373
    LPAREN          shift and go to state 240
    DOT             shift and go to state 242
    POW             reduce using rule 237 (primary -> name .)
    TIMES           reduce using rule 237 (primary -> name .)
    DIVIDE          reduce using rule 237 (primary -> name .)
    MOD             reduce using rule 237 (primary -> name .)
    REM             reduce using rule 237 (primary -> name .)
    DOUBLEDOT       reduce using rule 237 (primary -> name .)
    PLUS            reduce using rule 237 (primary -> name .)
    MINUS           reduce using rule 237 (primary -> name .)
    AMPERSAND       reduce using rule 237 (primary -> name .)
    LOOP            reduce using rule 93 (range_constr_opt -> .)
    RPAREN          reduce using rule 93 (range_constr_opt -> .)
    COMMA           reduce using rule 93 (range_constr_opt -> .)
    RANGE           shift and go to state 371

    range_constr_opt               shift and go to state 783
    range_constraint               shift and go to state 784

state 685

    (92) discrete_range -> range .

    LOOP            reduce using rule 92 (discrete_range -> range .)
    RPAREN          reduce using rule 92 (discrete_range -> range .)
    COMMA           reduce using rule 92 (discrete_range -> range .)


state 686

    (286) iter_part -> FOR IDENTIFIER IN .

    IDENTIFIER      reduce using rule 286 (iter_part -> FOR IDENTIFIER IN .)
    STRING          reduce using rule 286 (iter_part -> FOR IDENTIFIER IN .)
    PLUS            reduce using rule 286 (iter_part -> FOR IDENTIFIER IN .)
    MINUS           reduce using rule 286 (iter_part -> FOR IDENTIFIER IN .)
    NOT             reduce using rule 286 (iter_part -> FOR IDENTIFIER IN .)
    ABS             reduce using rule 286 (iter_part -> FOR IDENTIFIER IN .)
    NUMBER          reduce using rule 286 (iter_part -> FOR IDENTIFIER IN .)
    NULL            reduce using rule 286 (iter_part -> FOR IDENTIFIER IN .)
    NEW             reduce using rule 286 (iter_part -> FOR IDENTIFIER IN .)
    LPAREN          reduce using rule 286 (iter_part -> FOR IDENTIFIER IN .)
    CHARACTER       reduce using rule 286 (iter_part -> FOR IDENTIFIER IN .)
    REVERSE         reduce using rule 286 (iter_part -> FOR IDENTIFIER IN .)


state 687

    (283) loop_stmt -> label_opt iteration basic_loop id_opt . SEMICOLON

    SEMICOLON       shift and go to state 785


state 688

    (292) basic_loop -> LOOP statement_s . END LOOP
    (244) statement_s -> statement_s . statement
    (245) statement -> . unlabeled
    (246) statement -> . label statement
    (247) unlabeled -> . simple_stmt
    (248) unlabeled -> . compound_stmt
    (249) unlabeled -> . pragma
    (268) label -> . LLB IDENTIFIER RLB
    (250) simple_stmt -> . NULL_stmt
    (251) simple_stmt -> . assign_stmt
    (252) simple_stmt -> . exit_stmt
    (253) simple_stmt -> . return_stmt
    (254) simple_stmt -> . goto_stmt
    (255) simple_stmt -> . procedure_call
    (256) simple_stmt -> . delay_stmt
    (257) simple_stmt -> . abort_stmt
    (258) simple_stmt -> . raise_stmt
    (259) simple_stmt -> . code_stmt
    (260) simple_stmt -> . requeue_stmt
    (261) simple_stmt -> . error SEMICOLON
    (262) compound_stmt -> . if_stmt
    (263) compound_stmt -> . case_stmt
    (264) compound_stmt -> . loop_stmt
    (265) compound_stmt -> . block
    (266) compound_stmt -> . accept_stmt
    (267) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (269) NULL_stmt -> . NULL SEMICOLON
    (270) assign_stmt -> . name IS_ASSIGNED expression SEMICOLON
    (302) exit_stmt -> . EXIT name_opt when_opt SEMICOLON
    (307) return_stmt -> . RETURN SEMICOLON
    (308) return_stmt -> . RETURN expression SEMICOLON
    (309) goto_stmt -> . GOTO name SEMICOLON
    (332) procedure_call -> . name SEMICOLON
    (404) delay_stmt -> . DELAY expression SEMICOLON
    (405) delay_stmt -> . DELAY UNTIL expression SEMICOLON
    (425) abort_stmt -> . ABORT name_s SEMICOLON
    (464) raise_stmt -> . RAISE name_opt SEMICOLON
    (510) code_stmt -> . qualified SEMICOLON
    (465) requeue_stmt -> . REQUEUE name SEMICOLON
    (466) requeue_stmt -> . REQUEUE name WITH ABORT SEMICOLON
    (271) if_stmt -> . IF cond_clause else_opt END IF SEMICOLON
    (278) case_stmt -> . case_hdr alternative_s END CASE SEMICOLON
    (283) loop_stmt -> . label_opt iteration basic_loop id_opt SEMICOLON
    (295) block -> . label_opt block_decl block_body END id_opt SEMICOLON
    (399) accept_stmt -> . accept_hdr SEMICOLON
    (400) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt SEMICOLON
    (406) select_stmt -> . select_wait
    (407) select_stmt -> . async_select
    (408) select_stmt -> . timed_entry_call
    (409) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (240) qualified -> . name TICK parenthesized_primary
    (279) case_hdr -> . CASE expression IS
    (284) label_opt -> .
    (285) label_opt -> . IDENTIFIER COLON
    (401) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (410) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON
    (420) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON
    (421) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON
    (422) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    END             shift and go to state 786
    LLB             shift and go to state 289
    error           shift and go to state 309
    PRAGMA          shift and go to state 4
    NULL            shift and go to state 311
    EXIT            shift and go to state 308
    RETURN          shift and go to state 295
    GOTO            shift and go to state 276
    DELAY           shift and go to state 272
    ABORT           shift and go to state 282
    RAISE           shift and go to state 306
    REQUEUE         shift and go to state 298
    IF              shift and go to state 317
    CASE            shift and go to state 297
    WHILE           reduce using rule 284 (label_opt -> .)
    DECLARE         reduce using rule 284 (label_opt -> .)
    FOR             reduce using rule 284 (label_opt -> .)
    LOOP            reduce using rule 284 (label_opt -> .)
    BEGIN           reduce using rule 284 (label_opt -> .)
    IDENTIFIER      shift and go to state 300
    ACCEPT          shift and go to state 284
    SELECT          shift and go to state 286
    STRING          shift and go to state 137

    indexed_comp                   shift and go to state 119
    accept_stmt                    shift and go to state 283
    label_opt                      shift and go to state 275
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 316
    abort_stmt                     shift and go to state 310
    return_stmt                    shift and go to state 294
    procedure_call                 shift and go to state 285
    assign_stmt                    shift and go to state 320
    simple_name                    shift and go to state 153
    code_stmt                      shift and go to state 313
    case_stmt                      shift and go to state 287
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 146
    label                          shift and go to state 288
    exit_stmt                      shift and go to state 315
    select_stmt                    shift and go to state 274
    statement                      shift and go to state 465
    compound_stmt                  shift and go to state 290
    case_hdr                       shift and go to state 292
    delay_stmt                     shift and go to state 301
    unlabeled                      shift and go to state 314
    simple_stmt                    shift and go to state 277
    loop_stmt                      shift and go to state 278
    qualified                      shift and go to state 279
    pragma                         shift and go to state 303
    async_select                   shift and go to state 273
    requeue_stmt                   shift and go to state 304
    raise_stmt                     shift and go to state 305
    name                           shift and go to state 281
    if_stmt                        shift and go to state 280
    accept_hdr                     shift and go to state 302
    cond_entry_call                shift and go to state 318
    timed_entry_call               shift and go to state 307
    goto_stmt                      shift and go to state 291
    NULL_stmt                      shift and go to state 319
    block                          shift and go to state 293

state 689

    (295) block -> label_opt block_decl block_body END . id_opt SEMICOLON
    (293) id_opt -> .
    (294) id_opt -> . designator
    (316) designator -> . compound_name
    (317) designator -> . STRING
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name DOT simple_name
    (161) simple_name -> . IDENTIFIER

    SEMICOLON       reduce using rule 293 (id_opt -> .)
    STRING          shift and go to state 114
    IDENTIFIER      shift and go to state 40

    designator                     shift and go to state 471
    id_opt                         shift and go to state 787
    compound_name                  shift and go to state 113
    simple_name                    shift and go to state 41

state 690

    (270) assign_stmt -> name IS_ASSIGNED expression SEMICOLON .

    END             reduce using rule 270 (assign_stmt -> name IS_ASSIGNED expression SEMICOLON .)
    LLB             reduce using rule 270 (assign_stmt -> name IS_ASSIGNED expression SEMICOLON .)
    error           reduce using rule 270 (assign_stmt -> name IS_ASSIGNED expression SEMICOLON .)
    PRAGMA          reduce using rule 270 (assign_stmt -> name IS_ASSIGNED expression SEMICOLON .)
    NULL            reduce using rule 270 (assign_stmt -> name IS_ASSIGNED expression SEMICOLON .)
    EXIT            reduce using rule 270 (assign_stmt -> name IS_ASSIGNED expression SEMICOLON .)
    RETURN          reduce using rule 270 (assign_stmt -> name IS_ASSIGNED expression SEMICOLON .)
    GOTO            reduce using rule 270 (assign_stmt -> name IS_ASSIGNED expression SEMICOLON .)
    DELAY           reduce using rule 270 (assign_stmt -> name IS_ASSIGNED expression SEMICOLON .)
    ABORT           reduce using rule 270 (assign_stmt -> name IS_ASSIGNED expression SEMICOLON .)
    RAISE           reduce using rule 270 (assign_stmt -> name IS_ASSIGNED expression SEMICOLON .)
    REQUEUE         reduce using rule 270 (assign_stmt -> name IS_ASSIGNED expression SEMICOLON .)
    IF              reduce using rule 270 (assign_stmt -> name IS_ASSIGNED expression SEMICOLON .)
    CASE            reduce using rule 270 (assign_stmt -> name IS_ASSIGNED expression SEMICOLON .)
    IDENTIFIER      reduce using rule 270 (assign_stmt -> name IS_ASSIGNED expression SEMICOLON .)
    ACCEPT          reduce using rule 270 (assign_stmt -> name IS_ASSIGNED expression SEMICOLON .)
    SELECT          reduce using rule 270 (assign_stmt -> name IS_ASSIGNED expression SEMICOLON .)
    STRING          reduce using rule 270 (assign_stmt -> name IS_ASSIGNED expression SEMICOLON .)
    WHILE           reduce using rule 270 (assign_stmt -> name IS_ASSIGNED expression SEMICOLON .)
    DECLARE         reduce using rule 270 (assign_stmt -> name IS_ASSIGNED expression SEMICOLON .)
    FOR             reduce using rule 270 (assign_stmt -> name IS_ASSIGNED expression SEMICOLON .)
    LOOP            reduce using rule 270 (assign_stmt -> name IS_ASSIGNED expression SEMICOLON .)
    BEGIN           reduce using rule 270 (assign_stmt -> name IS_ASSIGNED expression SEMICOLON .)
    ELSE            reduce using rule 270 (assign_stmt -> name IS_ASSIGNED expression SEMICOLON .)
    ELSIF           reduce using rule 270 (assign_stmt -> name IS_ASSIGNED expression SEMICOLON .)
    WHEN            reduce using rule 270 (assign_stmt -> name IS_ASSIGNED expression SEMICOLON .)
    THEN            reduce using rule 270 (assign_stmt -> name IS_ASSIGNED expression SEMICOLON .)
    OR              reduce using rule 270 (assign_stmt -> name IS_ASSIGNED expression SEMICOLON .)
    EXCEPTION       reduce using rule 270 (assign_stmt -> name IS_ASSIGNED expression SEMICOLON .)


state 691

    (26) def_id -> IDENTIFIER .
    (161) simple_name -> IDENTIFIER .

    COLON           reduce using rule 26 (def_id -> IDENTIFIER .)
    COMMA           reduce using rule 26 (def_id -> IDENTIFIER .)
    TICK            reduce using rule 161 (simple_name -> IDENTIFIER .)
    LPAREN          reduce using rule 161 (simple_name -> IDENTIFIER .)
    DOT             reduce using rule 161 (simple_name -> IDENTIFIER .)
    POW             reduce using rule 161 (simple_name -> IDENTIFIER .)
    TIMES           reduce using rule 161 (simple_name -> IDENTIFIER .)
    DIVIDE          reduce using rule 161 (simple_name -> IDENTIFIER .)
    MOD             reduce using rule 161 (simple_name -> IDENTIFIER .)
    REM             reduce using rule 161 (simple_name -> IDENTIFIER .)
    EQ              reduce using rule 161 (simple_name -> IDENTIFIER .)
    NE              reduce using rule 161 (simple_name -> IDENTIFIER .)
    LT              reduce using rule 161 (simple_name -> IDENTIFIER .)
    LE              reduce using rule 161 (simple_name -> IDENTIFIER .)
    GT              reduce using rule 161 (simple_name -> IDENTIFIER .)
    GE              reduce using rule 161 (simple_name -> IDENTIFIER .)
    IN              reduce using rule 161 (simple_name -> IDENTIFIER .)
    NOT             reduce using rule 161 (simple_name -> IDENTIFIER .)
    PLUS            reduce using rule 161 (simple_name -> IDENTIFIER .)
    MINUS           reduce using rule 161 (simple_name -> IDENTIFIER .)
    AMPERSAND       reduce using rule 161 (simple_name -> IDENTIFIER .)
    RPAREN          reduce using rule 161 (simple_name -> IDENTIFIER .)
    AND             reduce using rule 161 (simple_name -> IDENTIFIER .)
    OR              reduce using rule 161 (simple_name -> IDENTIFIER .)
    XOR             reduce using rule 161 (simple_name -> IDENTIFIER .)


state 692

    (403) entry_name -> entry_name LPAREN expression . RPAREN
    (196) expression -> expression . logical relation
    (197) expression -> expression . short_circuit relation
    (198) logical -> . AND
    (199) logical -> . OR
    (200) logical -> . XOR
    (201) short_circuit -> . AND THEN
    (202) short_circuit -> . OR ELSE

    RPAREN          shift and go to state 788
    AND             shift and go to state 244
    OR              shift and go to state 248
    XOR             shift and go to state 245

    logical                        shift and go to state 246
    short_circuit                  shift and go to state 247

state 693

    (422) cond_entry_call -> SELECT entry_call stmts_opt ELSE . statement_s END SELECT SEMICOLON
    (243) statement_s -> . statement
    (244) statement_s -> . statement_s statement
    (245) statement -> . unlabeled
    (246) statement -> . label statement
    (247) unlabeled -> . simple_stmt
    (248) unlabeled -> . compound_stmt
    (249) unlabeled -> . pragma
    (268) label -> . LLB IDENTIFIER RLB
    (250) simple_stmt -> . NULL_stmt
    (251) simple_stmt -> . assign_stmt
    (252) simple_stmt -> . exit_stmt
    (253) simple_stmt -> . return_stmt
    (254) simple_stmt -> . goto_stmt
    (255) simple_stmt -> . procedure_call
    (256) simple_stmt -> . delay_stmt
    (257) simple_stmt -> . abort_stmt
    (258) simple_stmt -> . raise_stmt
    (259) simple_stmt -> . code_stmt
    (260) simple_stmt -> . requeue_stmt
    (261) simple_stmt -> . error SEMICOLON
    (262) compound_stmt -> . if_stmt
    (263) compound_stmt -> . case_stmt
    (264) compound_stmt -> . loop_stmt
    (265) compound_stmt -> . block
    (266) compound_stmt -> . accept_stmt
    (267) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (269) NULL_stmt -> . NULL SEMICOLON
    (270) assign_stmt -> . name IS_ASSIGNED expression SEMICOLON
    (302) exit_stmt -> . EXIT name_opt when_opt SEMICOLON
    (307) return_stmt -> . RETURN SEMICOLON
    (308) return_stmt -> . RETURN expression SEMICOLON
    (309) goto_stmt -> . GOTO name SEMICOLON
    (332) procedure_call -> . name SEMICOLON
    (404) delay_stmt -> . DELAY expression SEMICOLON
    (405) delay_stmt -> . DELAY UNTIL expression SEMICOLON
    (425) abort_stmt -> . ABORT name_s SEMICOLON
    (464) raise_stmt -> . RAISE name_opt SEMICOLON
    (510) code_stmt -> . qualified SEMICOLON
    (465) requeue_stmt -> . REQUEUE name SEMICOLON
    (466) requeue_stmt -> . REQUEUE name WITH ABORT SEMICOLON
    (271) if_stmt -> . IF cond_clause else_opt END IF SEMICOLON
    (278) case_stmt -> . case_hdr alternative_s END CASE SEMICOLON
    (283) loop_stmt -> . label_opt iteration basic_loop id_opt SEMICOLON
    (295) block -> . label_opt block_decl block_body END id_opt SEMICOLON
    (399) accept_stmt -> . accept_hdr SEMICOLON
    (400) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt SEMICOLON
    (406) select_stmt -> . select_wait
    (407) select_stmt -> . async_select
    (408) select_stmt -> . timed_entry_call
    (409) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (240) qualified -> . name TICK parenthesized_primary
    (279) case_hdr -> . CASE expression IS
    (284) label_opt -> .
    (285) label_opt -> . IDENTIFIER COLON
    (401) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (410) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON
    (420) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON
    (421) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON
    (422) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    LLB             shift and go to state 289
    error           shift and go to state 309
    PRAGMA          shift and go to state 4
    NULL            shift and go to state 311
    EXIT            shift and go to state 308
    RETURN          shift and go to state 295
    GOTO            shift and go to state 276
    DELAY           shift and go to state 272
    ABORT           shift and go to state 282
    RAISE           shift and go to state 306
    REQUEUE         shift and go to state 298
    IF              shift and go to state 317
    CASE            shift and go to state 297
    WHILE           reduce using rule 284 (label_opt -> .)
    DECLARE         reduce using rule 284 (label_opt -> .)
    FOR             reduce using rule 284 (label_opt -> .)
    LOOP            reduce using rule 284 (label_opt -> .)
    BEGIN           reduce using rule 284 (label_opt -> .)
    IDENTIFIER      shift and go to state 300
    ACCEPT          shift and go to state 284
    SELECT          shift and go to state 286
    STRING          shift and go to state 137

    indexed_comp                   shift and go to state 119
    accept_stmt                    shift and go to state 283
    label_opt                      shift and go to state 275
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 316
    abort_stmt                     shift and go to state 310
    return_stmt                    shift and go to state 294
    procedure_call                 shift and go to state 285
    assign_stmt                    shift and go to state 320
    statement_s                    shift and go to state 789
    simple_name                    shift and go to state 153
    code_stmt                      shift and go to state 313
    case_stmt                      shift and go to state 287
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 146
    label                          shift and go to state 288
    exit_stmt                      shift and go to state 315
    select_stmt                    shift and go to state 274
    statement                      shift and go to state 299
    compound_stmt                  shift and go to state 290
    case_hdr                       shift and go to state 292
    delay_stmt                     shift and go to state 301
    unlabeled                      shift and go to state 314
    simple_stmt                    shift and go to state 277
    loop_stmt                      shift and go to state 278
    qualified                      shift and go to state 279
    pragma                         shift and go to state 303
    async_select                   shift and go to state 273
    requeue_stmt                   shift and go to state 304
    raise_stmt                     shift and go to state 305
    name                           shift and go to state 281
    if_stmt                        shift and go to state 280
    accept_hdr                     shift and go to state 302
    cond_entry_call                shift and go to state 318
    timed_entry_call               shift and go to state 307
    goto_stmt                      shift and go to state 291
    NULL_stmt                      shift and go to state 319
    block                          shift and go to state 293

state 694

    (421) timed_entry_call -> SELECT entry_call stmts_opt OR . delay_stmt stmts_opt END SELECT SEMICOLON
    (404) delay_stmt -> . DELAY expression SEMICOLON
    (405) delay_stmt -> . DELAY UNTIL expression SEMICOLON

    DELAY           shift and go to state 272

    delay_stmt                     shift and go to state 790

state 695

    (420) async_select -> SELECT delay_or_entry_alt THEN ABORT . statement_s END SELECT SEMICOLON
    (243) statement_s -> . statement
    (244) statement_s -> . statement_s statement
    (245) statement -> . unlabeled
    (246) statement -> . label statement
    (247) unlabeled -> . simple_stmt
    (248) unlabeled -> . compound_stmt
    (249) unlabeled -> . pragma
    (268) label -> . LLB IDENTIFIER RLB
    (250) simple_stmt -> . NULL_stmt
    (251) simple_stmt -> . assign_stmt
    (252) simple_stmt -> . exit_stmt
    (253) simple_stmt -> . return_stmt
    (254) simple_stmt -> . goto_stmt
    (255) simple_stmt -> . procedure_call
    (256) simple_stmt -> . delay_stmt
    (257) simple_stmt -> . abort_stmt
    (258) simple_stmt -> . raise_stmt
    (259) simple_stmt -> . code_stmt
    (260) simple_stmt -> . requeue_stmt
    (261) simple_stmt -> . error SEMICOLON
    (262) compound_stmt -> . if_stmt
    (263) compound_stmt -> . case_stmt
    (264) compound_stmt -> . loop_stmt
    (265) compound_stmt -> . block
    (266) compound_stmt -> . accept_stmt
    (267) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (269) NULL_stmt -> . NULL SEMICOLON
    (270) assign_stmt -> . name IS_ASSIGNED expression SEMICOLON
    (302) exit_stmt -> . EXIT name_opt when_opt SEMICOLON
    (307) return_stmt -> . RETURN SEMICOLON
    (308) return_stmt -> . RETURN expression SEMICOLON
    (309) goto_stmt -> . GOTO name SEMICOLON
    (332) procedure_call -> . name SEMICOLON
    (404) delay_stmt -> . DELAY expression SEMICOLON
    (405) delay_stmt -> . DELAY UNTIL expression SEMICOLON
    (425) abort_stmt -> . ABORT name_s SEMICOLON
    (464) raise_stmt -> . RAISE name_opt SEMICOLON
    (510) code_stmt -> . qualified SEMICOLON
    (465) requeue_stmt -> . REQUEUE name SEMICOLON
    (466) requeue_stmt -> . REQUEUE name WITH ABORT SEMICOLON
    (271) if_stmt -> . IF cond_clause else_opt END IF SEMICOLON
    (278) case_stmt -> . case_hdr alternative_s END CASE SEMICOLON
    (283) loop_stmt -> . label_opt iteration basic_loop id_opt SEMICOLON
    (295) block -> . label_opt block_decl block_body END id_opt SEMICOLON
    (399) accept_stmt -> . accept_hdr SEMICOLON
    (400) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt SEMICOLON
    (406) select_stmt -> . select_wait
    (407) select_stmt -> . async_select
    (408) select_stmt -> . timed_entry_call
    (409) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (240) qualified -> . name TICK parenthesized_primary
    (279) case_hdr -> . CASE expression IS
    (284) label_opt -> .
    (285) label_opt -> . IDENTIFIER COLON
    (401) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (410) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON
    (420) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON
    (421) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON
    (422) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    LLB             shift and go to state 289
    error           shift and go to state 309
    PRAGMA          shift and go to state 4
    NULL            shift and go to state 311
    EXIT            shift and go to state 308
    RETURN          shift and go to state 295
    GOTO            shift and go to state 276
    DELAY           shift and go to state 272
    ABORT           shift and go to state 282
    RAISE           shift and go to state 306
    REQUEUE         shift and go to state 298
    IF              shift and go to state 317
    CASE            shift and go to state 297
    WHILE           reduce using rule 284 (label_opt -> .)
    DECLARE         reduce using rule 284 (label_opt -> .)
    FOR             reduce using rule 284 (label_opt -> .)
    LOOP            reduce using rule 284 (label_opt -> .)
    BEGIN           reduce using rule 284 (label_opt -> .)
    IDENTIFIER      shift and go to state 300
    ACCEPT          shift and go to state 284
    SELECT          shift and go to state 286
    STRING          shift and go to state 137

    indexed_comp                   shift and go to state 119
    accept_stmt                    shift and go to state 283
    label_opt                      shift and go to state 275
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 316
    abort_stmt                     shift and go to state 310
    return_stmt                    shift and go to state 294
    assign_stmt                    shift and go to state 320
    statement_s                    shift and go to state 791
    simple_name                    shift and go to state 153
    code_stmt                      shift and go to state 313
    case_stmt                      shift and go to state 287
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 146
    label                          shift and go to state 288
    exit_stmt                      shift and go to state 315
    select_stmt                    shift and go to state 274
    statement                      shift and go to state 299
    compound_stmt                  shift and go to state 290
    case_hdr                       shift and go to state 292
    delay_stmt                     shift and go to state 301
    unlabeled                      shift and go to state 314
    simple_stmt                    shift and go to state 277
    loop_stmt                      shift and go to state 278
    qualified                      shift and go to state 279
    pragma                         shift and go to state 303
    async_select                   shift and go to state 273
    requeue_stmt                   shift and go to state 304
    raise_stmt                     shift and go to state 305
    name                           shift and go to state 281
    if_stmt                        shift and go to state 280
    accept_hdr                     shift and go to state 302
    cond_entry_call                shift and go to state 318
    timed_entry_call               shift and go to state 307
    goto_stmt                      shift and go to state 291
    NULL_stmt                      shift and go to state 319
    procedure_call                 shift and go to state 285
    block                          shift and go to state 293

state 696

    (412) guarded_select_alt -> WHEN condition ARROW . select_alt
    (415) select_alt -> . accept_stmt stmts_opt
    (416) select_alt -> . delay_stmt stmts_opt
    (417) select_alt -> . TERMINATE SEMICOLON
    (399) accept_stmt -> . accept_hdr SEMICOLON
    (400) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt SEMICOLON
    (404) delay_stmt -> . DELAY expression SEMICOLON
    (405) delay_stmt -> . DELAY UNTIL expression SEMICOLON
    (401) accept_hdr -> . ACCEPT entry_name formal_part_opt

    TERMINATE       shift and go to state 445
    DELAY           shift and go to state 272
    ACCEPT          shift and go to state 284

    delay_stmt                     shift and go to state 792
    accept_hdr                     shift and go to state 302
    accept_stmt                    shift and go to state 437
    select_alt                     shift and go to state 793

state 697

    (410) select_wait -> SELECT guarded_select_alt or_select else_opt . END SELECT SEMICOLON

    END             shift and go to state 794


state 698

    (414) or_select -> or_select OR . guarded_select_alt
    (411) guarded_select_alt -> . select_alt
    (412) guarded_select_alt -> . WHEN condition ARROW select_alt
    (415) select_alt -> . accept_stmt stmts_opt
    (416) select_alt -> . delay_stmt stmts_opt
    (417) select_alt -> . TERMINATE SEMICOLON
    (399) accept_stmt -> . accept_hdr SEMICOLON
    (400) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt SEMICOLON
    (404) delay_stmt -> . DELAY expression SEMICOLON
    (405) delay_stmt -> . DELAY UNTIL expression SEMICOLON
    (401) accept_hdr -> . ACCEPT entry_name formal_part_opt

    WHEN            shift and go to state 440
    TERMINATE       shift and go to state 445
    DELAY           shift and go to state 272
    ACCEPT          shift and go to state 284

    delay_stmt                     shift and go to state 792
    accept_hdr                     shift and go to state 302
    accept_stmt                    shift and go to state 437
    guarded_select_alt             shift and go to state 795
    select_alt                     shift and go to state 442

state 699

    (278) case_stmt -> case_hdr alternative_s END CASE . SEMICOLON

    SEMICOLON       shift and go to state 796


state 700

    (282) alternative -> WHEN choice_s . ARROW statement_s
    (122) choice_s -> choice_s . | choice

    ARROW           shift and go to state 797
    |               shift and go to state 366


state 701

    (466) requeue_stmt -> REQUEUE name WITH ABORT . SEMICOLON

    SEMICOLON       shift and go to state 798


state 702

    (400) accept_stmt -> accept_hdr DO handled_stmt_s END . id_opt SEMICOLON
    (293) id_opt -> .
    (294) id_opt -> . designator
    (316) designator -> . compound_name
    (317) designator -> . STRING
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name DOT simple_name
    (161) simple_name -> . IDENTIFIER

    SEMICOLON       reduce using rule 293 (id_opt -> .)
    STRING          shift and go to state 114
    IDENTIFIER      shift and go to state 40

    designator                     shift and go to state 471
    id_opt                         shift and go to state 799
    compound_name                  shift and go to state 113
    simple_name                    shift and go to state 41

state 703

    (302) exit_stmt -> EXIT name_opt when_opt SEMICOLON .

    LLB             reduce using rule 302 (exit_stmt -> EXIT name_opt when_opt SEMICOLON .)
    error           reduce using rule 302 (exit_stmt -> EXIT name_opt when_opt SEMICOLON .)
    PRAGMA          reduce using rule 302 (exit_stmt -> EXIT name_opt when_opt SEMICOLON .)
    NULL            reduce using rule 302 (exit_stmt -> EXIT name_opt when_opt SEMICOLON .)
    EXIT            reduce using rule 302 (exit_stmt -> EXIT name_opt when_opt SEMICOLON .)
    RETURN          reduce using rule 302 (exit_stmt -> EXIT name_opt when_opt SEMICOLON .)
    GOTO            reduce using rule 302 (exit_stmt -> EXIT name_opt when_opt SEMICOLON .)
    DELAY           reduce using rule 302 (exit_stmt -> EXIT name_opt when_opt SEMICOLON .)
    ABORT           reduce using rule 302 (exit_stmt -> EXIT name_opt when_opt SEMICOLON .)
    RAISE           reduce using rule 302 (exit_stmt -> EXIT name_opt when_opt SEMICOLON .)
    REQUEUE         reduce using rule 302 (exit_stmt -> EXIT name_opt when_opt SEMICOLON .)
    IF              reduce using rule 302 (exit_stmt -> EXIT name_opt when_opt SEMICOLON .)
    CASE            reduce using rule 302 (exit_stmt -> EXIT name_opt when_opt SEMICOLON .)
    IDENTIFIER      reduce using rule 302 (exit_stmt -> EXIT name_opt when_opt SEMICOLON .)
    ACCEPT          reduce using rule 302 (exit_stmt -> EXIT name_opt when_opt SEMICOLON .)
    SELECT          reduce using rule 302 (exit_stmt -> EXIT name_opt when_opt SEMICOLON .)
    STRING          reduce using rule 302 (exit_stmt -> EXIT name_opt when_opt SEMICOLON .)
    WHILE           reduce using rule 302 (exit_stmt -> EXIT name_opt when_opt SEMICOLON .)
    DECLARE         reduce using rule 302 (exit_stmt -> EXIT name_opt when_opt SEMICOLON .)
    FOR             reduce using rule 302 (exit_stmt -> EXIT name_opt when_opt SEMICOLON .)
    LOOP            reduce using rule 302 (exit_stmt -> EXIT name_opt when_opt SEMICOLON .)
    BEGIN           reduce using rule 302 (exit_stmt -> EXIT name_opt when_opt SEMICOLON .)
    WHEN            reduce using rule 302 (exit_stmt -> EXIT name_opt when_opt SEMICOLON .)
    END             reduce using rule 302 (exit_stmt -> EXIT name_opt when_opt SEMICOLON .)
    OR              reduce using rule 302 (exit_stmt -> EXIT name_opt when_opt SEMICOLON .)
    ELSE            reduce using rule 302 (exit_stmt -> EXIT name_opt when_opt SEMICOLON .)
    THEN            reduce using rule 302 (exit_stmt -> EXIT name_opt when_opt SEMICOLON .)
    ELSIF           reduce using rule 302 (exit_stmt -> EXIT name_opt when_opt SEMICOLON .)
    EXCEPTION       reduce using rule 302 (exit_stmt -> EXIT name_opt when_opt SEMICOLON .)


state 704

    (306) when_opt -> WHEN condition .

    SEMICOLON       reduce using rule 306 (when_opt -> WHEN condition .)


state 705

    (459) exception_handler -> WHEN IDENTIFIER . COLON except_choice_s ARROW statement_s
    (161) simple_name -> IDENTIFIER .

    COLON           shift and go to state 800
    LPAREN          reduce using rule 161 (simple_name -> IDENTIFIER .)
    DOT             reduce using rule 161 (simple_name -> IDENTIFIER .)
    TICK            reduce using rule 161 (simple_name -> IDENTIFIER .)
    ARROW           reduce using rule 161 (simple_name -> IDENTIFIER .)
    |               reduce using rule 161 (simple_name -> IDENTIFIER .)


state 706

    (460) except_choice_s -> except_choice .

    ARROW           reduce using rule 460 (except_choice_s -> except_choice .)
    |               reduce using rule 460 (except_choice_s -> except_choice .)


state 707

    (463) except_choice -> OTHERS .

    ARROW           reduce using rule 463 (except_choice -> OTHERS .)
    |               reduce using rule 463 (except_choice -> OTHERS .)


state 708

    (462) except_choice -> name .
    (168) indexed_comp -> name . LPAREN value_s RPAREN
    (175) selected_comp -> name . DOT simple_name
    (176) selected_comp -> name . DOT used_char
    (177) selected_comp -> name . DOT operator_symbol
    (178) selected_comp -> name . DOT ALL
    (179) attribute -> name . TICK attribute_id

    ARROW           reduce using rule 462 (except_choice -> name .)
    |               reduce using rule 462 (except_choice -> name .)
    LPAREN          shift and go to state 240
    DOT             shift and go to state 242
    TICK            shift and go to state 251


state 709

    (458) exception_handler -> WHEN except_choice_s . ARROW statement_s
    (461) except_choice_s -> except_choice_s . | except_choice

    ARROW           shift and go to state 801
    |               shift and go to state 802


state 710

    (276) else_opt -> ELSE statement_s .
    (244) statement_s -> statement_s . statement
    (245) statement -> . unlabeled
    (246) statement -> . label statement
    (247) unlabeled -> . simple_stmt
    (248) unlabeled -> . compound_stmt
    (249) unlabeled -> . pragma
    (268) label -> . LLB IDENTIFIER RLB
    (250) simple_stmt -> . NULL_stmt
    (251) simple_stmt -> . assign_stmt
    (252) simple_stmt -> . exit_stmt
    (253) simple_stmt -> . return_stmt
    (254) simple_stmt -> . goto_stmt
    (255) simple_stmt -> . procedure_call
    (256) simple_stmt -> . delay_stmt
    (257) simple_stmt -> . abort_stmt
    (258) simple_stmt -> . raise_stmt
    (259) simple_stmt -> . code_stmt
    (260) simple_stmt -> . requeue_stmt
    (261) simple_stmt -> . error SEMICOLON
    (262) compound_stmt -> . if_stmt
    (263) compound_stmt -> . case_stmt
    (264) compound_stmt -> . loop_stmt
    (265) compound_stmt -> . block
    (266) compound_stmt -> . accept_stmt
    (267) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (269) NULL_stmt -> . NULL SEMICOLON
    (270) assign_stmt -> . name IS_ASSIGNED expression SEMICOLON
    (302) exit_stmt -> . EXIT name_opt when_opt SEMICOLON
    (307) return_stmt -> . RETURN SEMICOLON
    (308) return_stmt -> . RETURN expression SEMICOLON
    (309) goto_stmt -> . GOTO name SEMICOLON
    (332) procedure_call -> . name SEMICOLON
    (404) delay_stmt -> . DELAY expression SEMICOLON
    (405) delay_stmt -> . DELAY UNTIL expression SEMICOLON
    (425) abort_stmt -> . ABORT name_s SEMICOLON
    (464) raise_stmt -> . RAISE name_opt SEMICOLON
    (510) code_stmt -> . qualified SEMICOLON
    (465) requeue_stmt -> . REQUEUE name SEMICOLON
    (466) requeue_stmt -> . REQUEUE name WITH ABORT SEMICOLON
    (271) if_stmt -> . IF cond_clause else_opt END IF SEMICOLON
    (278) case_stmt -> . case_hdr alternative_s END CASE SEMICOLON
    (283) loop_stmt -> . label_opt iteration basic_loop id_opt SEMICOLON
    (295) block -> . label_opt block_decl block_body END id_opt SEMICOLON
    (399) accept_stmt -> . accept_hdr SEMICOLON
    (400) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt SEMICOLON
    (406) select_stmt -> . select_wait
    (407) select_stmt -> . async_select
    (408) select_stmt -> . timed_entry_call
    (409) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (240) qualified -> . name TICK parenthesized_primary
    (279) case_hdr -> . CASE expression IS
    (284) label_opt -> .
    (285) label_opt -> . IDENTIFIER COLON
    (401) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (410) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON
    (420) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON
    (421) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON
    (422) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    END             reduce using rule 276 (else_opt -> ELSE statement_s .)
    LLB             shift and go to state 289
    error           shift and go to state 309
    PRAGMA          shift and go to state 4
    NULL            shift and go to state 311
    EXIT            shift and go to state 308
    RETURN          shift and go to state 295
    GOTO            shift and go to state 276
    DELAY           shift and go to state 272
    ABORT           shift and go to state 282
    RAISE           shift and go to state 306
    REQUEUE         shift and go to state 298
    IF              shift and go to state 317
    CASE            shift and go to state 297
    WHILE           reduce using rule 284 (label_opt -> .)
    DECLARE         reduce using rule 284 (label_opt -> .)
    FOR             reduce using rule 284 (label_opt -> .)
    LOOP            reduce using rule 284 (label_opt -> .)
    BEGIN           reduce using rule 284 (label_opt -> .)
    IDENTIFIER      shift and go to state 300
    ACCEPT          shift and go to state 284
    SELECT          shift and go to state 286
    STRING          shift and go to state 137

    indexed_comp                   shift and go to state 119
    accept_stmt                    shift and go to state 283
    label_opt                      shift and go to state 275
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 316
    abort_stmt                     shift and go to state 310
    return_stmt                    shift and go to state 294
    procedure_call                 shift and go to state 285
    assign_stmt                    shift and go to state 320
    simple_name                    shift and go to state 153
    code_stmt                      shift and go to state 313
    case_stmt                      shift and go to state 287
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 146
    label                          shift and go to state 288
    exit_stmt                      shift and go to state 315
    select_stmt                    shift and go to state 274
    statement                      shift and go to state 465
    compound_stmt                  shift and go to state 290
    case_hdr                       shift and go to state 292
    delay_stmt                     shift and go to state 301
    unlabeled                      shift and go to state 314
    simple_stmt                    shift and go to state 277
    loop_stmt                      shift and go to state 278
    qualified                      shift and go to state 279
    pragma                         shift and go to state 303
    async_select                   shift and go to state 273
    requeue_stmt                   shift and go to state 304
    raise_stmt                     shift and go to state 305
    name                           shift and go to state 281
    if_stmt                        shift and go to state 280
    accept_hdr                     shift and go to state 302
    cond_entry_call                shift and go to state 318
    timed_entry_call               shift and go to state 307
    goto_stmt                      shift and go to state 291
    NULL_stmt                      shift and go to state 319
    block                          shift and go to state 293

state 711

    (271) if_stmt -> IF cond_clause else_opt END . IF SEMICOLON

    IF              shift and go to state 803


state 712

    (277) else_opt -> ELSIF cond_clause . else_opt
    (275) else_opt -> .
    (276) else_opt -> . ELSE statement_s
    (277) else_opt -> . ELSIF cond_clause else_opt

    END             reduce using rule 275 (else_opt -> .)
    ELSE            shift and go to state 588
    ELSIF           shift and go to state 590

    else_opt                       shift and go to state 804

state 713

    (504) record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s . END RECORD SEMICOLON
    (508) comp_loc_s -> comp_loc_s . mark AT expression RANGE range SEMICOLON
    (158) mark -> . simple_name
    (159) mark -> . mark TICK attribute_id
    (160) mark -> . mark DOT simple_name
    (161) simple_name -> . IDENTIFIER

    END             shift and go to state 805
    IDENTIFIER      shift and go to state 40

    mark                           shift and go to state 806
    simple_name                    shift and go to state 171

state 714

    (506) align_opt -> AT MOD . expression SEMICOLON
    (195) expression -> . relation
    (196) expression -> . expression logical relation
    (197) expression -> . expression short_circuit relation
    (203) relation -> . simple_expression
    (204) relation -> . simple_expression relational simple_expression
    (205) relation -> . simple_expression membership range
    (206) relation -> . simple_expression membership name
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    relation                       shift and go to state 127
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    factor                         shift and go to state 136
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    term                           shift and go to state 144
    name                           shift and go to state 145
    operator_symbol                shift and go to state 146
    expression                     shift and go to state 807

state 715

    (509) address_spec -> FOR mark USE AT expression SEMICOLON .

    PACKAGE         reduce using rule 509 (address_spec -> FOR mark USE AT expression SEMICOLON .)
    TASK            reduce using rule 509 (address_spec -> FOR mark USE AT expression SEMICOLON .)
    PROTECTED       reduce using rule 509 (address_spec -> FOR mark USE AT expression SEMICOLON .)
    error           reduce using rule 509 (address_spec -> FOR mark USE AT expression SEMICOLON .)
    USE             reduce using rule 509 (address_spec -> FOR mark USE AT expression SEMICOLON .)
    PRAGMA          reduce using rule 509 (address_spec -> FOR mark USE AT expression SEMICOLON .)
    TYPE            reduce using rule 509 (address_spec -> FOR mark USE AT expression SEMICOLON .)
    SUBTYPE         reduce using rule 509 (address_spec -> FOR mark USE AT expression SEMICOLON .)
    FOR             reduce using rule 509 (address_spec -> FOR mark USE AT expression SEMICOLON .)
    PROCEDURE       reduce using rule 509 (address_spec -> FOR mark USE AT expression SEMICOLON .)
    FUNCTION        reduce using rule 509 (address_spec -> FOR mark USE AT expression SEMICOLON .)
    GENERIC         reduce using rule 509 (address_spec -> FOR mark USE AT expression SEMICOLON .)
    IDENTIFIER      reduce using rule 509 (address_spec -> FOR mark USE AT expression SEMICOLON .)
    BEGIN           reduce using rule 509 (address_spec -> FOR mark USE AT expression SEMICOLON .)
    PRIVATE         reduce using rule 509 (address_spec -> FOR mark USE AT expression SEMICOLON .)
    END             reduce using rule 509 (address_spec -> FOR mark USE AT expression SEMICOLON .)
    ENTRY           reduce using rule 509 (address_spec -> FOR mark USE AT expression SEMICOLON .)


state 716

    (451) body_stub -> TASK BODY simple_name IS SEPARATE SEMICOLON .

    PACKAGE         reduce using rule 451 (body_stub -> TASK BODY simple_name IS SEPARATE SEMICOLON .)
    TASK            reduce using rule 451 (body_stub -> TASK BODY simple_name IS SEPARATE SEMICOLON .)
    PROTECTED       reduce using rule 451 (body_stub -> TASK BODY simple_name IS SEPARATE SEMICOLON .)
    error           reduce using rule 451 (body_stub -> TASK BODY simple_name IS SEPARATE SEMICOLON .)
    USE             reduce using rule 451 (body_stub -> TASK BODY simple_name IS SEPARATE SEMICOLON .)
    PRAGMA          reduce using rule 451 (body_stub -> TASK BODY simple_name IS SEPARATE SEMICOLON .)
    TYPE            reduce using rule 451 (body_stub -> TASK BODY simple_name IS SEPARATE SEMICOLON .)
    SUBTYPE         reduce using rule 451 (body_stub -> TASK BODY simple_name IS SEPARATE SEMICOLON .)
    FOR             reduce using rule 451 (body_stub -> TASK BODY simple_name IS SEPARATE SEMICOLON .)
    PROCEDURE       reduce using rule 451 (body_stub -> TASK BODY simple_name IS SEPARATE SEMICOLON .)
    FUNCTION        reduce using rule 451 (body_stub -> TASK BODY simple_name IS SEPARATE SEMICOLON .)
    GENERIC         reduce using rule 451 (body_stub -> TASK BODY simple_name IS SEPARATE SEMICOLON .)
    IDENTIFIER      reduce using rule 451 (body_stub -> TASK BODY simple_name IS SEPARATE SEMICOLON .)
    BEGIN           reduce using rule 451 (body_stub -> TASK BODY simple_name IS SEPARATE SEMICOLON .)
    END             reduce using rule 451 (body_stub -> TASK BODY simple_name IS SEPARATE SEMICOLON .)
    PRIVATE         reduce using rule 451 (body_stub -> TASK BODY simple_name IS SEPARATE SEMICOLON .)


state 717

    (365) task_body -> TASK BODY simple_name IS decl_part block_body . END id_opt SEMICOLON

    END             shift and go to state 808


state 718

    (397) rep_spec_s -> rep_spec_s rep_spec . pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    PRIVATE         reduce using rule 8 (pragma_s -> .)
    FOR             reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)

    pragma_s                       shift and go to state 809

state 719

    (364) task_private_opt -> PRIVATE . entry_decl_s rep_spec_s
    (388) entry_decl_s -> . pragma_s
    (389) entry_decl_s -> . entry_decl_s entry_decl pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    ENTRY           reduce using rule 8 (pragma_s -> .)
    FOR             reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)

    entry_decl_s                   shift and go to state 810
    pragma_s                       shift and go to state 481

state 720

    (362) task_def -> IS entry_decl_s rep_spec_s task_private_opt . END id_opt

    END             shift and go to state 811


state 721

    (389) entry_decl_s -> entry_decl_s entry_decl pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON

    ENTRY           reduce using rule 389 (entry_decl_s -> entry_decl_s entry_decl pragma_s .)
    FOR             reduce using rule 389 (entry_decl_s -> entry_decl_s entry_decl pragma_s .)
    END             reduce using rule 389 (entry_decl_s -> entry_decl_s entry_decl pragma_s .)
    PRIVATE         reduce using rule 389 (entry_decl_s -> entry_decl_s entry_decl pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 722

    (452) body_stub -> PACKAGE BODY compound_name IS SEPARATE SEMICOLON .

    PACKAGE         reduce using rule 452 (body_stub -> PACKAGE BODY compound_name IS SEPARATE SEMICOLON .)
    TASK            reduce using rule 452 (body_stub -> PACKAGE BODY compound_name IS SEPARATE SEMICOLON .)
    PROTECTED       reduce using rule 452 (body_stub -> PACKAGE BODY compound_name IS SEPARATE SEMICOLON .)
    error           reduce using rule 452 (body_stub -> PACKAGE BODY compound_name IS SEPARATE SEMICOLON .)
    USE             reduce using rule 452 (body_stub -> PACKAGE BODY compound_name IS SEPARATE SEMICOLON .)
    PRAGMA          reduce using rule 452 (body_stub -> PACKAGE BODY compound_name IS SEPARATE SEMICOLON .)
    TYPE            reduce using rule 452 (body_stub -> PACKAGE BODY compound_name IS SEPARATE SEMICOLON .)
    SUBTYPE         reduce using rule 452 (body_stub -> PACKAGE BODY compound_name IS SEPARATE SEMICOLON .)
    FOR             reduce using rule 452 (body_stub -> PACKAGE BODY compound_name IS SEPARATE SEMICOLON .)
    PROCEDURE       reduce using rule 452 (body_stub -> PACKAGE BODY compound_name IS SEPARATE SEMICOLON .)
    FUNCTION        reduce using rule 452 (body_stub -> PACKAGE BODY compound_name IS SEPARATE SEMICOLON .)
    GENERIC         reduce using rule 452 (body_stub -> PACKAGE BODY compound_name IS SEPARATE SEMICOLON .)
    IDENTIFIER      reduce using rule 452 (body_stub -> PACKAGE BODY compound_name IS SEPARATE SEMICOLON .)
    BEGIN           reduce using rule 452 (body_stub -> PACKAGE BODY compound_name IS SEPARATE SEMICOLON .)
    END             reduce using rule 452 (body_stub -> PACKAGE BODY compound_name IS SEPARATE SEMICOLON .)
    PRIVATE         reduce using rule 452 (body_stub -> PACKAGE BODY compound_name IS SEPARATE SEMICOLON .)


state 723

    (100) tagged_opt -> ABSTRACT TAGGED .

    LIMITED         reduce using rule 100 (tagged_opt -> ABSTRACT TAGGED .)
    RECORD          reduce using rule 100 (tagged_opt -> ABSTRACT TAGGED .)
    NULL            reduce using rule 100 (tagged_opt -> ABSTRACT TAGGED .)
    PRIVATE         reduce using rule 100 (tagged_opt -> ABSTRACT TAGGED .)


state 724

    (75) float_type -> DIGITS expression . range_spec_opt
    (196) expression -> expression . logical relation
    (197) expression -> expression . short_circuit relation
    (71) range_spec_opt -> .
    (72) range_spec_opt -> . range_spec
    (198) logical -> . AND
    (199) logical -> . OR
    (200) logical -> . XOR
    (201) short_circuit -> . AND THEN
    (202) short_circuit -> . OR ELSE
    (70) range_spec -> . range_constraint
    (59) range_constraint -> . RANGE range

    SEMICOLON       reduce using rule 71 (range_spec_opt -> .)
    AND             shift and go to state 244
    OR              shift and go to state 248
    XOR             shift and go to state 245
    RANGE           shift and go to state 371

    logical                        shift and go to state 246
    short_circuit                  shift and go to state 247
    range_constraint               shift and go to state 608
    range_spec                     shift and go to state 812
    range_spec_opt                 shift and go to state 813

state 725

    (345) limited_opt -> LIMITED .

    RECORD          reduce using rule 345 (limited_opt -> LIMITED .)
    NULL            reduce using rule 345 (limited_opt -> LIMITED .)
    PRIVATE         reduce using rule 345 (limited_opt -> LIMITED .)


state 726

    (95) record_type -> tagged_opt limited_opt . record_def
    (96) record_def -> . RECORD comp_list END RECORD
    (97) record_def -> . NULL RECORD

    RECORD          shift and go to state 814
    NULL            shift and go to state 815

    record_def                     shift and go to state 816

state 727

    (76) fixed_type -> DELTA expression . range_spec
    (77) fixed_type -> DELTA expression . DIGITS expression range_spec_opt
    (196) expression -> expression . logical relation
    (197) expression -> expression . short_circuit relation
    (70) range_spec -> . range_constraint
    (198) logical -> . AND
    (199) logical -> . OR
    (200) logical -> . XOR
    (201) short_circuit -> . AND THEN
    (202) short_circuit -> . OR ELSE
    (59) range_constraint -> . RANGE range

    DIGITS          shift and go to state 817
    AND             shift and go to state 244
    OR              shift and go to state 248
    XOR             shift and go to state 245
    RANGE           shift and go to state 371

    logical                        shift and go to state 246
    short_circuit                  shift and go to state 247
    range_constraint               shift and go to state 608
    range_spec                     shift and go to state 818

state 728

    (63) enumeration_type -> LPAREN enum_id_s . RPAREN
    (65) enum_id_s -> enum_id_s . COMMA enum_id

    RPAREN          shift and go to state 820
    COMMA           shift and go to state 819


state 729

    (67) enum_id -> CHARACTER .

    RPAREN          reduce using rule 67 (enum_id -> CHARACTER .)
    COMMA           reduce using rule 67 (enum_id -> CHARACTER .)


state 730

    (66) enum_id -> IDENTIFIER .

    RPAREN          reduce using rule 66 (enum_id -> IDENTIFIER .)
    COMMA           reduce using rule 66 (enum_id -> IDENTIFIER .)


state 731

    (64) enum_id_s -> enum_id .

    RPAREN          reduce using rule 64 (enum_id_s -> enum_id .)
    COMMA           reduce using rule 64 (enum_id_s -> enum_id .)


state 732

    (129) access_type -> ACCESS CONSTANT . subtype_ind
    (49) subtype_ind -> . name constraint
    (50) subtype_ind -> . name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    name                           shift and go to state 490
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 146
    subtype_ind                    shift and go to state 821
    indexed_comp                   shift and go to state 119
    simple_name                    shift and go to state 153

state 733

    (131) access_type -> ACCESS prot_opt . PROCEDURE formal_part_opt
    (132) access_type -> ACCESS prot_opt . FUNCTION formal_part_opt RETURN mark

    PROCEDURE       shift and go to state 823
    FUNCTION        shift and go to state 822


state 734

    (134) prot_opt -> PROTECTED .

    PROCEDURE       reduce using rule 134 (prot_opt -> PROTECTED .)
    FUNCTION        reduce using rule 134 (prot_opt -> PROTECTED .)


state 735

    (130) access_type -> ACCESS ALL . subtype_ind
    (49) subtype_ind -> . name constraint
    (50) subtype_ind -> . name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    name                           shift and go to state 490
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 146
    subtype_ind                    shift and go to state 824
    indexed_comp                   shift and go to state 119
    simple_name                    shift and go to state 153

state 736

    (128) access_type -> ACCESS subtype_ind .

    SEMICOLON       reduce using rule 128 (access_type -> ACCESS subtype_ind .)


state 737

    (69) integer_type -> MOD expression .
    (196) expression -> expression . logical relation
    (197) expression -> expression . short_circuit relation
    (198) logical -> . AND
    (199) logical -> . OR
    (200) logical -> . XOR
    (201) short_circuit -> . AND THEN
    (202) short_circuit -> . OR ELSE

    SEMICOLON       reduce using rule 69 (integer_type -> MOD expression .)
    AND             shift and go to state 244
    OR              shift and go to state 248
    XOR             shift and go to state 245

    logical                        shift and go to state 246
    short_circuit                  shift and go to state 247

state 738

    (112) discrim_spec_s -> discrim_spec_s SEMICOLON discrim_spec .

    RPAREN          reduce using rule 112 (discrim_spec_s -> discrim_spec_s SEMICOLON discrim_spec .)
    SEMICOLON       reduce using rule 112 (discrim_spec_s -> discrim_spec_s SEMICOLON discrim_spec .)


state 739

    (116) access_opt -> ACCESS .

    IDENTIFIER      reduce using rule 116 (access_opt -> ACCESS .)


state 740

    (113) discrim_spec -> def_id_s COLON access_opt . mark init_opt
    (158) mark -> . simple_name
    (159) mark -> . mark TICK attribute_id
    (160) mark -> . mark DOT simple_name
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 40

    mark                           shift and go to state 825
    simple_name                    shift and go to state 171

state 741

    (53) decimal_digits_constraint -> DIGITS expression . range_constr_opt
    (196) expression -> expression . logical relation
    (197) expression -> expression . short_circuit relation
    (93) range_constr_opt -> .
    (94) range_constr_opt -> . range_constraint
    (198) logical -> . AND
    (199) logical -> . OR
    (200) logical -> . XOR
    (201) short_circuit -> . AND THEN
    (202) short_circuit -> . OR ELSE
    (59) range_constraint -> . RANGE range

    SEMICOLON       reduce using rule 93 (range_constr_opt -> .)
    RENAMES         reduce using rule 93 (range_constr_opt -> .)
    IS_ASSIGNED     reduce using rule 93 (range_constr_opt -> .)
    WITH            reduce using rule 93 (range_constr_opt -> .)
    AND             shift and go to state 244
    OR              shift and go to state 248
    XOR             shift and go to state 245
    RANGE           shift and go to state 371

    range_constr_opt               shift and go to state 826
    logical                        shift and go to state 246
    short_circuit                  shift and go to state 247
    range_constraint               shift and go to state 784

state 742

    (35) number_decl -> def_id_s COLON CONSTANT IS_ASSIGNED expression SEMICOLON .

    PACKAGE         reduce using rule 35 (number_decl -> def_id_s COLON CONSTANT IS_ASSIGNED expression SEMICOLON .)
    TASK            reduce using rule 35 (number_decl -> def_id_s COLON CONSTANT IS_ASSIGNED expression SEMICOLON .)
    PROTECTED       reduce using rule 35 (number_decl -> def_id_s COLON CONSTANT IS_ASSIGNED expression SEMICOLON .)
    error           reduce using rule 35 (number_decl -> def_id_s COLON CONSTANT IS_ASSIGNED expression SEMICOLON .)
    USE             reduce using rule 35 (number_decl -> def_id_s COLON CONSTANT IS_ASSIGNED expression SEMICOLON .)
    PRAGMA          reduce using rule 35 (number_decl -> def_id_s COLON CONSTANT IS_ASSIGNED expression SEMICOLON .)
    TYPE            reduce using rule 35 (number_decl -> def_id_s COLON CONSTANT IS_ASSIGNED expression SEMICOLON .)
    SUBTYPE         reduce using rule 35 (number_decl -> def_id_s COLON CONSTANT IS_ASSIGNED expression SEMICOLON .)
    FOR             reduce using rule 35 (number_decl -> def_id_s COLON CONSTANT IS_ASSIGNED expression SEMICOLON .)
    PROCEDURE       reduce using rule 35 (number_decl -> def_id_s COLON CONSTANT IS_ASSIGNED expression SEMICOLON .)
    FUNCTION        reduce using rule 35 (number_decl -> def_id_s COLON CONSTANT IS_ASSIGNED expression SEMICOLON .)
    GENERIC         reduce using rule 35 (number_decl -> def_id_s COLON CONSTANT IS_ASSIGNED expression SEMICOLON .)
    IDENTIFIER      reduce using rule 35 (number_decl -> def_id_s COLON CONSTANT IS_ASSIGNED expression SEMICOLON .)
    BEGIN           reduce using rule 35 (number_decl -> def_id_s COLON CONSTANT IS_ASSIGNED expression SEMICOLON .)
    END             reduce using rule 35 (number_decl -> def_id_s COLON CONSTANT IS_ASSIGNED expression SEMICOLON .)
    PRIVATE         reduce using rule 35 (number_decl -> def_id_s COLON CONSTANT IS_ASSIGNED expression SEMICOLON .)


state 743

    (81) constr_array_type -> ARRAY iter_index_constraint OF . component_subtype_def
    (82) component_subtype_def -> . aliased_opt subtype_ind
    (83) aliased_opt -> .
    (84) aliased_opt -> . ALIASED

    IDENTIFIER      reduce using rule 83 (aliased_opt -> .)
    STRING          reduce using rule 83 (aliased_opt -> .)
    ALIASED         shift and go to state 827

    aliased_opt                    shift and go to state 828
    component_subtype_def          shift and go to state 829

state 744

    (88) iter_index_constraint -> LPAREN iter_discrete_range_s . RPAREN
    (90) iter_discrete_range_s -> iter_discrete_range_s . COMMA discrete_range

    RPAREN          shift and go to state 831
    COMMA           shift and go to state 830


state 745

    (85) index_s -> index .

    RPAREN          reduce using rule 85 (index_s -> index .)
    COMMA           reduce using rule 85 (index_s -> index .)


state 746

    (80) unconstr_array_type -> ARRAY LPAREN index_s . RPAREN OF component_subtype_def
    (86) index_s -> index_s . COMMA index

    RPAREN          shift and go to state 832
    COMMA           shift and go to state 833


state 747

    (89) iter_discrete_range_s -> discrete_range .

    RPAREN          reduce using rule 89 (iter_discrete_range_s -> discrete_range .)
    COMMA           reduce using rule 89 (iter_discrete_range_s -> discrete_range .)


state 748

    (87) index -> name . RANGE BOX
    (91) discrete_range -> name . range_constr_opt
    (61) range -> name . TICK RANGE
    (62) range -> name . TICK RANGE LPAREN expression RPAREN
    (168) indexed_comp -> name . LPAREN value_s RPAREN
    (175) selected_comp -> name . DOT simple_name
    (176) selected_comp -> name . DOT used_char
    (177) selected_comp -> name . DOT operator_symbol
    (178) selected_comp -> name . DOT ALL
    (179) attribute -> name . TICK attribute_id
    (237) primary -> name .
    (240) qualified -> name . TICK parenthesized_primary
    (93) range_constr_opt -> .
    (94) range_constr_opt -> . range_constraint
    (59) range_constraint -> . RANGE range

    RANGE           shift and go to state 834
    TICK            shift and go to state 373
    LPAREN          shift and go to state 240
    DOT             shift and go to state 242
    POW             reduce using rule 237 (primary -> name .)
    TIMES           reduce using rule 237 (primary -> name .)
    DIVIDE          reduce using rule 237 (primary -> name .)
    MOD             reduce using rule 237 (primary -> name .)
    REM             reduce using rule 237 (primary -> name .)
    DOUBLEDOT       reduce using rule 237 (primary -> name .)
    PLUS            reduce using rule 237 (primary -> name .)
    MINUS           reduce using rule 237 (primary -> name .)
    AMPERSAND       reduce using rule 237 (primary -> name .)
    RPAREN          reduce using rule 93 (range_constr_opt -> .)
    COMMA           reduce using rule 93 (range_constr_opt -> .)

    range_constr_opt               shift and go to state 783
    range_constraint               shift and go to state 784

state 749

    (34) init_opt -> IS_ASSIGNED expression .
    (196) expression -> expression . logical relation
    (197) expression -> expression . short_circuit relation
    (198) logical -> . AND
    (199) logical -> . OR
    (200) logical -> . XOR
    (201) short_circuit -> . AND THEN
    (202) short_circuit -> . OR ELSE

    SEMICOLON       reduce using rule 34 (init_opt -> IS_ASSIGNED expression .)
    RPAREN          reduce using rule 34 (init_opt -> IS_ASSIGNED expression .)
    AND             shift and go to state 244
    OR              shift and go to state 248
    XOR             shift and go to state 245

    logical                        shift and go to state 246
    short_circuit                  shift and go to state 247

state 750

    (23) object_decl -> def_id_s COLON object_qualifier_opt object_subtype_def init_opt SEMICOLON .

    PACKAGE         reduce using rule 23 (object_decl -> def_id_s COLON object_qualifier_opt object_subtype_def init_opt SEMICOLON .)
    TASK            reduce using rule 23 (object_decl -> def_id_s COLON object_qualifier_opt object_subtype_def init_opt SEMICOLON .)
    PROTECTED       reduce using rule 23 (object_decl -> def_id_s COLON object_qualifier_opt object_subtype_def init_opt SEMICOLON .)
    error           reduce using rule 23 (object_decl -> def_id_s COLON object_qualifier_opt object_subtype_def init_opt SEMICOLON .)
    USE             reduce using rule 23 (object_decl -> def_id_s COLON object_qualifier_opt object_subtype_def init_opt SEMICOLON .)
    PRAGMA          reduce using rule 23 (object_decl -> def_id_s COLON object_qualifier_opt object_subtype_def init_opt SEMICOLON .)
    TYPE            reduce using rule 23 (object_decl -> def_id_s COLON object_qualifier_opt object_subtype_def init_opt SEMICOLON .)
    SUBTYPE         reduce using rule 23 (object_decl -> def_id_s COLON object_qualifier_opt object_subtype_def init_opt SEMICOLON .)
    FOR             reduce using rule 23 (object_decl -> def_id_s COLON object_qualifier_opt object_subtype_def init_opt SEMICOLON .)
    PROCEDURE       reduce using rule 23 (object_decl -> def_id_s COLON object_qualifier_opt object_subtype_def init_opt SEMICOLON .)
    FUNCTION        reduce using rule 23 (object_decl -> def_id_s COLON object_qualifier_opt object_subtype_def init_opt SEMICOLON .)
    GENERIC         reduce using rule 23 (object_decl -> def_id_s COLON object_qualifier_opt object_subtype_def init_opt SEMICOLON .)
    IDENTIFIER      reduce using rule 23 (object_decl -> def_id_s COLON object_qualifier_opt object_subtype_def init_opt SEMICOLON .)
    BEGIN           reduce using rule 23 (object_decl -> def_id_s COLON object_qualifier_opt object_subtype_def init_opt SEMICOLON .)
    END             reduce using rule 23 (object_decl -> def_id_s COLON object_qualifier_opt object_subtype_def init_opt SEMICOLON .)
    PRIVATE         reduce using rule 23 (object_decl -> def_id_s COLON object_qualifier_opt object_subtype_def init_opt SEMICOLON .)


state 751

    (350) rename_decl -> def_id_s COLON object_qualifier_opt subtype_ind renames SEMICOLON .

    error           reduce using rule 350 (rename_decl -> def_id_s COLON object_qualifier_opt subtype_ind renames SEMICOLON .)
    USE             reduce using rule 350 (rename_decl -> def_id_s COLON object_qualifier_opt subtype_ind renames SEMICOLON .)
    PRAGMA          reduce using rule 350 (rename_decl -> def_id_s COLON object_qualifier_opt subtype_ind renames SEMICOLON .)
    TYPE            reduce using rule 350 (rename_decl -> def_id_s COLON object_qualifier_opt subtype_ind renames SEMICOLON .)
    SUBTYPE         reduce using rule 350 (rename_decl -> def_id_s COLON object_qualifier_opt subtype_ind renames SEMICOLON .)
    TASK            reduce using rule 350 (rename_decl -> def_id_s COLON object_qualifier_opt subtype_ind renames SEMICOLON .)
    PACKAGE         reduce using rule 350 (rename_decl -> def_id_s COLON object_qualifier_opt subtype_ind renames SEMICOLON .)
    PROTECTED       reduce using rule 350 (rename_decl -> def_id_s COLON object_qualifier_opt subtype_ind renames SEMICOLON .)
    FOR             reduce using rule 350 (rename_decl -> def_id_s COLON object_qualifier_opt subtype_ind renames SEMICOLON .)
    PROCEDURE       reduce using rule 350 (rename_decl -> def_id_s COLON object_qualifier_opt subtype_ind renames SEMICOLON .)
    FUNCTION        reduce using rule 350 (rename_decl -> def_id_s COLON object_qualifier_opt subtype_ind renames SEMICOLON .)
    GENERIC         reduce using rule 350 (rename_decl -> def_id_s COLON object_qualifier_opt subtype_ind renames SEMICOLON .)
    IDENTIFIER      reduce using rule 350 (rename_decl -> def_id_s COLON object_qualifier_opt subtype_ind renames SEMICOLON .)
    PRIVATE         reduce using rule 350 (rename_decl -> def_id_s COLON object_qualifier_opt subtype_ind renames SEMICOLON .)
    END             reduce using rule 350 (rename_decl -> def_id_s COLON object_qualifier_opt subtype_ind renames SEMICOLON .)
    BEGIN           reduce using rule 350 (rename_decl -> def_id_s COLON object_qualifier_opt subtype_ind renames SEMICOLON .)


state 752

    (474) generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name . subp_default SEMICOLON
    (168) indexed_comp -> name . LPAREN value_s RPAREN
    (175) selected_comp -> name . DOT simple_name
    (176) selected_comp -> name . DOT used_char
    (177) selected_comp -> name . DOT operator_symbol
    (178) selected_comp -> name . DOT ALL
    (179) attribute -> name . TICK attribute_id
    (481) subp_default -> .
    (482) subp_default -> . IS name
    (483) subp_default -> . IS BOX

    LPAREN          shift and go to state 240
    DOT             shift and go to state 242
    TICK            shift and go to state 251
    SEMICOLON       reduce using rule 481 (subp_default -> .)
    IS              shift and go to state 642

    subp_default                   shift and go to state 835

state 753

    (475) generic_formal -> WITH PACKAGE simple_name IS NEW name . LPAREN BOX RPAREN SEMICOLON
    (476) generic_formal -> WITH PACKAGE simple_name IS NEW name . SEMICOLON
    (168) indexed_comp -> name . LPAREN value_s RPAREN
    (175) selected_comp -> name . DOT simple_name
    (176) selected_comp -> name . DOT used_char
    (177) selected_comp -> name . DOT operator_symbol
    (178) selected_comp -> name . DOT ALL
    (179) attribute -> name . TICK attribute_id

    LPAREN          shift and go to state 837
    SEMICOLON       shift and go to state 836
    DOT             shift and go to state 242
    TICK            shift and go to state 251


state 754

    (483) subp_default -> IS BOX .

    SEMICOLON       reduce using rule 483 (subp_default -> IS BOX .)


state 755

    (482) subp_default -> IS name .
    (168) indexed_comp -> name . LPAREN value_s RPAREN
    (175) selected_comp -> name . DOT simple_name
    (176) selected_comp -> name . DOT used_char
    (177) selected_comp -> name . DOT operator_symbol
    (178) selected_comp -> name . DOT ALL
    (179) attribute -> name . TICK attribute_id

    SEMICOLON       reduce using rule 482 (subp_default -> IS name .)
    LPAREN          shift and go to state 240
    DOT             shift and go to state 242
    TICK            shift and go to state 251


state 756

    (473) generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default SEMICOLON .

    PACKAGE         reduce using rule 473 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default SEMICOLON .)
    PROCEDURE       reduce using rule 473 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default SEMICOLON .)
    FUNCTION        reduce using rule 473 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default SEMICOLON .)
    TYPE            reduce using rule 473 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default SEMICOLON .)
    WITH            reduce using rule 473 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default SEMICOLON .)
    error           reduce using rule 473 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default SEMICOLON .)
    USE             reduce using rule 473 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default SEMICOLON .)
    IDENTIFIER      reduce using rule 473 (generic_formal -> WITH PROCEDURE simple_name formal_part_opt subp_default SEMICOLON .)


state 757

    (496) generic_derived_type -> ABSTRACT NEW . subtype_ind WITH PRIVATE
    (49) subtype_ind -> . name constraint
    (50) subtype_ind -> . name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    name                           shift and go to state 490
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 146
    subtype_ind                    shift and go to state 838
    indexed_comp                   shift and go to state 119
    simple_name                    shift and go to state 153

state 758

    (472) generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def SEMICOLON .

    PACKAGE         reduce using rule 472 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def SEMICOLON .)
    PROCEDURE       reduce using rule 472 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def SEMICOLON .)
    FUNCTION        reduce using rule 472 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def SEMICOLON .)
    TYPE            reduce using rule 472 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def SEMICOLON .)
    WITH            reduce using rule 472 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def SEMICOLON .)
    error           reduce using rule 472 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def SEMICOLON .)
    USE             reduce using rule 472 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def SEMICOLON .)
    IDENTIFIER      reduce using rule 472 (generic_formal -> TYPE simple_name generic_discrim_part_opt IS generic_type_def SEMICOLON .)


state 759

    (494) generic_derived_type -> NEW subtype_ind .
    (495) generic_derived_type -> NEW subtype_ind . WITH PRIVATE

    SEMICOLON       reduce using rule 494 (generic_derived_type -> NEW subtype_ind .)
    WITH            shift and go to state 839


state 760

    (489) generic_type_def -> DIGITS BOX .

    SEMICOLON       reduce using rule 489 (generic_type_def -> DIGITS BOX .)


state 761

    (343) private_type -> tagged_opt limited_opt . PRIVATE

    PRIVATE         shift and go to state 840


state 762

    (485) generic_type_def -> RANGE BOX .

    SEMICOLON       reduce using rule 485 (generic_type_def -> RANGE BOX .)


state 763

    (484) generic_type_def -> LPAREN BOX . RPAREN

    RPAREN          shift and go to state 841


state 764

    (487) generic_type_def -> DELTA BOX .
    (488) generic_type_def -> DELTA BOX . DIGITS BOX

    SEMICOLON       reduce using rule 487 (generic_type_def -> DELTA BOX .)
    DIGITS          shift and go to state 842


state 765

    (486) generic_type_def -> MOD BOX .

    SEMICOLON       reduce using rule 486 (generic_type_def -> MOD BOX .)


state 766

    (62) range -> name TICK RANGE LPAREN expression . RPAREN
    (196) expression -> expression . logical relation
    (197) expression -> expression . short_circuit relation
    (198) logical -> . AND
    (199) logical -> . OR
    (200) logical -> . XOR
    (201) short_circuit -> . AND THEN
    (202) short_circuit -> . OR ELSE

    RPAREN          shift and go to state 843
    AND             shift and go to state 244
    OR              shift and go to state 248
    XOR             shift and go to state 245

    logical                        shift and go to state 246
    short_circuit                  shift and go to state 247

state 767

    (190) aggregate -> LPAREN expression WITH NULL RECORD RPAREN .

    POW             reduce using rule 190 (aggregate -> LPAREN expression WITH NULL RECORD RPAREN .)
    TIMES           reduce using rule 190 (aggregate -> LPAREN expression WITH NULL RECORD RPAREN .)
    DIVIDE          reduce using rule 190 (aggregate -> LPAREN expression WITH NULL RECORD RPAREN .)
    MOD             reduce using rule 190 (aggregate -> LPAREN expression WITH NULL RECORD RPAREN .)
    REM             reduce using rule 190 (aggregate -> LPAREN expression WITH NULL RECORD RPAREN .)
    EQ              reduce using rule 190 (aggregate -> LPAREN expression WITH NULL RECORD RPAREN .)
    NE              reduce using rule 190 (aggregate -> LPAREN expression WITH NULL RECORD RPAREN .)
    LT              reduce using rule 190 (aggregate -> LPAREN expression WITH NULL RECORD RPAREN .)
    LE              reduce using rule 190 (aggregate -> LPAREN expression WITH NULL RECORD RPAREN .)
    GT              reduce using rule 190 (aggregate -> LPAREN expression WITH NULL RECORD RPAREN .)
    GE              reduce using rule 190 (aggregate -> LPAREN expression WITH NULL RECORD RPAREN .)
    IN              reduce using rule 190 (aggregate -> LPAREN expression WITH NULL RECORD RPAREN .)
    NOT             reduce using rule 190 (aggregate -> LPAREN expression WITH NULL RECORD RPAREN .)
    PLUS            reduce using rule 190 (aggregate -> LPAREN expression WITH NULL RECORD RPAREN .)
    MINUS           reduce using rule 190 (aggregate -> LPAREN expression WITH NULL RECORD RPAREN .)
    AMPERSAND       reduce using rule 190 (aggregate -> LPAREN expression WITH NULL RECORD RPAREN .)
    AND             reduce using rule 190 (aggregate -> LPAREN expression WITH NULL RECORD RPAREN .)
    OR              reduce using rule 190 (aggregate -> LPAREN expression WITH NULL RECORD RPAREN .)
    XOR             reduce using rule 190 (aggregate -> LPAREN expression WITH NULL RECORD RPAREN .)
    THEN            reduce using rule 190 (aggregate -> LPAREN expression WITH NULL RECORD RPAREN .)
    RPAREN          reduce using rule 190 (aggregate -> LPAREN expression WITH NULL RECORD RPAREN .)
    COMMA           reduce using rule 190 (aggregate -> LPAREN expression WITH NULL RECORD RPAREN .)
    DOUBLEDOT       reduce using rule 190 (aggregate -> LPAREN expression WITH NULL RECORD RPAREN .)
    WITH            reduce using rule 190 (aggregate -> LPAREN expression WITH NULL RECORD RPAREN .)
    ARROW           reduce using rule 190 (aggregate -> LPAREN expression WITH NULL RECORD RPAREN .)
    |               reduce using rule 190 (aggregate -> LPAREN expression WITH NULL RECORD RPAREN .)
    SEMICOLON       reduce using rule 190 (aggregate -> LPAREN expression WITH NULL RECORD RPAREN .)
    IS              reduce using rule 190 (aggregate -> LPAREN expression WITH NULL RECORD RPAREN .)
    LOOP            reduce using rule 190 (aggregate -> LPAREN expression WITH NULL RECORD RPAREN .)
    RANGE           reduce using rule 190 (aggregate -> LPAREN expression WITH NULL RECORD RPAREN .)
    DIGITS          reduce using rule 190 (aggregate -> LPAREN expression WITH NULL RECORD RPAREN .)
    RENAMES         reduce using rule 190 (aggregate -> LPAREN expression WITH NULL RECORD RPAREN .)
    IS_ASSIGNED     reduce using rule 190 (aggregate -> LPAREN expression WITH NULL RECORD RPAREN .)


state 768

    (382) prot_body -> PROTECTED BODY simple_name IS . prot_op_body_s END id_opt SEMICOLON
    (383) prot_op_body_s -> . pragma_s
    (384) prot_op_body_s -> . prot_op_body_s prot_op_body pragma_s
    (8) pragma_s -> .
    (9) pragma_s -> . pragma_s pragma

    PRAGMA          reduce using rule 8 (pragma_s -> .)
    END             reduce using rule 8 (pragma_s -> .)
    ENTRY           reduce using rule 8 (pragma_s -> .)
    PROCEDURE       reduce using rule 8 (pragma_s -> .)
    FUNCTION        reduce using rule 8 (pragma_s -> .)

    prot_op_body_s                 shift and go to state 539
    pragma_s                       shift and go to state 540

state 769

    (365) task_body -> TASK BODY simple_name IS . decl_part block_body END id_opt SEMICOLON
    (135) decl_part -> .
    (136) decl_part -> . decl_item_or_body_s1
    (145) decl_item_or_body_s1 -> . decl_item_or_body
    (146) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (147) decl_item_or_body -> . body
    (148) decl_item_or_body -> . decl_item
    (149) body -> . subprog_body
    (150) body -> . pkg_body
    (151) body -> . task_body
    (152) body -> . prot_body
    (141) decl_item -> . decl
    (142) decl_item -> . use_clause
    (143) decl_item -> . rep_spec
    (144) decl_item -> . pragma
    (331) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt SEMICOLON
    (340) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt SEMICOLON
    (365) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt SEMICOLON
    (382) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt SEMICOLON
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error SEMICOLON
    (346) use_clause -> . USE name_s SEMICOLON
    (347) use_clause -> . USE TYPE name_s SEMICOLON
    (500) rep_spec -> . attrib_def
    (501) rep_spec -> . record_type_spec
    (502) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (330) subprog_spec_is_push -> . subprog_spec IS
    (23) object_decl -> . def_id_s COLON object_qualifier_opt object_subtype_def init_opt SEMICOLON
    (35) number_decl -> . def_id_s COLON CONSTANT IS_ASSIGNED expression SEMICOLON
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion SEMICOLON
    (48) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind SEMICOLON
    (310) subprog_decl -> . subprog_spec SEMICOLON
    (311) subprog_decl -> . generic_subp_inst SEMICOLON
    (312) subprog_decl -> . subprog_spec_is_push ABSTRACT SEMICOLON
    (333) pkg_decl -> . pkg_spec SEMICOLON
    (334) pkg_decl -> . generic_pkg_inst SEMICOLON
    (358) task_decl -> . task_spec SEMICOLON
    (366) prot_decl -> . prot_spec SEMICOLON
    (455) exception_decl -> . def_id_s COLON EXCEPTION SEMICOLON
    (350) rename_decl -> . def_id_s COLON object_qualifier_opt subtype_ind renames SEMICOLON
    (351) rename_decl -> . def_id_s COLON EXCEPTION renames SEMICOLON
    (352) rename_decl -> . rename_unit
    (467) generic_decl -> . generic_formal_part subprog_spec SEMICOLON
    (468) generic_decl -> . generic_formal_part pkg_spec SEMICOLON
    (451) body_stub -> . TASK BODY simple_name IS SEPARATE SEMICOLON
    (452) body_stub -> . PACKAGE BODY compound_name IS SEPARATE SEMICOLON
    (453) body_stub -> . subprog_spec IS SEPARATE SEMICOLON
    (454) body_stub -> . PROTECTED BODY simple_name IS SEPARATE SEMICOLON
    (503) attrib_def -> . FOR mark USE expression SEMICOLON
    (504) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD SEMICOLON
    (509) address_spec -> . FOR mark USE AT expression SEMICOLON
    (313) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (314) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (315) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s COMMA def_id
    (497) generic_subp_inst -> . subprog_spec IS generic_inst
    (335) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (498) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (359) task_spec -> . TASK simple_name task_def
    (360) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (367) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (368) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (353) rename_unit -> . PACKAGE compound_name renames SEMICOLON
    (354) rename_unit -> . subprog_spec renames SEMICOLON
    (355) rename_unit -> . generic_formal_part PACKAGE compound_name renames SEMICOLON
    (356) rename_unit -> . generic_formal_part subprog_spec renames SEMICOLON
    (469) generic_formal_part -> . GENERIC
    (470) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    BEGIN           reduce using rule 135 (decl_part -> .)
    PACKAGE         shift and go to state 80
    TASK            shift and go to state 74
    PROTECTED       shift and go to state 58
    error           shift and go to state 85
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 87
    SUBTYPE         shift and go to state 91
    FOR             shift and go to state 70
    PROCEDURE       shift and go to state 30
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 79

    decl                           shift and go to state 57
    subprog_body                   shift and go to state 66
    task_decl                      shift and go to state 67
    type_decl                      shift and go to state 63
    rep_spec                       shift and go to state 89
    task_body                      shift and go to state 90
    subtype_decl                   shift and go to state 68
    exception_decl                 shift and go to state 92
    address_spec                   shift and go to state 59
    decl_item                      shift and go to state 60
    subprog_spec_is_push           shift and go to state 93
    decl_part                      shift and go to state 599
    prot_decl                      shift and go to state 62
    record_type_spec               shift and go to state 75
    generic_decl                   shift and go to state 76
    def_id                         shift and go to state 96
    attrib_def                     shift and go to state 77
    subprog_spec                   shift and go to state 94
    def_id_s                       shift and go to state 95
    decl_item_or_body_s1           shift and go to state 78
    task_spec                      shift and go to state 72
    body                           shift and go to state 69
    object_decl                    shift and go to state 71
    body_stub                      shift and go to state 81
    pkg_spec                       shift and go to state 37
    rename_decl                    shift and go to state 97
    generic_subp_inst              shift and go to state 28
    pragma                         shift and go to state 82
    rename_unit                    shift and go to state 98
    subprog_decl                   shift and go to state 65
    pkg_decl                       shift and go to state 64
    prot_spec                      shift and go to state 83
    generic_formal_part            shift and go to state 33
    prot_body                      shift and go to state 99
    use_clause                     shift and go to state 73
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 84
    decl_item_or_body              shift and go to state 86
    number_decl                    shift and go to state 100

state 770

    (340) pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt . SEMICOLON

    SEMICOLON       shift and go to state 844


state 771

    (387) prot_op_body -> subprog_spec SEMICOLON .

    PRAGMA          reduce using rule 387 (prot_op_body -> subprog_spec SEMICOLON .)
    END             reduce using rule 387 (prot_op_body -> subprog_spec SEMICOLON .)
    ENTRY           reduce using rule 387 (prot_op_body -> subprog_spec SEMICOLON .)
    PROCEDURE       reduce using rule 387 (prot_op_body -> subprog_spec SEMICOLON .)
    FUNCTION        reduce using rule 387 (prot_op_body -> subprog_spec SEMICOLON .)


state 772

    (382) prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt . SEMICOLON

    SEMICOLON       shift and go to state 845


state 773

    (384) prot_op_body_s -> prot_op_body_s prot_op_body pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON

    END             reduce using rule 384 (prot_op_body_s -> prot_op_body_s prot_op_body pragma_s .)
    ENTRY           reduce using rule 384 (prot_op_body_s -> prot_op_body_s prot_op_body pragma_s .)
    PROCEDURE       reduce using rule 384 (prot_op_body_s -> prot_op_body_s prot_op_body pragma_s .)
    FUNCTION        reduce using rule 384 (prot_op_body_s -> prot_op_body_s prot_op_body pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 774

    (392) entry_body -> ENTRY IDENTIFIER . formal_part_opt WHEN condition entry_body_part
    (393) entry_body -> ENTRY IDENTIFIER . LPAREN iter_part discrete_range RPAREN formal_part_opt WHEN condition entry_body_part
    (318) formal_part_opt -> .
    (319) formal_part_opt -> . formal_part
    (320) formal_part -> . LPAREN param_s RPAREN

    LPAREN          shift and go to state 847
    WHEN            reduce using rule 318 (formal_part_opt -> .)

    formal_part                    shift and go to state 162
    formal_part_opt                shift and go to state 846

state 775

    (108) comp_decl -> def_id_s . COLON component_subtype_def init_opt SEMICOLON
    (25) def_id_s -> def_id_s . COMMA def_id

    COLON           shift and go to state 848
    COMMA           shift and go to state 186


state 776

    (381) prot_elem_decl -> comp_decl .

    error           reduce using rule 381 (prot_elem_decl -> comp_decl .)
    ENTRY           reduce using rule 381 (prot_elem_decl -> comp_decl .)
    PROCEDURE       reduce using rule 381 (prot_elem_decl -> comp_decl .)
    FUNCTION        reduce using rule 381 (prot_elem_decl -> comp_decl .)
    PRAGMA          reduce using rule 381 (prot_elem_decl -> comp_decl .)
    FOR             reduce using rule 381 (prot_elem_decl -> comp_decl .)
    IDENTIFIER      reduce using rule 381 (prot_elem_decl -> comp_decl .)
    END             reduce using rule 381 (prot_elem_decl -> comp_decl .)


state 777

    (380) prot_elem_decl -> prot_op_decl .

    error           reduce using rule 380 (prot_elem_decl -> prot_op_decl .)
    ENTRY           reduce using rule 380 (prot_elem_decl -> prot_op_decl .)
    PROCEDURE       reduce using rule 380 (prot_elem_decl -> prot_op_decl .)
    FUNCTION        reduce using rule 380 (prot_elem_decl -> prot_op_decl .)
    PRAGMA          reduce using rule 380 (prot_elem_decl -> prot_op_decl .)
    FOR             reduce using rule 380 (prot_elem_decl -> prot_op_decl .)
    IDENTIFIER      reduce using rule 380 (prot_elem_decl -> prot_op_decl .)
    END             reduce using rule 380 (prot_elem_decl -> prot_op_decl .)


state 778

    (379) prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .

    error           reduce using rule 379 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
    ENTRY           reduce using rule 379 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
    PROCEDURE       reduce using rule 379 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
    FUNCTION        reduce using rule 379 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
    PRAGMA          reduce using rule 379 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
    FOR             reduce using rule 379 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
    IDENTIFIER      reduce using rule 379 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)
    END             reduce using rule 379 (prot_elem_decl_s -> prot_elem_decl_s prot_elem_decl .)


state 779

    (109) comp_decl -> error . SEMICOLON

    SEMICOLON       shift and go to state 849


state 780

    (369) prot_def -> IS prot_op_decl_s prot_private_opt END id_opt .

    SEMICOLON       reduce using rule 369 (prot_def -> IS prot_op_decl_s prot_private_opt END id_opt .)


state 781

    (391) entry_decl -> ENTRY IDENTIFIER LPAREN . discrete_range RPAREN formal_part_opt SEMICOLON
    (320) formal_part -> LPAREN . param_s RPAREN
    (91) discrete_range -> . name range_constr_opt
    (92) discrete_range -> . range
    (321) param_s -> . param
    (322) param_s -> . param_s SEMICOLON param
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (60) range -> . simple_expression DOUBLEDOT simple_expression
    (61) range -> . name TICK RANGE
    (62) range -> . name TICK RANGE LPAREN expression RPAREN
    (323) param -> . def_id_s COLON mode mark init_opt
    (324) param -> . error
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s COMMA def_id
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (26) def_id -> . IDENTIFIER
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN

    error           shift and go to state 108
    IDENTIFIER      shift and go to state 850
    STRING          shift and go to state 137
    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    param                          shift and go to state 266
    simple_expression              shift and go to state 356
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    param_s                        shift and go to state 267
    literal                        shift and go to state 135
    def_id_s                       shift and go to state 104
    factor                         shift and go to state 136
    def_id                         shift and go to state 96
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    discrete_range                 shift and go to state 851
    aggregate                      shift and go to state 126
    term                           shift and go to state 144
    name                           shift and go to state 684
    operator_symbol                shift and go to state 146
    range                          shift and go to state 685

state 782

    (390) entry_decl -> ENTRY IDENTIFIER formal_part_opt . SEMICOLON

    SEMICOLON       shift and go to state 852


state 783

    (91) discrete_range -> name range_constr_opt .

    LOOP            reduce using rule 91 (discrete_range -> name range_constr_opt .)
    RPAREN          reduce using rule 91 (discrete_range -> name range_constr_opt .)
    COMMA           reduce using rule 91 (discrete_range -> name range_constr_opt .)


state 784

    (94) range_constr_opt -> range_constraint .

    LOOP            reduce using rule 94 (range_constr_opt -> range_constraint .)
    RPAREN          reduce using rule 94 (range_constr_opt -> range_constraint .)
    COMMA           reduce using rule 94 (range_constr_opt -> range_constraint .)
    SEMICOLON       reduce using rule 94 (range_constr_opt -> range_constraint .)
    RENAMES         reduce using rule 94 (range_constr_opt -> range_constraint .)
    IS_ASSIGNED     reduce using rule 94 (range_constr_opt -> range_constraint .)
    WITH            reduce using rule 94 (range_constr_opt -> range_constraint .)


state 785

    (283) loop_stmt -> label_opt iteration basic_loop id_opt SEMICOLON .

    END             reduce using rule 283 (loop_stmt -> label_opt iteration basic_loop id_opt SEMICOLON .)
    LLB             reduce using rule 283 (loop_stmt -> label_opt iteration basic_loop id_opt SEMICOLON .)
    error           reduce using rule 283 (loop_stmt -> label_opt iteration basic_loop id_opt SEMICOLON .)
    PRAGMA          reduce using rule 283 (loop_stmt -> label_opt iteration basic_loop id_opt SEMICOLON .)
    NULL            reduce using rule 283 (loop_stmt -> label_opt iteration basic_loop id_opt SEMICOLON .)
    EXIT            reduce using rule 283 (loop_stmt -> label_opt iteration basic_loop id_opt SEMICOLON .)
    RETURN          reduce using rule 283 (loop_stmt -> label_opt iteration basic_loop id_opt SEMICOLON .)
    GOTO            reduce using rule 283 (loop_stmt -> label_opt iteration basic_loop id_opt SEMICOLON .)
    DELAY           reduce using rule 283 (loop_stmt -> label_opt iteration basic_loop id_opt SEMICOLON .)
    ABORT           reduce using rule 283 (loop_stmt -> label_opt iteration basic_loop id_opt SEMICOLON .)
    RAISE           reduce using rule 283 (loop_stmt -> label_opt iteration basic_loop id_opt SEMICOLON .)
    REQUEUE         reduce using rule 283 (loop_stmt -> label_opt iteration basic_loop id_opt SEMICOLON .)
    IF              reduce using rule 283 (loop_stmt -> label_opt iteration basic_loop id_opt SEMICOLON .)
    CASE            reduce using rule 283 (loop_stmt -> label_opt iteration basic_loop id_opt SEMICOLON .)
    IDENTIFIER      reduce using rule 283 (loop_stmt -> label_opt iteration basic_loop id_opt SEMICOLON .)
    ACCEPT          reduce using rule 283 (loop_stmt -> label_opt iteration basic_loop id_opt SEMICOLON .)
    SELECT          reduce using rule 283 (loop_stmt -> label_opt iteration basic_loop id_opt SEMICOLON .)
    STRING          reduce using rule 283 (loop_stmt -> label_opt iteration basic_loop id_opt SEMICOLON .)
    WHILE           reduce using rule 283 (loop_stmt -> label_opt iteration basic_loop id_opt SEMICOLON .)
    DECLARE         reduce using rule 283 (loop_stmt -> label_opt iteration basic_loop id_opt SEMICOLON .)
    FOR             reduce using rule 283 (loop_stmt -> label_opt iteration basic_loop id_opt SEMICOLON .)
    LOOP            reduce using rule 283 (loop_stmt -> label_opt iteration basic_loop id_opt SEMICOLON .)
    BEGIN           reduce using rule 283 (loop_stmt -> label_opt iteration basic_loop id_opt SEMICOLON .)
    THEN            reduce using rule 283 (loop_stmt -> label_opt iteration basic_loop id_opt SEMICOLON .)
    OR              reduce using rule 283 (loop_stmt -> label_opt iteration basic_loop id_opt SEMICOLON .)
    ELSE            reduce using rule 283 (loop_stmt -> label_opt iteration basic_loop id_opt SEMICOLON .)
    ELSIF           reduce using rule 283 (loop_stmt -> label_opt iteration basic_loop id_opt SEMICOLON .)
    WHEN            reduce using rule 283 (loop_stmt -> label_opt iteration basic_loop id_opt SEMICOLON .)
    EXCEPTION       reduce using rule 283 (loop_stmt -> label_opt iteration basic_loop id_opt SEMICOLON .)


state 786

    (292) basic_loop -> LOOP statement_s END . LOOP

    LOOP            shift and go to state 853


state 787

    (295) block -> label_opt block_decl block_body END id_opt . SEMICOLON

    SEMICOLON       shift and go to state 854


state 788

    (403) entry_name -> entry_name LPAREN expression RPAREN .

    LPAREN          reduce using rule 403 (entry_name -> entry_name LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 403 (entry_name -> entry_name LPAREN expression RPAREN .)
    DO              reduce using rule 403 (entry_name -> entry_name LPAREN expression RPAREN .)


state 789

    (422) cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s . END SELECT SEMICOLON
    (244) statement_s -> statement_s . statement
    (245) statement -> . unlabeled
    (246) statement -> . label statement
    (247) unlabeled -> . simple_stmt
    (248) unlabeled -> . compound_stmt
    (249) unlabeled -> . pragma
    (268) label -> . LLB IDENTIFIER RLB
    (250) simple_stmt -> . NULL_stmt
    (251) simple_stmt -> . assign_stmt
    (252) simple_stmt -> . exit_stmt
    (253) simple_stmt -> . return_stmt
    (254) simple_stmt -> . goto_stmt
    (255) simple_stmt -> . procedure_call
    (256) simple_stmt -> . delay_stmt
    (257) simple_stmt -> . abort_stmt
    (258) simple_stmt -> . raise_stmt
    (259) simple_stmt -> . code_stmt
    (260) simple_stmt -> . requeue_stmt
    (261) simple_stmt -> . error SEMICOLON
    (262) compound_stmt -> . if_stmt
    (263) compound_stmt -> . case_stmt
    (264) compound_stmt -> . loop_stmt
    (265) compound_stmt -> . block
    (266) compound_stmt -> . accept_stmt
    (267) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (269) NULL_stmt -> . NULL SEMICOLON
    (270) assign_stmt -> . name IS_ASSIGNED expression SEMICOLON
    (302) exit_stmt -> . EXIT name_opt when_opt SEMICOLON
    (307) return_stmt -> . RETURN SEMICOLON
    (308) return_stmt -> . RETURN expression SEMICOLON
    (309) goto_stmt -> . GOTO name SEMICOLON
    (332) procedure_call -> . name SEMICOLON
    (404) delay_stmt -> . DELAY expression SEMICOLON
    (405) delay_stmt -> . DELAY UNTIL expression SEMICOLON
    (425) abort_stmt -> . ABORT name_s SEMICOLON
    (464) raise_stmt -> . RAISE name_opt SEMICOLON
    (510) code_stmt -> . qualified SEMICOLON
    (465) requeue_stmt -> . REQUEUE name SEMICOLON
    (466) requeue_stmt -> . REQUEUE name WITH ABORT SEMICOLON
    (271) if_stmt -> . IF cond_clause else_opt END IF SEMICOLON
    (278) case_stmt -> . case_hdr alternative_s END CASE SEMICOLON
    (283) loop_stmt -> . label_opt iteration basic_loop id_opt SEMICOLON
    (295) block -> . label_opt block_decl block_body END id_opt SEMICOLON
    (399) accept_stmt -> . accept_hdr SEMICOLON
    (400) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt SEMICOLON
    (406) select_stmt -> . select_wait
    (407) select_stmt -> . async_select
    (408) select_stmt -> . timed_entry_call
    (409) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (240) qualified -> . name TICK parenthesized_primary
    (279) case_hdr -> . CASE expression IS
    (284) label_opt -> .
    (285) label_opt -> . IDENTIFIER COLON
    (401) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (410) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON
    (420) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON
    (421) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON
    (422) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    END             shift and go to state 855
    LLB             shift and go to state 289
    error           shift and go to state 309
    PRAGMA          shift and go to state 4
    NULL            shift and go to state 311
    EXIT            shift and go to state 308
    RETURN          shift and go to state 295
    GOTO            shift and go to state 276
    DELAY           shift and go to state 272
    ABORT           shift and go to state 282
    RAISE           shift and go to state 306
    REQUEUE         shift and go to state 298
    IF              shift and go to state 317
    CASE            shift and go to state 297
    WHILE           reduce using rule 284 (label_opt -> .)
    DECLARE         reduce using rule 284 (label_opt -> .)
    FOR             reduce using rule 284 (label_opt -> .)
    LOOP            reduce using rule 284 (label_opt -> .)
    BEGIN           reduce using rule 284 (label_opt -> .)
    IDENTIFIER      shift and go to state 300
    ACCEPT          shift and go to state 284
    SELECT          shift and go to state 286
    STRING          shift and go to state 137

    indexed_comp                   shift and go to state 119
    accept_stmt                    shift and go to state 283
    label_opt                      shift and go to state 275
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 316
    abort_stmt                     shift and go to state 310
    return_stmt                    shift and go to state 294
    procedure_call                 shift and go to state 285
    assign_stmt                    shift and go to state 320
    simple_name                    shift and go to state 153
    code_stmt                      shift and go to state 313
    case_stmt                      shift and go to state 287
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 146
    label                          shift and go to state 288
    exit_stmt                      shift and go to state 315
    select_stmt                    shift and go to state 274
    statement                      shift and go to state 465
    compound_stmt                  shift and go to state 290
    case_hdr                       shift and go to state 292
    delay_stmt                     shift and go to state 301
    unlabeled                      shift and go to state 314
    simple_stmt                    shift and go to state 277
    loop_stmt                      shift and go to state 278
    qualified                      shift and go to state 279
    pragma                         shift and go to state 303
    async_select                   shift and go to state 273
    requeue_stmt                   shift and go to state 304
    raise_stmt                     shift and go to state 305
    name                           shift and go to state 281
    if_stmt                        shift and go to state 280
    accept_hdr                     shift and go to state 302
    cond_entry_call                shift and go to state 318
    timed_entry_call               shift and go to state 307
    goto_stmt                      shift and go to state 291
    NULL_stmt                      shift and go to state 319
    block                          shift and go to state 293

state 790

    (421) timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt . stmts_opt END SELECT SEMICOLON
    (423) stmts_opt -> .
    (424) stmts_opt -> . statement_s
    (243) statement_s -> . statement
    (244) statement_s -> . statement_s statement
    (245) statement -> . unlabeled
    (246) statement -> . label statement
    (247) unlabeled -> . simple_stmt
    (248) unlabeled -> . compound_stmt
    (249) unlabeled -> . pragma
    (268) label -> . LLB IDENTIFIER RLB
    (250) simple_stmt -> . NULL_stmt
    (251) simple_stmt -> . assign_stmt
    (252) simple_stmt -> . exit_stmt
    (253) simple_stmt -> . return_stmt
    (254) simple_stmt -> . goto_stmt
    (255) simple_stmt -> . procedure_call
    (256) simple_stmt -> . delay_stmt
    (257) simple_stmt -> . abort_stmt
    (258) simple_stmt -> . raise_stmt
    (259) simple_stmt -> . code_stmt
    (260) simple_stmt -> . requeue_stmt
    (261) simple_stmt -> . error SEMICOLON
    (262) compound_stmt -> . if_stmt
    (263) compound_stmt -> . case_stmt
    (264) compound_stmt -> . loop_stmt
    (265) compound_stmt -> . block
    (266) compound_stmt -> . accept_stmt
    (267) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (269) NULL_stmt -> . NULL SEMICOLON
    (270) assign_stmt -> . name IS_ASSIGNED expression SEMICOLON
    (302) exit_stmt -> . EXIT name_opt when_opt SEMICOLON
    (307) return_stmt -> . RETURN SEMICOLON
    (308) return_stmt -> . RETURN expression SEMICOLON
    (309) goto_stmt -> . GOTO name SEMICOLON
    (332) procedure_call -> . name SEMICOLON
    (404) delay_stmt -> . DELAY expression SEMICOLON
    (405) delay_stmt -> . DELAY UNTIL expression SEMICOLON
    (425) abort_stmt -> . ABORT name_s SEMICOLON
    (464) raise_stmt -> . RAISE name_opt SEMICOLON
    (510) code_stmt -> . qualified SEMICOLON
    (465) requeue_stmt -> . REQUEUE name SEMICOLON
    (466) requeue_stmt -> . REQUEUE name WITH ABORT SEMICOLON
    (271) if_stmt -> . IF cond_clause else_opt END IF SEMICOLON
    (278) case_stmt -> . case_hdr alternative_s END CASE SEMICOLON
    (283) loop_stmt -> . label_opt iteration basic_loop id_opt SEMICOLON
    (295) block -> . label_opt block_decl block_body END id_opt SEMICOLON
    (399) accept_stmt -> . accept_hdr SEMICOLON
    (400) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt SEMICOLON
    (406) select_stmt -> . select_wait
    (407) select_stmt -> . async_select
    (408) select_stmt -> . timed_entry_call
    (409) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (240) qualified -> . name TICK parenthesized_primary
    (279) case_hdr -> . CASE expression IS
    (284) label_opt -> .
    (285) label_opt -> . IDENTIFIER COLON
    (401) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (410) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON
    (420) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON
    (421) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON
    (422) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    END             reduce using rule 423 (stmts_opt -> .)
    LLB             shift and go to state 289
    error           shift and go to state 309
    PRAGMA          shift and go to state 4
    NULL            shift and go to state 311
    EXIT            shift and go to state 308
    RETURN          shift and go to state 295
    GOTO            shift and go to state 276
    DELAY           shift and go to state 272
    ABORT           shift and go to state 282
    RAISE           shift and go to state 306
    REQUEUE         shift and go to state 298
    IF              shift and go to state 317
    CASE            shift and go to state 297
    WHILE           reduce using rule 284 (label_opt -> .)
    DECLARE         reduce using rule 284 (label_opt -> .)
    FOR             reduce using rule 284 (label_opt -> .)
    LOOP            reduce using rule 284 (label_opt -> .)
    BEGIN           reduce using rule 284 (label_opt -> .)
    IDENTIFIER      shift and go to state 300
    ACCEPT          shift and go to state 284
    SELECT          shift and go to state 286
    STRING          shift and go to state 137

    indexed_comp                   shift and go to state 119
    accept_stmt                    shift and go to state 283
    label_opt                      shift and go to state 275
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 316
    abort_stmt                     shift and go to state 310
    return_stmt                    shift and go to state 294
    procedure_call                 shift and go to state 285
    assign_stmt                    shift and go to state 320
    statement_s                    shift and go to state 566
    simple_name                    shift and go to state 153
    code_stmt                      shift and go to state 313
    case_stmt                      shift and go to state 287
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 146
    label                          shift and go to state 288
    exit_stmt                      shift and go to state 315
    select_stmt                    shift and go to state 274
    statement                      shift and go to state 299
    compound_stmt                  shift and go to state 290
    case_hdr                       shift and go to state 292
    delay_stmt                     shift and go to state 301
    unlabeled                      shift and go to state 314
    simple_stmt                    shift and go to state 277
    loop_stmt                      shift and go to state 278
    qualified                      shift and go to state 279
    pragma                         shift and go to state 303
    async_select                   shift and go to state 273
    requeue_stmt                   shift and go to state 304
    raise_stmt                     shift and go to state 305
    name                           shift and go to state 281
    if_stmt                        shift and go to state 280
    accept_hdr                     shift and go to state 302
    cond_entry_call                shift and go to state 318
    timed_entry_call               shift and go to state 307
    stmts_opt                      shift and go to state 856
    goto_stmt                      shift and go to state 291
    NULL_stmt                      shift and go to state 319
    block                          shift and go to state 293

state 791

    (420) async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s . END SELECT SEMICOLON
    (244) statement_s -> statement_s . statement
    (245) statement -> . unlabeled
    (246) statement -> . label statement
    (247) unlabeled -> . simple_stmt
    (248) unlabeled -> . compound_stmt
    (249) unlabeled -> . pragma
    (268) label -> . LLB IDENTIFIER RLB
    (250) simple_stmt -> . NULL_stmt
    (251) simple_stmt -> . assign_stmt
    (252) simple_stmt -> . exit_stmt
    (253) simple_stmt -> . return_stmt
    (254) simple_stmt -> . goto_stmt
    (255) simple_stmt -> . procedure_call
    (256) simple_stmt -> . delay_stmt
    (257) simple_stmt -> . abort_stmt
    (258) simple_stmt -> . raise_stmt
    (259) simple_stmt -> . code_stmt
    (260) simple_stmt -> . requeue_stmt
    (261) simple_stmt -> . error SEMICOLON
    (262) compound_stmt -> . if_stmt
    (263) compound_stmt -> . case_stmt
    (264) compound_stmt -> . loop_stmt
    (265) compound_stmt -> . block
    (266) compound_stmt -> . accept_stmt
    (267) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (269) NULL_stmt -> . NULL SEMICOLON
    (270) assign_stmt -> . name IS_ASSIGNED expression SEMICOLON
    (302) exit_stmt -> . EXIT name_opt when_opt SEMICOLON
    (307) return_stmt -> . RETURN SEMICOLON
    (308) return_stmt -> . RETURN expression SEMICOLON
    (309) goto_stmt -> . GOTO name SEMICOLON
    (332) procedure_call -> . name SEMICOLON
    (404) delay_stmt -> . DELAY expression SEMICOLON
    (405) delay_stmt -> . DELAY UNTIL expression SEMICOLON
    (425) abort_stmt -> . ABORT name_s SEMICOLON
    (464) raise_stmt -> . RAISE name_opt SEMICOLON
    (510) code_stmt -> . qualified SEMICOLON
    (465) requeue_stmt -> . REQUEUE name SEMICOLON
    (466) requeue_stmt -> . REQUEUE name WITH ABORT SEMICOLON
    (271) if_stmt -> . IF cond_clause else_opt END IF SEMICOLON
    (278) case_stmt -> . case_hdr alternative_s END CASE SEMICOLON
    (283) loop_stmt -> . label_opt iteration basic_loop id_opt SEMICOLON
    (295) block -> . label_opt block_decl block_body END id_opt SEMICOLON
    (399) accept_stmt -> . accept_hdr SEMICOLON
    (400) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt SEMICOLON
    (406) select_stmt -> . select_wait
    (407) select_stmt -> . async_select
    (408) select_stmt -> . timed_entry_call
    (409) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (240) qualified -> . name TICK parenthesized_primary
    (279) case_hdr -> . CASE expression IS
    (284) label_opt -> .
    (285) label_opt -> . IDENTIFIER COLON
    (401) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (410) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON
    (420) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON
    (421) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON
    (422) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    END             shift and go to state 857
    LLB             shift and go to state 289
    error           shift and go to state 309
    PRAGMA          shift and go to state 4
    NULL            shift and go to state 311
    EXIT            shift and go to state 308
    RETURN          shift and go to state 295
    GOTO            shift and go to state 276
    DELAY           shift and go to state 272
    ABORT           shift and go to state 282
    RAISE           shift and go to state 306
    REQUEUE         shift and go to state 298
    IF              shift and go to state 317
    CASE            shift and go to state 297
    WHILE           reduce using rule 284 (label_opt -> .)
    DECLARE         reduce using rule 284 (label_opt -> .)
    FOR             reduce using rule 284 (label_opt -> .)
    LOOP            reduce using rule 284 (label_opt -> .)
    BEGIN           reduce using rule 284 (label_opt -> .)
    IDENTIFIER      shift and go to state 300
    ACCEPT          shift and go to state 284
    SELECT          shift and go to state 286
    STRING          shift and go to state 137

    indexed_comp                   shift and go to state 119
    accept_stmt                    shift and go to state 283
    label_opt                      shift and go to state 275
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 316
    abort_stmt                     shift and go to state 310
    return_stmt                    shift and go to state 294
    assign_stmt                    shift and go to state 320
    simple_name                    shift and go to state 153
    code_stmt                      shift and go to state 313
    case_stmt                      shift and go to state 287
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 146
    label                          shift and go to state 288
    exit_stmt                      shift and go to state 315
    select_stmt                    shift and go to state 274
    statement                      shift and go to state 465
    compound_stmt                  shift and go to state 290
    case_hdr                       shift and go to state 292
    delay_stmt                     shift and go to state 301
    unlabeled                      shift and go to state 314
    simple_stmt                    shift and go to state 277
    loop_stmt                      shift and go to state 278
    qualified                      shift and go to state 279
    pragma                         shift and go to state 303
    async_select                   shift and go to state 273
    requeue_stmt                   shift and go to state 304
    raise_stmt                     shift and go to state 305
    name                           shift and go to state 281
    if_stmt                        shift and go to state 280
    accept_hdr                     shift and go to state 302
    cond_entry_call                shift and go to state 318
    timed_entry_call               shift and go to state 307
    goto_stmt                      shift and go to state 291
    NULL_stmt                      shift and go to state 319
    procedure_call                 shift and go to state 285
    block                          shift and go to state 293

state 792

    (416) select_alt -> delay_stmt . stmts_opt
    (423) stmts_opt -> .
    (424) stmts_opt -> . statement_s
    (243) statement_s -> . statement
    (244) statement_s -> . statement_s statement
    (245) statement -> . unlabeled
    (246) statement -> . label statement
    (247) unlabeled -> . simple_stmt
    (248) unlabeled -> . compound_stmt
    (249) unlabeled -> . pragma
    (268) label -> . LLB IDENTIFIER RLB
    (250) simple_stmt -> . NULL_stmt
    (251) simple_stmt -> . assign_stmt
    (252) simple_stmt -> . exit_stmt
    (253) simple_stmt -> . return_stmt
    (254) simple_stmt -> . goto_stmt
    (255) simple_stmt -> . procedure_call
    (256) simple_stmt -> . delay_stmt
    (257) simple_stmt -> . abort_stmt
    (258) simple_stmt -> . raise_stmt
    (259) simple_stmt -> . code_stmt
    (260) simple_stmt -> . requeue_stmt
    (261) simple_stmt -> . error SEMICOLON
    (262) compound_stmt -> . if_stmt
    (263) compound_stmt -> . case_stmt
    (264) compound_stmt -> . loop_stmt
    (265) compound_stmt -> . block
    (266) compound_stmt -> . accept_stmt
    (267) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (269) NULL_stmt -> . NULL SEMICOLON
    (270) assign_stmt -> . name IS_ASSIGNED expression SEMICOLON
    (302) exit_stmt -> . EXIT name_opt when_opt SEMICOLON
    (307) return_stmt -> . RETURN SEMICOLON
    (308) return_stmt -> . RETURN expression SEMICOLON
    (309) goto_stmt -> . GOTO name SEMICOLON
    (332) procedure_call -> . name SEMICOLON
    (404) delay_stmt -> . DELAY expression SEMICOLON
    (405) delay_stmt -> . DELAY UNTIL expression SEMICOLON
    (425) abort_stmt -> . ABORT name_s SEMICOLON
    (464) raise_stmt -> . RAISE name_opt SEMICOLON
    (510) code_stmt -> . qualified SEMICOLON
    (465) requeue_stmt -> . REQUEUE name SEMICOLON
    (466) requeue_stmt -> . REQUEUE name WITH ABORT SEMICOLON
    (271) if_stmt -> . IF cond_clause else_opt END IF SEMICOLON
    (278) case_stmt -> . case_hdr alternative_s END CASE SEMICOLON
    (283) loop_stmt -> . label_opt iteration basic_loop id_opt SEMICOLON
    (295) block -> . label_opt block_decl block_body END id_opt SEMICOLON
    (399) accept_stmt -> . accept_hdr SEMICOLON
    (400) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt SEMICOLON
    (406) select_stmt -> . select_wait
    (407) select_stmt -> . async_select
    (408) select_stmt -> . timed_entry_call
    (409) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (240) qualified -> . name TICK parenthesized_primary
    (279) case_hdr -> . CASE expression IS
    (284) label_opt -> .
    (285) label_opt -> . IDENTIFIER COLON
    (401) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (410) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON
    (420) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON
    (421) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON
    (422) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    OR              reduce using rule 423 (stmts_opt -> .)
    ELSE            reduce using rule 423 (stmts_opt -> .)
    ELSIF           reduce using rule 423 (stmts_opt -> .)
    END             reduce using rule 423 (stmts_opt -> .)
    LLB             shift and go to state 289
    error           shift and go to state 309
    PRAGMA          shift and go to state 4
    NULL            shift and go to state 311
    EXIT            shift and go to state 308
    RETURN          shift and go to state 295
    GOTO            shift and go to state 276
    DELAY           shift and go to state 272
    ABORT           shift and go to state 282
    RAISE           shift and go to state 306
    REQUEUE         shift and go to state 298
    IF              shift and go to state 317
    CASE            shift and go to state 297
    WHILE           reduce using rule 284 (label_opt -> .)
    DECLARE         reduce using rule 284 (label_opt -> .)
    FOR             reduce using rule 284 (label_opt -> .)
    LOOP            reduce using rule 284 (label_opt -> .)
    BEGIN           reduce using rule 284 (label_opt -> .)
    IDENTIFIER      shift and go to state 300
    ACCEPT          shift and go to state 284
    SELECT          shift and go to state 286
    STRING          shift and go to state 137

    indexed_comp                   shift and go to state 119
    accept_stmt                    shift and go to state 283
    label_opt                      shift and go to state 275
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 316
    abort_stmt                     shift and go to state 310
    return_stmt                    shift and go to state 294
    procedure_call                 shift and go to state 285
    assign_stmt                    shift and go to state 320
    statement_s                    shift and go to state 566
    simple_name                    shift and go to state 153
    code_stmt                      shift and go to state 313
    case_stmt                      shift and go to state 287
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 146
    label                          shift and go to state 288
    exit_stmt                      shift and go to state 315
    select_stmt                    shift and go to state 274
    statement                      shift and go to state 299
    compound_stmt                  shift and go to state 290
    case_hdr                       shift and go to state 292
    delay_stmt                     shift and go to state 301
    unlabeled                      shift and go to state 314
    simple_stmt                    shift and go to state 277
    loop_stmt                      shift and go to state 278
    qualified                      shift and go to state 279
    pragma                         shift and go to state 303
    async_select                   shift and go to state 273
    requeue_stmt                   shift and go to state 304
    raise_stmt                     shift and go to state 305
    name                           shift and go to state 281
    if_stmt                        shift and go to state 280
    accept_hdr                     shift and go to state 302
    cond_entry_call                shift and go to state 318
    timed_entry_call               shift and go to state 307
    stmts_opt                      shift and go to state 858
    goto_stmt                      shift and go to state 291
    NULL_stmt                      shift and go to state 319
    block                          shift and go to state 293

state 793

    (412) guarded_select_alt -> WHEN condition ARROW select_alt .

    OR              reduce using rule 412 (guarded_select_alt -> WHEN condition ARROW select_alt .)
    ELSE            reduce using rule 412 (guarded_select_alt -> WHEN condition ARROW select_alt .)
    ELSIF           reduce using rule 412 (guarded_select_alt -> WHEN condition ARROW select_alt .)
    END             reduce using rule 412 (guarded_select_alt -> WHEN condition ARROW select_alt .)


state 794

    (410) select_wait -> SELECT guarded_select_alt or_select else_opt END . SELECT SEMICOLON

    SELECT          shift and go to state 859


state 795

    (414) or_select -> or_select OR guarded_select_alt .

    OR              reduce using rule 414 (or_select -> or_select OR guarded_select_alt .)
    ELSE            reduce using rule 414 (or_select -> or_select OR guarded_select_alt .)
    ELSIF           reduce using rule 414 (or_select -> or_select OR guarded_select_alt .)
    END             reduce using rule 414 (or_select -> or_select OR guarded_select_alt .)


state 796

    (278) case_stmt -> case_hdr alternative_s END CASE SEMICOLON .

    END             reduce using rule 278 (case_stmt -> case_hdr alternative_s END CASE SEMICOLON .)
    LLB             reduce using rule 278 (case_stmt -> case_hdr alternative_s END CASE SEMICOLON .)
    error           reduce using rule 278 (case_stmt -> case_hdr alternative_s END CASE SEMICOLON .)
    PRAGMA          reduce using rule 278 (case_stmt -> case_hdr alternative_s END CASE SEMICOLON .)
    NULL            reduce using rule 278 (case_stmt -> case_hdr alternative_s END CASE SEMICOLON .)
    EXIT            reduce using rule 278 (case_stmt -> case_hdr alternative_s END CASE SEMICOLON .)
    RETURN          reduce using rule 278 (case_stmt -> case_hdr alternative_s END CASE SEMICOLON .)
    GOTO            reduce using rule 278 (case_stmt -> case_hdr alternative_s END CASE SEMICOLON .)
    DELAY           reduce using rule 278 (case_stmt -> case_hdr alternative_s END CASE SEMICOLON .)
    ABORT           reduce using rule 278 (case_stmt -> case_hdr alternative_s END CASE SEMICOLON .)
    RAISE           reduce using rule 278 (case_stmt -> case_hdr alternative_s END CASE SEMICOLON .)
    REQUEUE         reduce using rule 278 (case_stmt -> case_hdr alternative_s END CASE SEMICOLON .)
    IF              reduce using rule 278 (case_stmt -> case_hdr alternative_s END CASE SEMICOLON .)
    CASE            reduce using rule 278 (case_stmt -> case_hdr alternative_s END CASE SEMICOLON .)
    IDENTIFIER      reduce using rule 278 (case_stmt -> case_hdr alternative_s END CASE SEMICOLON .)
    ACCEPT          reduce using rule 278 (case_stmt -> case_hdr alternative_s END CASE SEMICOLON .)
    SELECT          reduce using rule 278 (case_stmt -> case_hdr alternative_s END CASE SEMICOLON .)
    STRING          reduce using rule 278 (case_stmt -> case_hdr alternative_s END CASE SEMICOLON .)
    WHILE           reduce using rule 278 (case_stmt -> case_hdr alternative_s END CASE SEMICOLON .)
    DECLARE         reduce using rule 278 (case_stmt -> case_hdr alternative_s END CASE SEMICOLON .)
    FOR             reduce using rule 278 (case_stmt -> case_hdr alternative_s END CASE SEMICOLON .)
    LOOP            reduce using rule 278 (case_stmt -> case_hdr alternative_s END CASE SEMICOLON .)
    BEGIN           reduce using rule 278 (case_stmt -> case_hdr alternative_s END CASE SEMICOLON .)
    WHEN            reduce using rule 278 (case_stmt -> case_hdr alternative_s END CASE SEMICOLON .)
    OR              reduce using rule 278 (case_stmt -> case_hdr alternative_s END CASE SEMICOLON .)
    ELSE            reduce using rule 278 (case_stmt -> case_hdr alternative_s END CASE SEMICOLON .)
    ELSIF           reduce using rule 278 (case_stmt -> case_hdr alternative_s END CASE SEMICOLON .)
    THEN            reduce using rule 278 (case_stmt -> case_hdr alternative_s END CASE SEMICOLON .)
    EXCEPTION       reduce using rule 278 (case_stmt -> case_hdr alternative_s END CASE SEMICOLON .)


state 797

    (282) alternative -> WHEN choice_s ARROW . statement_s
    (243) statement_s -> . statement
    (244) statement_s -> . statement_s statement
    (245) statement -> . unlabeled
    (246) statement -> . label statement
    (247) unlabeled -> . simple_stmt
    (248) unlabeled -> . compound_stmt
    (249) unlabeled -> . pragma
    (268) label -> . LLB IDENTIFIER RLB
    (250) simple_stmt -> . NULL_stmt
    (251) simple_stmt -> . assign_stmt
    (252) simple_stmt -> . exit_stmt
    (253) simple_stmt -> . return_stmt
    (254) simple_stmt -> . goto_stmt
    (255) simple_stmt -> . procedure_call
    (256) simple_stmt -> . delay_stmt
    (257) simple_stmt -> . abort_stmt
    (258) simple_stmt -> . raise_stmt
    (259) simple_stmt -> . code_stmt
    (260) simple_stmt -> . requeue_stmt
    (261) simple_stmt -> . error SEMICOLON
    (262) compound_stmt -> . if_stmt
    (263) compound_stmt -> . case_stmt
    (264) compound_stmt -> . loop_stmt
    (265) compound_stmt -> . block
    (266) compound_stmt -> . accept_stmt
    (267) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (269) NULL_stmt -> . NULL SEMICOLON
    (270) assign_stmt -> . name IS_ASSIGNED expression SEMICOLON
    (302) exit_stmt -> . EXIT name_opt when_opt SEMICOLON
    (307) return_stmt -> . RETURN SEMICOLON
    (308) return_stmt -> . RETURN expression SEMICOLON
    (309) goto_stmt -> . GOTO name SEMICOLON
    (332) procedure_call -> . name SEMICOLON
    (404) delay_stmt -> . DELAY expression SEMICOLON
    (405) delay_stmt -> . DELAY UNTIL expression SEMICOLON
    (425) abort_stmt -> . ABORT name_s SEMICOLON
    (464) raise_stmt -> . RAISE name_opt SEMICOLON
    (510) code_stmt -> . qualified SEMICOLON
    (465) requeue_stmt -> . REQUEUE name SEMICOLON
    (466) requeue_stmt -> . REQUEUE name WITH ABORT SEMICOLON
    (271) if_stmt -> . IF cond_clause else_opt END IF SEMICOLON
    (278) case_stmt -> . case_hdr alternative_s END CASE SEMICOLON
    (283) loop_stmt -> . label_opt iteration basic_loop id_opt SEMICOLON
    (295) block -> . label_opt block_decl block_body END id_opt SEMICOLON
    (399) accept_stmt -> . accept_hdr SEMICOLON
    (400) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt SEMICOLON
    (406) select_stmt -> . select_wait
    (407) select_stmt -> . async_select
    (408) select_stmt -> . timed_entry_call
    (409) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (240) qualified -> . name TICK parenthesized_primary
    (279) case_hdr -> . CASE expression IS
    (284) label_opt -> .
    (285) label_opt -> . IDENTIFIER COLON
    (401) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (410) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON
    (420) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON
    (421) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON
    (422) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    LLB             shift and go to state 289
    error           shift and go to state 309
    PRAGMA          shift and go to state 4
    NULL            shift and go to state 311
    EXIT            shift and go to state 308
    RETURN          shift and go to state 295
    GOTO            shift and go to state 276
    DELAY           shift and go to state 272
    ABORT           shift and go to state 282
    RAISE           shift and go to state 306
    REQUEUE         shift and go to state 298
    IF              shift and go to state 317
    CASE            shift and go to state 297
    WHILE           reduce using rule 284 (label_opt -> .)
    DECLARE         reduce using rule 284 (label_opt -> .)
    FOR             reduce using rule 284 (label_opt -> .)
    LOOP            reduce using rule 284 (label_opt -> .)
    BEGIN           reduce using rule 284 (label_opt -> .)
    IDENTIFIER      shift and go to state 300
    ACCEPT          shift and go to state 284
    SELECT          shift and go to state 286
    STRING          shift and go to state 137

    indexed_comp                   shift and go to state 119
    accept_stmt                    shift and go to state 283
    label_opt                      shift and go to state 275
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 316
    abort_stmt                     shift and go to state 310
    return_stmt                    shift and go to state 294
    procedure_call                 shift and go to state 285
    assign_stmt                    shift and go to state 320
    statement_s                    shift and go to state 860
    simple_name                    shift and go to state 153
    code_stmt                      shift and go to state 313
    case_stmt                      shift and go to state 287
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 146
    label                          shift and go to state 288
    exit_stmt                      shift and go to state 315
    select_stmt                    shift and go to state 274
    statement                      shift and go to state 299
    compound_stmt                  shift and go to state 290
    case_hdr                       shift and go to state 292
    delay_stmt                     shift and go to state 301
    unlabeled                      shift and go to state 314
    simple_stmt                    shift and go to state 277
    loop_stmt                      shift and go to state 278
    qualified                      shift and go to state 279
    pragma                         shift and go to state 303
    async_select                   shift and go to state 273
    requeue_stmt                   shift and go to state 304
    raise_stmt                     shift and go to state 305
    name                           shift and go to state 281
    if_stmt                        shift and go to state 280
    accept_hdr                     shift and go to state 302
    cond_entry_call                shift and go to state 318
    timed_entry_call               shift and go to state 307
    goto_stmt                      shift and go to state 291
    NULL_stmt                      shift and go to state 319
    block                          shift and go to state 293

state 798

    (466) requeue_stmt -> REQUEUE name WITH ABORT SEMICOLON .

    LLB             reduce using rule 466 (requeue_stmt -> REQUEUE name WITH ABORT SEMICOLON .)
    error           reduce using rule 466 (requeue_stmt -> REQUEUE name WITH ABORT SEMICOLON .)
    PRAGMA          reduce using rule 466 (requeue_stmt -> REQUEUE name WITH ABORT SEMICOLON .)
    NULL            reduce using rule 466 (requeue_stmt -> REQUEUE name WITH ABORT SEMICOLON .)
    EXIT            reduce using rule 466 (requeue_stmt -> REQUEUE name WITH ABORT SEMICOLON .)
    RETURN          reduce using rule 466 (requeue_stmt -> REQUEUE name WITH ABORT SEMICOLON .)
    GOTO            reduce using rule 466 (requeue_stmt -> REQUEUE name WITH ABORT SEMICOLON .)
    DELAY           reduce using rule 466 (requeue_stmt -> REQUEUE name WITH ABORT SEMICOLON .)
    ABORT           reduce using rule 466 (requeue_stmt -> REQUEUE name WITH ABORT SEMICOLON .)
    RAISE           reduce using rule 466 (requeue_stmt -> REQUEUE name WITH ABORT SEMICOLON .)
    REQUEUE         reduce using rule 466 (requeue_stmt -> REQUEUE name WITH ABORT SEMICOLON .)
    IF              reduce using rule 466 (requeue_stmt -> REQUEUE name WITH ABORT SEMICOLON .)
    CASE            reduce using rule 466 (requeue_stmt -> REQUEUE name WITH ABORT SEMICOLON .)
    IDENTIFIER      reduce using rule 466 (requeue_stmt -> REQUEUE name WITH ABORT SEMICOLON .)
    ACCEPT          reduce using rule 466 (requeue_stmt -> REQUEUE name WITH ABORT SEMICOLON .)
    SELECT          reduce using rule 466 (requeue_stmt -> REQUEUE name WITH ABORT SEMICOLON .)
    STRING          reduce using rule 466 (requeue_stmt -> REQUEUE name WITH ABORT SEMICOLON .)
    WHILE           reduce using rule 466 (requeue_stmt -> REQUEUE name WITH ABORT SEMICOLON .)
    DECLARE         reduce using rule 466 (requeue_stmt -> REQUEUE name WITH ABORT SEMICOLON .)
    FOR             reduce using rule 466 (requeue_stmt -> REQUEUE name WITH ABORT SEMICOLON .)
    LOOP            reduce using rule 466 (requeue_stmt -> REQUEUE name WITH ABORT SEMICOLON .)
    BEGIN           reduce using rule 466 (requeue_stmt -> REQUEUE name WITH ABORT SEMICOLON .)
    ELSE            reduce using rule 466 (requeue_stmt -> REQUEUE name WITH ABORT SEMICOLON .)
    ELSIF           reduce using rule 466 (requeue_stmt -> REQUEUE name WITH ABORT SEMICOLON .)
    END             reduce using rule 466 (requeue_stmt -> REQUEUE name WITH ABORT SEMICOLON .)
    WHEN            reduce using rule 466 (requeue_stmt -> REQUEUE name WITH ABORT SEMICOLON .)
    EXCEPTION       reduce using rule 466 (requeue_stmt -> REQUEUE name WITH ABORT SEMICOLON .)
    OR              reduce using rule 466 (requeue_stmt -> REQUEUE name WITH ABORT SEMICOLON .)
    THEN            reduce using rule 466 (requeue_stmt -> REQUEUE name WITH ABORT SEMICOLON .)


state 799

    (400) accept_stmt -> accept_hdr DO handled_stmt_s END id_opt . SEMICOLON

    SEMICOLON       shift and go to state 861


state 800

    (459) exception_handler -> WHEN IDENTIFIER COLON . except_choice_s ARROW statement_s
    (460) except_choice_s -> . except_choice
    (461) except_choice_s -> . except_choice_s | except_choice
    (462) except_choice -> . name
    (463) except_choice -> . OTHERS
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    OTHERS          shift and go to state 707
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    name                           shift and go to state 708
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 146
    except_choice_s                shift and go to state 862
    except_choice                  shift and go to state 706
    indexed_comp                   shift and go to state 119
    simple_name                    shift and go to state 153

state 801

    (458) exception_handler -> WHEN except_choice_s ARROW . statement_s
    (243) statement_s -> . statement
    (244) statement_s -> . statement_s statement
    (245) statement -> . unlabeled
    (246) statement -> . label statement
    (247) unlabeled -> . simple_stmt
    (248) unlabeled -> . compound_stmt
    (249) unlabeled -> . pragma
    (268) label -> . LLB IDENTIFIER RLB
    (250) simple_stmt -> . NULL_stmt
    (251) simple_stmt -> . assign_stmt
    (252) simple_stmt -> . exit_stmt
    (253) simple_stmt -> . return_stmt
    (254) simple_stmt -> . goto_stmt
    (255) simple_stmt -> . procedure_call
    (256) simple_stmt -> . delay_stmt
    (257) simple_stmt -> . abort_stmt
    (258) simple_stmt -> . raise_stmt
    (259) simple_stmt -> . code_stmt
    (260) simple_stmt -> . requeue_stmt
    (261) simple_stmt -> . error SEMICOLON
    (262) compound_stmt -> . if_stmt
    (263) compound_stmt -> . case_stmt
    (264) compound_stmt -> . loop_stmt
    (265) compound_stmt -> . block
    (266) compound_stmt -> . accept_stmt
    (267) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (269) NULL_stmt -> . NULL SEMICOLON
    (270) assign_stmt -> . name IS_ASSIGNED expression SEMICOLON
    (302) exit_stmt -> . EXIT name_opt when_opt SEMICOLON
    (307) return_stmt -> . RETURN SEMICOLON
    (308) return_stmt -> . RETURN expression SEMICOLON
    (309) goto_stmt -> . GOTO name SEMICOLON
    (332) procedure_call -> . name SEMICOLON
    (404) delay_stmt -> . DELAY expression SEMICOLON
    (405) delay_stmt -> . DELAY UNTIL expression SEMICOLON
    (425) abort_stmt -> . ABORT name_s SEMICOLON
    (464) raise_stmt -> . RAISE name_opt SEMICOLON
    (510) code_stmt -> . qualified SEMICOLON
    (465) requeue_stmt -> . REQUEUE name SEMICOLON
    (466) requeue_stmt -> . REQUEUE name WITH ABORT SEMICOLON
    (271) if_stmt -> . IF cond_clause else_opt END IF SEMICOLON
    (278) case_stmt -> . case_hdr alternative_s END CASE SEMICOLON
    (283) loop_stmt -> . label_opt iteration basic_loop id_opt SEMICOLON
    (295) block -> . label_opt block_decl block_body END id_opt SEMICOLON
    (399) accept_stmt -> . accept_hdr SEMICOLON
    (400) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt SEMICOLON
    (406) select_stmt -> . select_wait
    (407) select_stmt -> . async_select
    (408) select_stmt -> . timed_entry_call
    (409) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (240) qualified -> . name TICK parenthesized_primary
    (279) case_hdr -> . CASE expression IS
    (284) label_opt -> .
    (285) label_opt -> . IDENTIFIER COLON
    (401) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (410) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON
    (420) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON
    (421) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON
    (422) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    LLB             shift and go to state 289
    error           shift and go to state 309
    PRAGMA          shift and go to state 4
    NULL            shift and go to state 311
    EXIT            shift and go to state 308
    RETURN          shift and go to state 295
    GOTO            shift and go to state 276
    DELAY           shift and go to state 272
    ABORT           shift and go to state 282
    RAISE           shift and go to state 306
    REQUEUE         shift and go to state 298
    IF              shift and go to state 317
    CASE            shift and go to state 297
    WHILE           reduce using rule 284 (label_opt -> .)
    DECLARE         reduce using rule 284 (label_opt -> .)
    FOR             reduce using rule 284 (label_opt -> .)
    LOOP            reduce using rule 284 (label_opt -> .)
    BEGIN           reduce using rule 284 (label_opt -> .)
    IDENTIFIER      shift and go to state 300
    ACCEPT          shift and go to state 284
    SELECT          shift and go to state 286
    STRING          shift and go to state 137

    indexed_comp                   shift and go to state 119
    accept_stmt                    shift and go to state 283
    label_opt                      shift and go to state 275
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 316
    abort_stmt                     shift and go to state 310
    return_stmt                    shift and go to state 294
    procedure_call                 shift and go to state 285
    assign_stmt                    shift and go to state 320
    statement_s                    shift and go to state 863
    simple_name                    shift and go to state 153
    code_stmt                      shift and go to state 313
    case_stmt                      shift and go to state 287
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 146
    label                          shift and go to state 288
    exit_stmt                      shift and go to state 315
    select_stmt                    shift and go to state 274
    statement                      shift and go to state 299
    compound_stmt                  shift and go to state 290
    case_hdr                       shift and go to state 292
    delay_stmt                     shift and go to state 301
    unlabeled                      shift and go to state 314
    simple_stmt                    shift and go to state 277
    loop_stmt                      shift and go to state 278
    qualified                      shift and go to state 279
    pragma                         shift and go to state 303
    async_select                   shift and go to state 273
    requeue_stmt                   shift and go to state 304
    raise_stmt                     shift and go to state 305
    name                           shift and go to state 281
    if_stmt                        shift and go to state 280
    accept_hdr                     shift and go to state 302
    cond_entry_call                shift and go to state 318
    timed_entry_call               shift and go to state 307
    goto_stmt                      shift and go to state 291
    NULL_stmt                      shift and go to state 319
    block                          shift and go to state 293

state 802

    (461) except_choice_s -> except_choice_s | . except_choice
    (462) except_choice -> . name
    (463) except_choice -> . OTHERS
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    OTHERS          shift and go to state 707
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    name                           shift and go to state 708
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 146
    indexed_comp                   shift and go to state 119
    except_choice                  shift and go to state 864
    simple_name                    shift and go to state 153

state 803

    (271) if_stmt -> IF cond_clause else_opt END IF . SEMICOLON

    SEMICOLON       shift and go to state 865


state 804

    (277) else_opt -> ELSIF cond_clause else_opt .

    END             reduce using rule 277 (else_opt -> ELSIF cond_clause else_opt .)


state 805

    (504) record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END . RECORD SEMICOLON

    RECORD          shift and go to state 866


state 806

    (508) comp_loc_s -> comp_loc_s mark . AT expression RANGE range SEMICOLON
    (159) mark -> mark . TICK attribute_id
    (160) mark -> mark . DOT simple_name

    AT              shift and go to state 867
    TICK            shift and go to state 323
    DOT             shift and go to state 324


state 807

    (506) align_opt -> AT MOD expression . SEMICOLON
    (196) expression -> expression . logical relation
    (197) expression -> expression . short_circuit relation
    (198) logical -> . AND
    (199) logical -> . OR
    (200) logical -> . XOR
    (201) short_circuit -> . AND THEN
    (202) short_circuit -> . OR ELSE

    SEMICOLON       shift and go to state 868
    AND             shift and go to state 244
    OR              shift and go to state 248
    XOR             shift and go to state 245

    logical                        shift and go to state 246
    short_circuit                  shift and go to state 247

state 808

    (365) task_body -> TASK BODY simple_name IS decl_part block_body END . id_opt SEMICOLON
    (293) id_opt -> .
    (294) id_opt -> . designator
    (316) designator -> . compound_name
    (317) designator -> . STRING
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name DOT simple_name
    (161) simple_name -> . IDENTIFIER

    SEMICOLON       reduce using rule 293 (id_opt -> .)
    STRING          shift and go to state 114
    IDENTIFIER      shift and go to state 40

    designator                     shift and go to state 471
    id_opt                         shift and go to state 869
    compound_name                  shift and go to state 113
    simple_name                    shift and go to state 41

state 809

    (397) rep_spec_s -> rep_spec_s rep_spec pragma_s .
    (9) pragma_s -> pragma_s . pragma
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON

    FOR             reduce using rule 397 (rep_spec_s -> rep_spec_s rep_spec pragma_s .)
    END             reduce using rule 397 (rep_spec_s -> rep_spec_s rep_spec pragma_s .)
    PRIVATE         reduce using rule 397 (rep_spec_s -> rep_spec_s rep_spec pragma_s .)
    PRAGMA          shift and go to state 4

    pragma                         shift and go to state 14

state 810

    (364) task_private_opt -> PRIVATE entry_decl_s . rep_spec_s
    (389) entry_decl_s -> entry_decl_s . entry_decl pragma_s
    (396) rep_spec_s -> .
    (397) rep_spec_s -> . rep_spec_s rep_spec pragma_s
    (390) entry_decl -> . ENTRY IDENTIFIER formal_part_opt SEMICOLON
    (391) entry_decl -> . ENTRY IDENTIFIER LPAREN discrete_range RPAREN formal_part_opt SEMICOLON

    FOR             reduce using rule 396 (rep_spec_s -> .)
    END             reduce using rule 396 (rep_spec_s -> .)
    ENTRY           shift and go to state 547

    rep_spec_s                     shift and go to state 870
    entry_decl                     shift and go to state 602

state 811

    (362) task_def -> IS entry_decl_s rep_spec_s task_private_opt END . id_opt
    (293) id_opt -> .
    (294) id_opt -> . designator
    (316) designator -> . compound_name
    (317) designator -> . STRING
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name DOT simple_name
    (161) simple_name -> . IDENTIFIER

    SEMICOLON       reduce using rule 293 (id_opt -> .)
    STRING          shift and go to state 114
    IDENTIFIER      shift and go to state 40

    designator                     shift and go to state 471
    id_opt                         shift and go to state 871
    compound_name                  shift and go to state 113
    simple_name                    shift and go to state 41

state 812

    (72) range_spec_opt -> range_spec .

    SEMICOLON       reduce using rule 72 (range_spec_opt -> range_spec .)


state 813

    (75) float_type -> DIGITS expression range_spec_opt .

    SEMICOLON       reduce using rule 75 (float_type -> DIGITS expression range_spec_opt .)


state 814

    (96) record_def -> RECORD . comp_list END RECORD
    (101) comp_list -> . comp_decl_s variant_part_opt
    (102) comp_list -> . variant_part
    (103) comp_list -> . NULL SEMICOLON
    (104) comp_decl_s -> . comp_decl
    (105) comp_decl_s -> . comp_decl_s comp_decl
    (117) variant_part -> . CASE simple_name IS variant_s END CASE SEMICOLON
    (108) comp_decl -> . def_id_s COLON component_subtype_def init_opt SEMICOLON
    (109) comp_decl -> . error SEMICOLON
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s COMMA def_id
    (26) def_id -> . IDENTIFIER

    NULL            shift and go to state 877
    CASE            shift and go to state 872
    error           shift and go to state 779
    IDENTIFIER      shift and go to state 79

    comp_decl                      shift and go to state 873
    def_id_s                       shift and go to state 775
    comp_list                      shift and go to state 876
    def_id                         shift and go to state 96
    variant_part                   shift and go to state 875
    comp_decl_s                    shift and go to state 874

state 815

    (97) record_def -> NULL . RECORD

    RECORD          shift and go to state 878


state 816

    (95) record_type -> tagged_opt limited_opt record_def .

    SEMICOLON       reduce using rule 95 (record_type -> tagged_opt limited_opt record_def .)


state 817

    (77) fixed_type -> DELTA expression DIGITS . expression range_spec_opt
    (195) expression -> . relation
    (196) expression -> . expression logical relation
    (197) expression -> . expression short_circuit relation
    (203) relation -> . simple_expression
    (204) relation -> . simple_expression relational simple_expression
    (205) relation -> . simple_expression membership range
    (206) relation -> . simple_expression membership name
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    relation                       shift and go to state 127
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    factor                         shift and go to state 136
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    term                           shift and go to state 144
    name                           shift and go to state 145
    operator_symbol                shift and go to state 146
    expression                     shift and go to state 879

state 818

    (76) fixed_type -> DELTA expression range_spec .

    SEMICOLON       reduce using rule 76 (fixed_type -> DELTA expression range_spec .)


state 819

    (65) enum_id_s -> enum_id_s COMMA . enum_id
    (66) enum_id -> . IDENTIFIER
    (67) enum_id -> . CHARACTER

    IDENTIFIER      shift and go to state 730
    CHARACTER       shift and go to state 729

    enum_id                        shift and go to state 880

state 820

    (63) enumeration_type -> LPAREN enum_id_s RPAREN .

    SEMICOLON       reduce using rule 63 (enumeration_type -> LPAREN enum_id_s RPAREN .)


state 821

    (129) access_type -> ACCESS CONSTANT subtype_ind .

    SEMICOLON       reduce using rule 129 (access_type -> ACCESS CONSTANT subtype_ind .)


state 822

    (132) access_type -> ACCESS prot_opt FUNCTION . formal_part_opt RETURN mark
    (318) formal_part_opt -> .
    (319) formal_part_opt -> . formal_part
    (320) formal_part -> . LPAREN param_s RPAREN

    RETURN          reduce using rule 318 (formal_part_opt -> .)
    LPAREN          shift and go to state 164

    formal_part                    shift and go to state 162
    formal_part_opt                shift and go to state 881

state 823

    (131) access_type -> ACCESS prot_opt PROCEDURE . formal_part_opt
    (318) formal_part_opt -> .
    (319) formal_part_opt -> . formal_part
    (320) formal_part -> . LPAREN param_s RPAREN

    SEMICOLON       reduce using rule 318 (formal_part_opt -> .)
    LPAREN          shift and go to state 164

    formal_part                    shift and go to state 162
    formal_part_opt                shift and go to state 882

state 824

    (130) access_type -> ACCESS ALL subtype_ind .

    SEMICOLON       reduce using rule 130 (access_type -> ACCESS ALL subtype_ind .)


state 825

    (113) discrim_spec -> def_id_s COLON access_opt mark . init_opt
    (159) mark -> mark . TICK attribute_id
    (160) mark -> mark . DOT simple_name
    (33) init_opt -> .
    (34) init_opt -> . IS_ASSIGNED expression

    TICK            shift and go to state 323
    DOT             shift and go to state 324
    RPAREN          reduce using rule 33 (init_opt -> .)
    SEMICOLON       reduce using rule 33 (init_opt -> .)
    IS_ASSIGNED     shift and go to state 637

    init_opt                       shift and go to state 883

state 826

    (53) decimal_digits_constraint -> DIGITS expression range_constr_opt .

    SEMICOLON       reduce using rule 53 (decimal_digits_constraint -> DIGITS expression range_constr_opt .)
    RENAMES         reduce using rule 53 (decimal_digits_constraint -> DIGITS expression range_constr_opt .)
    IS_ASSIGNED     reduce using rule 53 (decimal_digits_constraint -> DIGITS expression range_constr_opt .)
    WITH            reduce using rule 53 (decimal_digits_constraint -> DIGITS expression range_constr_opt .)


state 827

    (84) aliased_opt -> ALIASED .

    IDENTIFIER      reduce using rule 84 (aliased_opt -> ALIASED .)
    STRING          reduce using rule 84 (aliased_opt -> ALIASED .)


state 828

    (82) component_subtype_def -> aliased_opt . subtype_ind
    (49) subtype_ind -> . name constraint
    (50) subtype_ind -> . name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    name                           shift and go to state 490
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 146
    subtype_ind                    shift and go to state 884
    indexed_comp                   shift and go to state 119
    simple_name                    shift and go to state 153

state 829

    (81) constr_array_type -> ARRAY iter_index_constraint OF component_subtype_def .

    SEMICOLON       reduce using rule 81 (constr_array_type -> ARRAY iter_index_constraint OF component_subtype_def .)
    IS_ASSIGNED     reduce using rule 81 (constr_array_type -> ARRAY iter_index_constraint OF component_subtype_def .)


state 830

    (90) iter_discrete_range_s -> iter_discrete_range_s COMMA . discrete_range
    (91) discrete_range -> . name range_constr_opt
    (92) discrete_range -> . range
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (60) range -> . simple_expression DOUBLEDOT simple_expression
    (61) range -> . name TICK RANGE
    (62) range -> . name TICK RANGE LPAREN expression RPAREN
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN

    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137
    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    simple_expression              shift and go to state 356
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    factor                         shift and go to state 136
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    discrete_range                 shift and go to state 885
    aggregate                      shift and go to state 126
    term                           shift and go to state 144
    name                           shift and go to state 684
    operator_symbol                shift and go to state 146
    range                          shift and go to state 685

state 831

    (88) iter_index_constraint -> LPAREN iter_discrete_range_s RPAREN .

    OF              reduce using rule 88 (iter_index_constraint -> LPAREN iter_discrete_range_s RPAREN .)


state 832

    (80) unconstr_array_type -> ARRAY LPAREN index_s RPAREN . OF component_subtype_def

    OF              shift and go to state 886


state 833

    (86) index_s -> index_s COMMA . index
    (87) index -> . name RANGE BOX
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    index                          shift and go to state 887
    name                           shift and go to state 888
    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    operator_symbol                shift and go to state 146
    indexed_comp                   shift and go to state 119
    simple_name                    shift and go to state 153

state 834

    (87) index -> name RANGE . BOX
    (59) range_constraint -> RANGE . range
    (60) range -> . simple_expression DOUBLEDOT simple_expression
    (61) range -> . name TICK RANGE
    (62) range -> . name TICK RANGE LPAREN expression RPAREN
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN

    BOX             shift and go to state 889
    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    simple_expression              shift and go to state 356
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    factor                         shift and go to state 136
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    term                           shift and go to state 144
    name                           shift and go to state 519
    operator_symbol                shift and go to state 146
    range                          shift and go to state 520

state 835

    (474) generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default . SEMICOLON

    SEMICOLON       shift and go to state 890


state 836

    (476) generic_formal -> WITH PACKAGE simple_name IS NEW name SEMICOLON .

    PACKAGE         reduce using rule 476 (generic_formal -> WITH PACKAGE simple_name IS NEW name SEMICOLON .)
    PROCEDURE       reduce using rule 476 (generic_formal -> WITH PACKAGE simple_name IS NEW name SEMICOLON .)
    FUNCTION        reduce using rule 476 (generic_formal -> WITH PACKAGE simple_name IS NEW name SEMICOLON .)
    TYPE            reduce using rule 476 (generic_formal -> WITH PACKAGE simple_name IS NEW name SEMICOLON .)
    WITH            reduce using rule 476 (generic_formal -> WITH PACKAGE simple_name IS NEW name SEMICOLON .)
    error           reduce using rule 476 (generic_formal -> WITH PACKAGE simple_name IS NEW name SEMICOLON .)
    USE             reduce using rule 476 (generic_formal -> WITH PACKAGE simple_name IS NEW name SEMICOLON .)
    IDENTIFIER      reduce using rule 476 (generic_formal -> WITH PACKAGE simple_name IS NEW name SEMICOLON .)


state 837

    (475) generic_formal -> WITH PACKAGE simple_name IS NEW name LPAREN . BOX RPAREN SEMICOLON
    (168) indexed_comp -> name LPAREN . value_s RPAREN
    (169) value_s -> . value
    (170) value_s -> . value_s COMMA value
    (171) value -> . expression
    (172) value -> . comp_assoc
    (173) value -> . discrete_with_range
    (174) value -> . error
    (195) expression -> . relation
    (196) expression -> . expression logical relation
    (197) expression -> . expression short_circuit relation
    (194) comp_assoc -> . choice_s ARROW expression
    (126) discrete_with_range -> . name range_constraint
    (127) discrete_with_range -> . range
    (203) relation -> . simple_expression
    (204) relation -> . simple_expression relational simple_expression
    (205) relation -> . simple_expression membership range
    (206) relation -> . simple_expression membership name
    (121) choice_s -> . choice
    (122) choice_s -> . choice_s | choice
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (60) range -> . simple_expression DOUBLEDOT simple_expression
    (61) range -> . name TICK RANGE
    (62) range -> . name TICK RANGE LPAREN expression RPAREN
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (123) choice -> . expression
    (124) choice -> . discrete_with_range
    (125) choice -> . OTHERS
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN

    BOX             shift and go to state 891
    error           shift and go to state 233
    OTHERS          shift and go to state 222
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137
    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    relation                       shift and go to state 127
    value_s                        shift and go to state 381
    simple_expression              shift and go to state 379
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    choice_s                       shift and go to state 225
    comp_assoc                     shift and go to state 380
    factor                         shift and go to state 136
    choice                         shift and go to state 227
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    discrete_with_range            shift and go to state 229
    term                           shift and go to state 144
    name                           shift and go to state 230
    operator_symbol                shift and go to state 146
    value                          shift and go to state 378
    range                          shift and go to state 232
    expression                     shift and go to state 382

state 838

    (496) generic_derived_type -> ABSTRACT NEW subtype_ind . WITH PRIVATE

    WITH            shift and go to state 892


state 839

    (495) generic_derived_type -> NEW subtype_ind WITH . PRIVATE

    PRIVATE         shift and go to state 893


state 840

    (343) private_type -> tagged_opt limited_opt PRIVATE .

    SEMICOLON       reduce using rule 343 (private_type -> tagged_opt limited_opt PRIVATE .)


state 841

    (484) generic_type_def -> LPAREN BOX RPAREN .

    SEMICOLON       reduce using rule 484 (generic_type_def -> LPAREN BOX RPAREN .)


state 842

    (488) generic_type_def -> DELTA BOX DIGITS . BOX

    BOX             shift and go to state 894


state 843

    (62) range -> name TICK RANGE LPAREN expression RPAREN .

    RPAREN          reduce using rule 62 (range -> name TICK RANGE LPAREN expression RPAREN .)
    COMMA           reduce using rule 62 (range -> name TICK RANGE LPAREN expression RPAREN .)
    ARROW           reduce using rule 62 (range -> name TICK RANGE LPAREN expression RPAREN .)
    |               reduce using rule 62 (range -> name TICK RANGE LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 62 (range -> name TICK RANGE LPAREN expression RPAREN .)
    RENAMES         reduce using rule 62 (range -> name TICK RANGE LPAREN expression RPAREN .)
    IS_ASSIGNED     reduce using rule 62 (range -> name TICK RANGE LPAREN expression RPAREN .)
    WITH            reduce using rule 62 (range -> name TICK RANGE LPAREN expression RPAREN .)
    LOOP            reduce using rule 62 (range -> name TICK RANGE LPAREN expression RPAREN .)
    AND             reduce using rule 62 (range -> name TICK RANGE LPAREN expression RPAREN .)
    OR              reduce using rule 62 (range -> name TICK RANGE LPAREN expression RPAREN .)
    XOR             reduce using rule 62 (range -> name TICK RANGE LPAREN expression RPAREN .)
    IS              reduce using rule 62 (range -> name TICK RANGE LPAREN expression RPAREN .)
    THEN            reduce using rule 62 (range -> name TICK RANGE LPAREN expression RPAREN .)
    RANGE           reduce using rule 62 (range -> name TICK RANGE LPAREN expression RPAREN .)
    DIGITS          reduce using rule 62 (range -> name TICK RANGE LPAREN expression RPAREN .)


state 844

    (340) pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt SEMICOLON .

    PACKAGE         reduce using rule 340 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt SEMICOLON .)
    TASK            reduce using rule 340 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt SEMICOLON .)
    PROTECTED       reduce using rule 340 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt SEMICOLON .)
    error           reduce using rule 340 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt SEMICOLON .)
    USE             reduce using rule 340 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt SEMICOLON .)
    PRAGMA          reduce using rule 340 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt SEMICOLON .)
    TYPE            reduce using rule 340 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt SEMICOLON .)
    SUBTYPE         reduce using rule 340 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt SEMICOLON .)
    FOR             reduce using rule 340 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt SEMICOLON .)
    PROCEDURE       reduce using rule 340 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt SEMICOLON .)
    FUNCTION        reduce using rule 340 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt SEMICOLON .)
    GENERIC         reduce using rule 340 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt SEMICOLON .)
    IDENTIFIER      reduce using rule 340 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt SEMICOLON .)
    BEGIN           reduce using rule 340 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt SEMICOLON .)
    END             reduce using rule 340 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt SEMICOLON .)
    PRIVATE         reduce using rule 340 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt SEMICOLON .)
    WITH            reduce using rule 340 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt SEMICOLON .)
    SEPARATE        reduce using rule 340 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt SEMICOLON .)
    $end            reduce using rule 340 (pkg_body -> PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt SEMICOLON .)


state 845

    (382) prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt SEMICOLON .

    PACKAGE         reduce using rule 382 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt SEMICOLON .)
    TASK            reduce using rule 382 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt SEMICOLON .)
    PROTECTED       reduce using rule 382 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt SEMICOLON .)
    error           reduce using rule 382 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt SEMICOLON .)
    USE             reduce using rule 382 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt SEMICOLON .)
    PRAGMA          reduce using rule 382 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt SEMICOLON .)
    TYPE            reduce using rule 382 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt SEMICOLON .)
    SUBTYPE         reduce using rule 382 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt SEMICOLON .)
    FOR             reduce using rule 382 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt SEMICOLON .)
    PROCEDURE       reduce using rule 382 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt SEMICOLON .)
    FUNCTION        reduce using rule 382 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt SEMICOLON .)
    GENERIC         reduce using rule 382 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt SEMICOLON .)
    IDENTIFIER      reduce using rule 382 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt SEMICOLON .)
    BEGIN           reduce using rule 382 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt SEMICOLON .)
    END             reduce using rule 382 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt SEMICOLON .)
    PRIVATE         reduce using rule 382 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt SEMICOLON .)
    WITH            reduce using rule 382 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt SEMICOLON .)
    SEPARATE        reduce using rule 382 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt SEMICOLON .)
    $end            reduce using rule 382 (prot_body -> PROTECTED BODY simple_name IS prot_op_body_s END id_opt SEMICOLON .)


state 846

    (392) entry_body -> ENTRY IDENTIFIER formal_part_opt . WHEN condition entry_body_part

    WHEN            shift and go to state 895


state 847

    (393) entry_body -> ENTRY IDENTIFIER LPAREN . iter_part discrete_range RPAREN formal_part_opt WHEN condition entry_body_part
    (320) formal_part -> LPAREN . param_s RPAREN
    (286) iter_part -> . FOR IDENTIFIER IN
    (321) param_s -> . param
    (322) param_s -> . param_s SEMICOLON param
    (323) param -> . def_id_s COLON mode mark init_opt
    (324) param -> . error
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s COMMA def_id
    (26) def_id -> . IDENTIFIER

    FOR             shift and go to state 425
    error           shift and go to state 108
    IDENTIFIER      shift and go to state 79

    def_id                         shift and go to state 96
    param_s                        shift and go to state 267
    iter_part                      shift and go to state 896
    param                          shift and go to state 266
    def_id_s                       shift and go to state 104

state 848

    (108) comp_decl -> def_id_s COLON . component_subtype_def init_opt SEMICOLON
    (82) component_subtype_def -> . aliased_opt subtype_ind
    (83) aliased_opt -> .
    (84) aliased_opt -> . ALIASED

    IDENTIFIER      reduce using rule 83 (aliased_opt -> .)
    STRING          reduce using rule 83 (aliased_opt -> .)
    ALIASED         shift and go to state 827

    aliased_opt                    shift and go to state 828
    component_subtype_def          shift and go to state 897

state 849

    (109) comp_decl -> error SEMICOLON .

    error           reduce using rule 109 (comp_decl -> error SEMICOLON .)
    CASE            reduce using rule 109 (comp_decl -> error SEMICOLON .)
    IDENTIFIER      reduce using rule 109 (comp_decl -> error SEMICOLON .)
    END             reduce using rule 109 (comp_decl -> error SEMICOLON .)
    WHEN            reduce using rule 109 (comp_decl -> error SEMICOLON .)
    ENTRY           reduce using rule 109 (comp_decl -> error SEMICOLON .)
    PROCEDURE       reduce using rule 109 (comp_decl -> error SEMICOLON .)
    FUNCTION        reduce using rule 109 (comp_decl -> error SEMICOLON .)
    PRAGMA          reduce using rule 109 (comp_decl -> error SEMICOLON .)
    FOR             reduce using rule 109 (comp_decl -> error SEMICOLON .)


state 850

    (161) simple_name -> IDENTIFIER .
    (26) def_id -> IDENTIFIER .

    TICK            reduce using rule 161 (simple_name -> IDENTIFIER .)
    LPAREN          reduce using rule 161 (simple_name -> IDENTIFIER .)
    DOT             reduce using rule 161 (simple_name -> IDENTIFIER .)
    RANGE           reduce using rule 161 (simple_name -> IDENTIFIER .)
    RPAREN          reduce using rule 161 (simple_name -> IDENTIFIER .)
    POW             reduce using rule 161 (simple_name -> IDENTIFIER .)
    TIMES           reduce using rule 161 (simple_name -> IDENTIFIER .)
    DIVIDE          reduce using rule 161 (simple_name -> IDENTIFIER .)
    MOD             reduce using rule 161 (simple_name -> IDENTIFIER .)
    REM             reduce using rule 161 (simple_name -> IDENTIFIER .)
    DOUBLEDOT       reduce using rule 161 (simple_name -> IDENTIFIER .)
    PLUS            reduce using rule 161 (simple_name -> IDENTIFIER .)
    MINUS           reduce using rule 161 (simple_name -> IDENTIFIER .)
    AMPERSAND       reduce using rule 161 (simple_name -> IDENTIFIER .)
    COLON           reduce using rule 26 (def_id -> IDENTIFIER .)
    COMMA           reduce using rule 26 (def_id -> IDENTIFIER .)


state 851

    (391) entry_decl -> ENTRY IDENTIFIER LPAREN discrete_range . RPAREN formal_part_opt SEMICOLON

    RPAREN          shift and go to state 898


state 852

    (390) entry_decl -> ENTRY IDENTIFIER formal_part_opt SEMICOLON .

    error           reduce using rule 390 (entry_decl -> ENTRY IDENTIFIER formal_part_opt SEMICOLON .)
    ENTRY           reduce using rule 390 (entry_decl -> ENTRY IDENTIFIER formal_part_opt SEMICOLON .)
    PROCEDURE       reduce using rule 390 (entry_decl -> ENTRY IDENTIFIER formal_part_opt SEMICOLON .)
    FUNCTION        reduce using rule 390 (entry_decl -> ENTRY IDENTIFIER formal_part_opt SEMICOLON .)
    PRAGMA          reduce using rule 390 (entry_decl -> ENTRY IDENTIFIER formal_part_opt SEMICOLON .)
    FOR             reduce using rule 390 (entry_decl -> ENTRY IDENTIFIER formal_part_opt SEMICOLON .)
    IDENTIFIER      reduce using rule 390 (entry_decl -> ENTRY IDENTIFIER formal_part_opt SEMICOLON .)
    END             reduce using rule 390 (entry_decl -> ENTRY IDENTIFIER formal_part_opt SEMICOLON .)
    PRIVATE         reduce using rule 390 (entry_decl -> ENTRY IDENTIFIER formal_part_opt SEMICOLON .)


state 853

    (292) basic_loop -> LOOP statement_s END LOOP .

    STRING          reduce using rule 292 (basic_loop -> LOOP statement_s END LOOP .)
    IDENTIFIER      reduce using rule 292 (basic_loop -> LOOP statement_s END LOOP .)
    SEMICOLON       reduce using rule 292 (basic_loop -> LOOP statement_s END LOOP .)


state 854

    (295) block -> label_opt block_decl block_body END id_opt SEMICOLON .

    END             reduce using rule 295 (block -> label_opt block_decl block_body END id_opt SEMICOLON .)
    LLB             reduce using rule 295 (block -> label_opt block_decl block_body END id_opt SEMICOLON .)
    error           reduce using rule 295 (block -> label_opt block_decl block_body END id_opt SEMICOLON .)
    PRAGMA          reduce using rule 295 (block -> label_opt block_decl block_body END id_opt SEMICOLON .)
    NULL            reduce using rule 295 (block -> label_opt block_decl block_body END id_opt SEMICOLON .)
    EXIT            reduce using rule 295 (block -> label_opt block_decl block_body END id_opt SEMICOLON .)
    RETURN          reduce using rule 295 (block -> label_opt block_decl block_body END id_opt SEMICOLON .)
    GOTO            reduce using rule 295 (block -> label_opt block_decl block_body END id_opt SEMICOLON .)
    DELAY           reduce using rule 295 (block -> label_opt block_decl block_body END id_opt SEMICOLON .)
    ABORT           reduce using rule 295 (block -> label_opt block_decl block_body END id_opt SEMICOLON .)
    RAISE           reduce using rule 295 (block -> label_opt block_decl block_body END id_opt SEMICOLON .)
    REQUEUE         reduce using rule 295 (block -> label_opt block_decl block_body END id_opt SEMICOLON .)
    IF              reduce using rule 295 (block -> label_opt block_decl block_body END id_opt SEMICOLON .)
    CASE            reduce using rule 295 (block -> label_opt block_decl block_body END id_opt SEMICOLON .)
    IDENTIFIER      reduce using rule 295 (block -> label_opt block_decl block_body END id_opt SEMICOLON .)
    ACCEPT          reduce using rule 295 (block -> label_opt block_decl block_body END id_opt SEMICOLON .)
    SELECT          reduce using rule 295 (block -> label_opt block_decl block_body END id_opt SEMICOLON .)
    STRING          reduce using rule 295 (block -> label_opt block_decl block_body END id_opt SEMICOLON .)
    WHILE           reduce using rule 295 (block -> label_opt block_decl block_body END id_opt SEMICOLON .)
    DECLARE         reduce using rule 295 (block -> label_opt block_decl block_body END id_opt SEMICOLON .)
    FOR             reduce using rule 295 (block -> label_opt block_decl block_body END id_opt SEMICOLON .)
    LOOP            reduce using rule 295 (block -> label_opt block_decl block_body END id_opt SEMICOLON .)
    BEGIN           reduce using rule 295 (block -> label_opt block_decl block_body END id_opt SEMICOLON .)
    EXCEPTION       reduce using rule 295 (block -> label_opt block_decl block_body END id_opt SEMICOLON .)
    WHEN            reduce using rule 295 (block -> label_opt block_decl block_body END id_opt SEMICOLON .)
    ELSE            reduce using rule 295 (block -> label_opt block_decl block_body END id_opt SEMICOLON .)
    ELSIF           reduce using rule 295 (block -> label_opt block_decl block_body END id_opt SEMICOLON .)
    OR              reduce using rule 295 (block -> label_opt block_decl block_body END id_opt SEMICOLON .)
    THEN            reduce using rule 295 (block -> label_opt block_decl block_body END id_opt SEMICOLON .)


state 855

    (422) cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END . SELECT SEMICOLON

    SELECT          shift and go to state 899


state 856

    (421) timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt . END SELECT SEMICOLON

    END             shift and go to state 900


state 857

    (420) async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END . SELECT SEMICOLON

    SELECT          shift and go to state 901


state 858

    (416) select_alt -> delay_stmt stmts_opt .

    OR              reduce using rule 416 (select_alt -> delay_stmt stmts_opt .)
    ELSE            reduce using rule 416 (select_alt -> delay_stmt stmts_opt .)
    ELSIF           reduce using rule 416 (select_alt -> delay_stmt stmts_opt .)
    END             reduce using rule 416 (select_alt -> delay_stmt stmts_opt .)


state 859

    (410) select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT . SEMICOLON

    SEMICOLON       shift and go to state 902


state 860

    (282) alternative -> WHEN choice_s ARROW statement_s .
    (244) statement_s -> statement_s . statement
    (245) statement -> . unlabeled
    (246) statement -> . label statement
    (247) unlabeled -> . simple_stmt
    (248) unlabeled -> . compound_stmt
    (249) unlabeled -> . pragma
    (268) label -> . LLB IDENTIFIER RLB
    (250) simple_stmt -> . NULL_stmt
    (251) simple_stmt -> . assign_stmt
    (252) simple_stmt -> . exit_stmt
    (253) simple_stmt -> . return_stmt
    (254) simple_stmt -> . goto_stmt
    (255) simple_stmt -> . procedure_call
    (256) simple_stmt -> . delay_stmt
    (257) simple_stmt -> . abort_stmt
    (258) simple_stmt -> . raise_stmt
    (259) simple_stmt -> . code_stmt
    (260) simple_stmt -> . requeue_stmt
    (261) simple_stmt -> . error SEMICOLON
    (262) compound_stmt -> . if_stmt
    (263) compound_stmt -> . case_stmt
    (264) compound_stmt -> . loop_stmt
    (265) compound_stmt -> . block
    (266) compound_stmt -> . accept_stmt
    (267) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (269) NULL_stmt -> . NULL SEMICOLON
    (270) assign_stmt -> . name IS_ASSIGNED expression SEMICOLON
    (302) exit_stmt -> . EXIT name_opt when_opt SEMICOLON
    (307) return_stmt -> . RETURN SEMICOLON
    (308) return_stmt -> . RETURN expression SEMICOLON
    (309) goto_stmt -> . GOTO name SEMICOLON
    (332) procedure_call -> . name SEMICOLON
    (404) delay_stmt -> . DELAY expression SEMICOLON
    (405) delay_stmt -> . DELAY UNTIL expression SEMICOLON
    (425) abort_stmt -> . ABORT name_s SEMICOLON
    (464) raise_stmt -> . RAISE name_opt SEMICOLON
    (510) code_stmt -> . qualified SEMICOLON
    (465) requeue_stmt -> . REQUEUE name SEMICOLON
    (466) requeue_stmt -> . REQUEUE name WITH ABORT SEMICOLON
    (271) if_stmt -> . IF cond_clause else_opt END IF SEMICOLON
    (278) case_stmt -> . case_hdr alternative_s END CASE SEMICOLON
    (283) loop_stmt -> . label_opt iteration basic_loop id_opt SEMICOLON
    (295) block -> . label_opt block_decl block_body END id_opt SEMICOLON
    (399) accept_stmt -> . accept_hdr SEMICOLON
    (400) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt SEMICOLON
    (406) select_stmt -> . select_wait
    (407) select_stmt -> . async_select
    (408) select_stmt -> . timed_entry_call
    (409) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (240) qualified -> . name TICK parenthesized_primary
    (279) case_hdr -> . CASE expression IS
    (284) label_opt -> .
    (285) label_opt -> . IDENTIFIER COLON
    (401) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (410) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON
    (420) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON
    (421) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON
    (422) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    END             reduce using rule 282 (alternative -> WHEN choice_s ARROW statement_s .)
    WHEN            reduce using rule 282 (alternative -> WHEN choice_s ARROW statement_s .)
    LLB             shift and go to state 289
    error           shift and go to state 309
    PRAGMA          shift and go to state 4
    NULL            shift and go to state 311
    EXIT            shift and go to state 308
    RETURN          shift and go to state 295
    GOTO            shift and go to state 276
    DELAY           shift and go to state 272
    ABORT           shift and go to state 282
    RAISE           shift and go to state 306
    REQUEUE         shift and go to state 298
    IF              shift and go to state 317
    CASE            shift and go to state 297
    WHILE           reduce using rule 284 (label_opt -> .)
    DECLARE         reduce using rule 284 (label_opt -> .)
    FOR             reduce using rule 284 (label_opt -> .)
    LOOP            reduce using rule 284 (label_opt -> .)
    BEGIN           reduce using rule 284 (label_opt -> .)
    IDENTIFIER      shift and go to state 300
    ACCEPT          shift and go to state 284
    SELECT          shift and go to state 286
    STRING          shift and go to state 137

    indexed_comp                   shift and go to state 119
    accept_stmt                    shift and go to state 283
    label_opt                      shift and go to state 275
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 316
    abort_stmt                     shift and go to state 310
    return_stmt                    shift and go to state 294
    procedure_call                 shift and go to state 285
    assign_stmt                    shift and go to state 320
    simple_name                    shift and go to state 153
    code_stmt                      shift and go to state 313
    case_stmt                      shift and go to state 287
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 146
    label                          shift and go to state 288
    exit_stmt                      shift and go to state 315
    select_stmt                    shift and go to state 274
    statement                      shift and go to state 465
    compound_stmt                  shift and go to state 290
    case_hdr                       shift and go to state 292
    delay_stmt                     shift and go to state 301
    unlabeled                      shift and go to state 314
    simple_stmt                    shift and go to state 277
    loop_stmt                      shift and go to state 278
    qualified                      shift and go to state 279
    pragma                         shift and go to state 303
    async_select                   shift and go to state 273
    requeue_stmt                   shift and go to state 304
    raise_stmt                     shift and go to state 305
    name                           shift and go to state 281
    if_stmt                        shift and go to state 280
    accept_hdr                     shift and go to state 302
    cond_entry_call                shift and go to state 318
    timed_entry_call               shift and go to state 307
    goto_stmt                      shift and go to state 291
    NULL_stmt                      shift and go to state 319
    block                          shift and go to state 293

state 861

    (400) accept_stmt -> accept_hdr DO handled_stmt_s END id_opt SEMICOLON .

    LLB             reduce using rule 400 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt SEMICOLON .)
    error           reduce using rule 400 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt SEMICOLON .)
    PRAGMA          reduce using rule 400 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt SEMICOLON .)
    NULL            reduce using rule 400 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt SEMICOLON .)
    EXIT            reduce using rule 400 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt SEMICOLON .)
    RETURN          reduce using rule 400 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt SEMICOLON .)
    GOTO            reduce using rule 400 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt SEMICOLON .)
    DELAY           reduce using rule 400 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt SEMICOLON .)
    ABORT           reduce using rule 400 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt SEMICOLON .)
    RAISE           reduce using rule 400 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt SEMICOLON .)
    REQUEUE         reduce using rule 400 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt SEMICOLON .)
    IF              reduce using rule 400 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt SEMICOLON .)
    CASE            reduce using rule 400 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt SEMICOLON .)
    IDENTIFIER      reduce using rule 400 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt SEMICOLON .)
    ACCEPT          reduce using rule 400 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt SEMICOLON .)
    SELECT          reduce using rule 400 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt SEMICOLON .)
    STRING          reduce using rule 400 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt SEMICOLON .)
    WHILE           reduce using rule 400 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt SEMICOLON .)
    DECLARE         reduce using rule 400 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt SEMICOLON .)
    FOR             reduce using rule 400 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt SEMICOLON .)
    LOOP            reduce using rule 400 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt SEMICOLON .)
    BEGIN           reduce using rule 400 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt SEMICOLON .)
    END             reduce using rule 400 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt SEMICOLON .)
    EXCEPTION       reduce using rule 400 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt SEMICOLON .)
    OR              reduce using rule 400 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt SEMICOLON .)
    ELSE            reduce using rule 400 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt SEMICOLON .)
    ELSIF           reduce using rule 400 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt SEMICOLON .)
    THEN            reduce using rule 400 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt SEMICOLON .)
    WHEN            reduce using rule 400 (accept_stmt -> accept_hdr DO handled_stmt_s END id_opt SEMICOLON .)


state 862

    (459) exception_handler -> WHEN IDENTIFIER COLON except_choice_s . ARROW statement_s
    (461) except_choice_s -> except_choice_s . | except_choice

    ARROW           shift and go to state 903
    |               shift and go to state 802


state 863

    (458) exception_handler -> WHEN except_choice_s ARROW statement_s .
    (244) statement_s -> statement_s . statement
    (245) statement -> . unlabeled
    (246) statement -> . label statement
    (247) unlabeled -> . simple_stmt
    (248) unlabeled -> . compound_stmt
    (249) unlabeled -> . pragma
    (268) label -> . LLB IDENTIFIER RLB
    (250) simple_stmt -> . NULL_stmt
    (251) simple_stmt -> . assign_stmt
    (252) simple_stmt -> . exit_stmt
    (253) simple_stmt -> . return_stmt
    (254) simple_stmt -> . goto_stmt
    (255) simple_stmt -> . procedure_call
    (256) simple_stmt -> . delay_stmt
    (257) simple_stmt -> . abort_stmt
    (258) simple_stmt -> . raise_stmt
    (259) simple_stmt -> . code_stmt
    (260) simple_stmt -> . requeue_stmt
    (261) simple_stmt -> . error SEMICOLON
    (262) compound_stmt -> . if_stmt
    (263) compound_stmt -> . case_stmt
    (264) compound_stmt -> . loop_stmt
    (265) compound_stmt -> . block
    (266) compound_stmt -> . accept_stmt
    (267) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (269) NULL_stmt -> . NULL SEMICOLON
    (270) assign_stmt -> . name IS_ASSIGNED expression SEMICOLON
    (302) exit_stmt -> . EXIT name_opt when_opt SEMICOLON
    (307) return_stmt -> . RETURN SEMICOLON
    (308) return_stmt -> . RETURN expression SEMICOLON
    (309) goto_stmt -> . GOTO name SEMICOLON
    (332) procedure_call -> . name SEMICOLON
    (404) delay_stmt -> . DELAY expression SEMICOLON
    (405) delay_stmt -> . DELAY UNTIL expression SEMICOLON
    (425) abort_stmt -> . ABORT name_s SEMICOLON
    (464) raise_stmt -> . RAISE name_opt SEMICOLON
    (510) code_stmt -> . qualified SEMICOLON
    (465) requeue_stmt -> . REQUEUE name SEMICOLON
    (466) requeue_stmt -> . REQUEUE name WITH ABORT SEMICOLON
    (271) if_stmt -> . IF cond_clause else_opt END IF SEMICOLON
    (278) case_stmt -> . case_hdr alternative_s END CASE SEMICOLON
    (283) loop_stmt -> . label_opt iteration basic_loop id_opt SEMICOLON
    (295) block -> . label_opt block_decl block_body END id_opt SEMICOLON
    (399) accept_stmt -> . accept_hdr SEMICOLON
    (400) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt SEMICOLON
    (406) select_stmt -> . select_wait
    (407) select_stmt -> . async_select
    (408) select_stmt -> . timed_entry_call
    (409) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (240) qualified -> . name TICK parenthesized_primary
    (279) case_hdr -> . CASE expression IS
    (284) label_opt -> .
    (285) label_opt -> . IDENTIFIER COLON
    (401) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (410) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON
    (420) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON
    (421) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON
    (422) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    WHEN            reduce using rule 458 (exception_handler -> WHEN except_choice_s ARROW statement_s .)
    END             reduce using rule 458 (exception_handler -> WHEN except_choice_s ARROW statement_s .)
    LLB             shift and go to state 289
    error           shift and go to state 309
    PRAGMA          shift and go to state 4
    NULL            shift and go to state 311
    EXIT            shift and go to state 308
    RETURN          shift and go to state 295
    GOTO            shift and go to state 276
    DELAY           shift and go to state 272
    ABORT           shift and go to state 282
    RAISE           shift and go to state 306
    REQUEUE         shift and go to state 298
    IF              shift and go to state 317
    CASE            shift and go to state 297
    WHILE           reduce using rule 284 (label_opt -> .)
    DECLARE         reduce using rule 284 (label_opt -> .)
    FOR             reduce using rule 284 (label_opt -> .)
    LOOP            reduce using rule 284 (label_opt -> .)
    BEGIN           reduce using rule 284 (label_opt -> .)
    IDENTIFIER      shift and go to state 300
    ACCEPT          shift and go to state 284
    SELECT          shift and go to state 286
    STRING          shift and go to state 137

    indexed_comp                   shift and go to state 119
    accept_stmt                    shift and go to state 283
    label_opt                      shift and go to state 275
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 316
    abort_stmt                     shift and go to state 310
    return_stmt                    shift and go to state 294
    procedure_call                 shift and go to state 285
    assign_stmt                    shift and go to state 320
    simple_name                    shift and go to state 153
    code_stmt                      shift and go to state 313
    case_stmt                      shift and go to state 287
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 146
    label                          shift and go to state 288
    exit_stmt                      shift and go to state 315
    select_stmt                    shift and go to state 274
    statement                      shift and go to state 465
    compound_stmt                  shift and go to state 290
    case_hdr                       shift and go to state 292
    delay_stmt                     shift and go to state 301
    unlabeled                      shift and go to state 314
    simple_stmt                    shift and go to state 277
    loop_stmt                      shift and go to state 278
    qualified                      shift and go to state 279
    pragma                         shift and go to state 303
    async_select                   shift and go to state 273
    requeue_stmt                   shift and go to state 304
    raise_stmt                     shift and go to state 305
    name                           shift and go to state 281
    if_stmt                        shift and go to state 280
    accept_hdr                     shift and go to state 302
    cond_entry_call                shift and go to state 318
    timed_entry_call               shift and go to state 307
    goto_stmt                      shift and go to state 291
    NULL_stmt                      shift and go to state 319
    block                          shift and go to state 293

state 864

    (461) except_choice_s -> except_choice_s | except_choice .

    ARROW           reduce using rule 461 (except_choice_s -> except_choice_s | except_choice .)
    |               reduce using rule 461 (except_choice_s -> except_choice_s | except_choice .)


state 865

    (271) if_stmt -> IF cond_clause else_opt END IF SEMICOLON .

    LLB             reduce using rule 271 (if_stmt -> IF cond_clause else_opt END IF SEMICOLON .)
    error           reduce using rule 271 (if_stmt -> IF cond_clause else_opt END IF SEMICOLON .)
    PRAGMA          reduce using rule 271 (if_stmt -> IF cond_clause else_opt END IF SEMICOLON .)
    NULL            reduce using rule 271 (if_stmt -> IF cond_clause else_opt END IF SEMICOLON .)
    EXIT            reduce using rule 271 (if_stmt -> IF cond_clause else_opt END IF SEMICOLON .)
    RETURN          reduce using rule 271 (if_stmt -> IF cond_clause else_opt END IF SEMICOLON .)
    GOTO            reduce using rule 271 (if_stmt -> IF cond_clause else_opt END IF SEMICOLON .)
    DELAY           reduce using rule 271 (if_stmt -> IF cond_clause else_opt END IF SEMICOLON .)
    ABORT           reduce using rule 271 (if_stmt -> IF cond_clause else_opt END IF SEMICOLON .)
    RAISE           reduce using rule 271 (if_stmt -> IF cond_clause else_opt END IF SEMICOLON .)
    REQUEUE         reduce using rule 271 (if_stmt -> IF cond_clause else_opt END IF SEMICOLON .)
    IF              reduce using rule 271 (if_stmt -> IF cond_clause else_opt END IF SEMICOLON .)
    CASE            reduce using rule 271 (if_stmt -> IF cond_clause else_opt END IF SEMICOLON .)
    IDENTIFIER      reduce using rule 271 (if_stmt -> IF cond_clause else_opt END IF SEMICOLON .)
    ACCEPT          reduce using rule 271 (if_stmt -> IF cond_clause else_opt END IF SEMICOLON .)
    SELECT          reduce using rule 271 (if_stmt -> IF cond_clause else_opt END IF SEMICOLON .)
    STRING          reduce using rule 271 (if_stmt -> IF cond_clause else_opt END IF SEMICOLON .)
    WHILE           reduce using rule 271 (if_stmt -> IF cond_clause else_opt END IF SEMICOLON .)
    DECLARE         reduce using rule 271 (if_stmt -> IF cond_clause else_opt END IF SEMICOLON .)
    FOR             reduce using rule 271 (if_stmt -> IF cond_clause else_opt END IF SEMICOLON .)
    LOOP            reduce using rule 271 (if_stmt -> IF cond_clause else_opt END IF SEMICOLON .)
    BEGIN           reduce using rule 271 (if_stmt -> IF cond_clause else_opt END IF SEMICOLON .)
    WHEN            reduce using rule 271 (if_stmt -> IF cond_clause else_opt END IF SEMICOLON .)
    END             reduce using rule 271 (if_stmt -> IF cond_clause else_opt END IF SEMICOLON .)
    EXCEPTION       reduce using rule 271 (if_stmt -> IF cond_clause else_opt END IF SEMICOLON .)
    OR              reduce using rule 271 (if_stmt -> IF cond_clause else_opt END IF SEMICOLON .)
    ELSE            reduce using rule 271 (if_stmt -> IF cond_clause else_opt END IF SEMICOLON .)
    ELSIF           reduce using rule 271 (if_stmt -> IF cond_clause else_opt END IF SEMICOLON .)
    THEN            reduce using rule 271 (if_stmt -> IF cond_clause else_opt END IF SEMICOLON .)


state 866

    (504) record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD . SEMICOLON

    SEMICOLON       shift and go to state 904


state 867

    (508) comp_loc_s -> comp_loc_s mark AT . expression RANGE range SEMICOLON
    (195) expression -> . relation
    (196) expression -> . expression logical relation
    (197) expression -> . expression short_circuit relation
    (203) relation -> . simple_expression
    (204) relation -> . simple_expression relational simple_expression
    (205) relation -> . simple_expression membership range
    (206) relation -> . simple_expression membership name
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    relation                       shift and go to state 127
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    factor                         shift and go to state 136
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    term                           shift and go to state 144
    name                           shift and go to state 145
    operator_symbol                shift and go to state 146
    expression                     shift and go to state 905

state 868

    (506) align_opt -> AT MOD expression SEMICOLON .

    END             reduce using rule 506 (align_opt -> AT MOD expression SEMICOLON .)
    IDENTIFIER      reduce using rule 506 (align_opt -> AT MOD expression SEMICOLON .)


state 869

    (365) task_body -> TASK BODY simple_name IS decl_part block_body END id_opt . SEMICOLON

    SEMICOLON       shift and go to state 906


state 870

    (364) task_private_opt -> PRIVATE entry_decl_s rep_spec_s .
    (397) rep_spec_s -> rep_spec_s . rep_spec pragma_s
    (500) rep_spec -> . attrib_def
    (501) rep_spec -> . record_type_spec
    (502) rep_spec -> . address_spec
    (503) attrib_def -> . FOR mark USE expression SEMICOLON
    (504) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD SEMICOLON
    (509) address_spec -> . FOR mark USE AT expression SEMICOLON

    END             reduce using rule 364 (task_private_opt -> PRIVATE entry_decl_s rep_spec_s .)
    FOR             shift and go to state 70

    record_type_spec               shift and go to state 75
    rep_spec                       shift and go to state 718
    attrib_def                     shift and go to state 77
    address_spec                   shift and go to state 59

state 871

    (362) task_def -> IS entry_decl_s rep_spec_s task_private_opt END id_opt .

    SEMICOLON       reduce using rule 362 (task_def -> IS entry_decl_s rep_spec_s task_private_opt END id_opt .)


state 872

    (117) variant_part -> CASE . simple_name IS variant_s END CASE SEMICOLON
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 40

    simple_name                    shift and go to state 907

state 873

    (104) comp_decl_s -> comp_decl .

    error           reduce using rule 104 (comp_decl_s -> comp_decl .)
    CASE            reduce using rule 104 (comp_decl_s -> comp_decl .)
    IDENTIFIER      reduce using rule 104 (comp_decl_s -> comp_decl .)
    END             reduce using rule 104 (comp_decl_s -> comp_decl .)
    WHEN            reduce using rule 104 (comp_decl_s -> comp_decl .)


state 874

    (101) comp_list -> comp_decl_s . variant_part_opt
    (105) comp_decl_s -> comp_decl_s . comp_decl
    (106) variant_part_opt -> .
    (107) variant_part_opt -> . variant_part
    (108) comp_decl -> . def_id_s COLON component_subtype_def init_opt SEMICOLON
    (109) comp_decl -> . error SEMICOLON
    (117) variant_part -> . CASE simple_name IS variant_s END CASE SEMICOLON
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s COMMA def_id
    (26) def_id -> . IDENTIFIER

    END             reduce using rule 106 (variant_part_opt -> .)
    WHEN            reduce using rule 106 (variant_part_opt -> .)
    error           shift and go to state 779
    CASE            shift and go to state 872
    IDENTIFIER      shift and go to state 79

    comp_decl                      shift and go to state 908
    def_id                         shift and go to state 96
    variant_part                   shift and go to state 909
    variant_part_opt               shift and go to state 910
    def_id_s                       shift and go to state 775

state 875

    (102) comp_list -> variant_part .

    END             reduce using rule 102 (comp_list -> variant_part .)
    WHEN            reduce using rule 102 (comp_list -> variant_part .)


state 876

    (96) record_def -> RECORD comp_list . END RECORD

    END             shift and go to state 911


state 877

    (103) comp_list -> NULL . SEMICOLON

    SEMICOLON       shift and go to state 912


state 878

    (97) record_def -> NULL RECORD .

    SEMICOLON       reduce using rule 97 (record_def -> NULL RECORD .)


state 879

    (77) fixed_type -> DELTA expression DIGITS expression . range_spec_opt
    (196) expression -> expression . logical relation
    (197) expression -> expression . short_circuit relation
    (71) range_spec_opt -> .
    (72) range_spec_opt -> . range_spec
    (198) logical -> . AND
    (199) logical -> . OR
    (200) logical -> . XOR
    (201) short_circuit -> . AND THEN
    (202) short_circuit -> . OR ELSE
    (70) range_spec -> . range_constraint
    (59) range_constraint -> . RANGE range

    SEMICOLON       reduce using rule 71 (range_spec_opt -> .)
    AND             shift and go to state 244
    OR              shift and go to state 248
    XOR             shift and go to state 245
    RANGE           shift and go to state 371

    logical                        shift and go to state 246
    short_circuit                  shift and go to state 247
    range_constraint               shift and go to state 608
    range_spec                     shift and go to state 812
    range_spec_opt                 shift and go to state 913

state 880

    (65) enum_id_s -> enum_id_s COMMA enum_id .

    RPAREN          reduce using rule 65 (enum_id_s -> enum_id_s COMMA enum_id .)
    COMMA           reduce using rule 65 (enum_id_s -> enum_id_s COMMA enum_id .)


state 881

    (132) access_type -> ACCESS prot_opt FUNCTION formal_part_opt . RETURN mark

    RETURN          shift and go to state 914


state 882

    (131) access_type -> ACCESS prot_opt PROCEDURE formal_part_opt .

    SEMICOLON       reduce using rule 131 (access_type -> ACCESS prot_opt PROCEDURE formal_part_opt .)


state 883

    (113) discrim_spec -> def_id_s COLON access_opt mark init_opt .

    RPAREN          reduce using rule 113 (discrim_spec -> def_id_s COLON access_opt mark init_opt .)
    SEMICOLON       reduce using rule 113 (discrim_spec -> def_id_s COLON access_opt mark init_opt .)


state 884

    (82) component_subtype_def -> aliased_opt subtype_ind .

    IS_ASSIGNED     reduce using rule 82 (component_subtype_def -> aliased_opt subtype_ind .)
    SEMICOLON       reduce using rule 82 (component_subtype_def -> aliased_opt subtype_ind .)


state 885

    (90) iter_discrete_range_s -> iter_discrete_range_s COMMA discrete_range .

    RPAREN          reduce using rule 90 (iter_discrete_range_s -> iter_discrete_range_s COMMA discrete_range .)
    COMMA           reduce using rule 90 (iter_discrete_range_s -> iter_discrete_range_s COMMA discrete_range .)


state 886

    (80) unconstr_array_type -> ARRAY LPAREN index_s RPAREN OF . component_subtype_def
    (82) component_subtype_def -> . aliased_opt subtype_ind
    (83) aliased_opt -> .
    (84) aliased_opt -> . ALIASED

    IDENTIFIER      reduce using rule 83 (aliased_opt -> .)
    STRING          reduce using rule 83 (aliased_opt -> .)
    ALIASED         shift and go to state 827

    aliased_opt                    shift and go to state 828
    component_subtype_def          shift and go to state 915

state 887

    (86) index_s -> index_s COMMA index .

    RPAREN          reduce using rule 86 (index_s -> index_s COMMA index .)
    COMMA           reduce using rule 86 (index_s -> index_s COMMA index .)


state 888

    (87) index -> name . RANGE BOX
    (168) indexed_comp -> name . LPAREN value_s RPAREN
    (175) selected_comp -> name . DOT simple_name
    (176) selected_comp -> name . DOT used_char
    (177) selected_comp -> name . DOT operator_symbol
    (178) selected_comp -> name . DOT ALL
    (179) attribute -> name . TICK attribute_id

    RANGE           shift and go to state 916
    LPAREN          shift and go to state 240
    DOT             shift and go to state 242
    TICK            shift and go to state 251


state 889

    (87) index -> name RANGE BOX .

    RPAREN          reduce using rule 87 (index -> name RANGE BOX .)
    COMMA           reduce using rule 87 (index -> name RANGE BOX .)


state 890

    (474) generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default SEMICOLON .

    PACKAGE         reduce using rule 474 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default SEMICOLON .)
    PROCEDURE       reduce using rule 474 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default SEMICOLON .)
    FUNCTION        reduce using rule 474 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default SEMICOLON .)
    TYPE            reduce using rule 474 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default SEMICOLON .)
    WITH            reduce using rule 474 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default SEMICOLON .)
    error           reduce using rule 474 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default SEMICOLON .)
    USE             reduce using rule 474 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default SEMICOLON .)
    IDENTIFIER      reduce using rule 474 (generic_formal -> WITH FUNCTION designator formal_part_opt RETURN name subp_default SEMICOLON .)


state 891

    (475) generic_formal -> WITH PACKAGE simple_name IS NEW name LPAREN BOX . RPAREN SEMICOLON

    RPAREN          shift and go to state 917


state 892

    (496) generic_derived_type -> ABSTRACT NEW subtype_ind WITH . PRIVATE

    PRIVATE         shift and go to state 918


state 893

    (495) generic_derived_type -> NEW subtype_ind WITH PRIVATE .

    SEMICOLON       reduce using rule 495 (generic_derived_type -> NEW subtype_ind WITH PRIVATE .)


state 894

    (488) generic_type_def -> DELTA BOX DIGITS BOX .

    SEMICOLON       reduce using rule 488 (generic_type_def -> DELTA BOX DIGITS BOX .)


state 895

    (392) entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN . condition entry_body_part
    (274) condition -> . expression
    (195) expression -> . relation
    (196) expression -> . expression logical relation
    (197) expression -> . expression short_circuit relation
    (203) relation -> . simple_expression
    (204) relation -> . simple_expression relational simple_expression
    (205) relation -> . simple_expression membership range
    (206) relation -> . simple_expression membership name
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    relation                       shift and go to state 127
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 119
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    allocator                      shift and go to state 132
    factor                         shift and go to state 136
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    condition                      shift and go to state 919
    term                           shift and go to state 144
    name                           shift and go to state 145
    operator_symbol                shift and go to state 146
    expression                     shift and go to state 470

state 896

    (393) entry_body -> ENTRY IDENTIFIER LPAREN iter_part . discrete_range RPAREN formal_part_opt WHEN condition entry_body_part
    (91) discrete_range -> . name range_constr_opt
    (92) discrete_range -> . range
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (60) range -> . simple_expression DOUBLEDOT simple_expression
    (61) range -> . name TICK RANGE
    (62) range -> . name TICK RANGE LPAREN expression RPAREN
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN

    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137
    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    simple_expression              shift and go to state 356
    indexed_comp                   shift and go to state 119
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    allocator                      shift and go to state 132
    factor                         shift and go to state 136
    parenthesized_primary          shift and go to state 141
    discrete_range                 shift and go to state 920
    aggregate                      shift and go to state 126
    term                           shift and go to state 144
    name                           shift and go to state 684
    operator_symbol                shift and go to state 146
    range                          shift and go to state 685
    qualified                      shift and go to state 147

state 897

    (108) comp_decl -> def_id_s COLON component_subtype_def . init_opt SEMICOLON
    (33) init_opt -> .
    (34) init_opt -> . IS_ASSIGNED expression

    SEMICOLON       reduce using rule 33 (init_opt -> .)
    IS_ASSIGNED     shift and go to state 637

    init_opt                       shift and go to state 921

state 898

    (391) entry_decl -> ENTRY IDENTIFIER LPAREN discrete_range RPAREN . formal_part_opt SEMICOLON
    (318) formal_part_opt -> .
    (319) formal_part_opt -> . formal_part
    (320) formal_part -> . LPAREN param_s RPAREN

    SEMICOLON       reduce using rule 318 (formal_part_opt -> .)
    LPAREN          shift and go to state 164

    formal_part                    shift and go to state 162
    formal_part_opt                shift and go to state 922

state 899

    (422) cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT . SEMICOLON

    SEMICOLON       shift and go to state 923


state 900

    (421) timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END . SELECT SEMICOLON

    SELECT          shift and go to state 924


state 901

    (420) async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT . SEMICOLON

    SEMICOLON       shift and go to state 925


state 902

    (410) select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON .

    LLB             reduce using rule 410 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON .)
    error           reduce using rule 410 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON .)
    PRAGMA          reduce using rule 410 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON .)
    NULL            reduce using rule 410 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON .)
    EXIT            reduce using rule 410 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON .)
    RETURN          reduce using rule 410 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON .)
    GOTO            reduce using rule 410 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON .)
    DELAY           reduce using rule 410 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON .)
    ABORT           reduce using rule 410 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON .)
    RAISE           reduce using rule 410 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON .)
    REQUEUE         reduce using rule 410 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON .)
    IF              reduce using rule 410 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON .)
    CASE            reduce using rule 410 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON .)
    IDENTIFIER      reduce using rule 410 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON .)
    ACCEPT          reduce using rule 410 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON .)
    SELECT          reduce using rule 410 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON .)
    STRING          reduce using rule 410 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON .)
    WHILE           reduce using rule 410 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON .)
    DECLARE         reduce using rule 410 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON .)
    FOR             reduce using rule 410 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON .)
    LOOP            reduce using rule 410 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON .)
    BEGIN           reduce using rule 410 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON .)
    END             reduce using rule 410 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON .)
    WHEN            reduce using rule 410 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON .)
    OR              reduce using rule 410 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON .)
    ELSE            reduce using rule 410 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON .)
    ELSIF           reduce using rule 410 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON .)
    THEN            reduce using rule 410 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON .)
    EXCEPTION       reduce using rule 410 (select_wait -> SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON .)


state 903

    (459) exception_handler -> WHEN IDENTIFIER COLON except_choice_s ARROW . statement_s
    (243) statement_s -> . statement
    (244) statement_s -> . statement_s statement
    (245) statement -> . unlabeled
    (246) statement -> . label statement
    (247) unlabeled -> . simple_stmt
    (248) unlabeled -> . compound_stmt
    (249) unlabeled -> . pragma
    (268) label -> . LLB IDENTIFIER RLB
    (250) simple_stmt -> . NULL_stmt
    (251) simple_stmt -> . assign_stmt
    (252) simple_stmt -> . exit_stmt
    (253) simple_stmt -> . return_stmt
    (254) simple_stmt -> . goto_stmt
    (255) simple_stmt -> . procedure_call
    (256) simple_stmt -> . delay_stmt
    (257) simple_stmt -> . abort_stmt
    (258) simple_stmt -> . raise_stmt
    (259) simple_stmt -> . code_stmt
    (260) simple_stmt -> . requeue_stmt
    (261) simple_stmt -> . error SEMICOLON
    (262) compound_stmt -> . if_stmt
    (263) compound_stmt -> . case_stmt
    (264) compound_stmt -> . loop_stmt
    (265) compound_stmt -> . block
    (266) compound_stmt -> . accept_stmt
    (267) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (269) NULL_stmt -> . NULL SEMICOLON
    (270) assign_stmt -> . name IS_ASSIGNED expression SEMICOLON
    (302) exit_stmt -> . EXIT name_opt when_opt SEMICOLON
    (307) return_stmt -> . RETURN SEMICOLON
    (308) return_stmt -> . RETURN expression SEMICOLON
    (309) goto_stmt -> . GOTO name SEMICOLON
    (332) procedure_call -> . name SEMICOLON
    (404) delay_stmt -> . DELAY expression SEMICOLON
    (405) delay_stmt -> . DELAY UNTIL expression SEMICOLON
    (425) abort_stmt -> . ABORT name_s SEMICOLON
    (464) raise_stmt -> . RAISE name_opt SEMICOLON
    (510) code_stmt -> . qualified SEMICOLON
    (465) requeue_stmt -> . REQUEUE name SEMICOLON
    (466) requeue_stmt -> . REQUEUE name WITH ABORT SEMICOLON
    (271) if_stmt -> . IF cond_clause else_opt END IF SEMICOLON
    (278) case_stmt -> . case_hdr alternative_s END CASE SEMICOLON
    (283) loop_stmt -> . label_opt iteration basic_loop id_opt SEMICOLON
    (295) block -> . label_opt block_decl block_body END id_opt SEMICOLON
    (399) accept_stmt -> . accept_hdr SEMICOLON
    (400) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt SEMICOLON
    (406) select_stmt -> . select_wait
    (407) select_stmt -> . async_select
    (408) select_stmt -> . timed_entry_call
    (409) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (240) qualified -> . name TICK parenthesized_primary
    (279) case_hdr -> . CASE expression IS
    (284) label_opt -> .
    (285) label_opt -> . IDENTIFIER COLON
    (401) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (410) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON
    (420) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON
    (421) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON
    (422) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    LLB             shift and go to state 289
    error           shift and go to state 309
    PRAGMA          shift and go to state 4
    NULL            shift and go to state 311
    EXIT            shift and go to state 308
    RETURN          shift and go to state 295
    GOTO            shift and go to state 276
    DELAY           shift and go to state 272
    ABORT           shift and go to state 282
    RAISE           shift and go to state 306
    REQUEUE         shift and go to state 298
    IF              shift and go to state 317
    CASE            shift and go to state 297
    WHILE           reduce using rule 284 (label_opt -> .)
    DECLARE         reduce using rule 284 (label_opt -> .)
    FOR             reduce using rule 284 (label_opt -> .)
    LOOP            reduce using rule 284 (label_opt -> .)
    BEGIN           reduce using rule 284 (label_opt -> .)
    IDENTIFIER      shift and go to state 300
    ACCEPT          shift and go to state 284
    SELECT          shift and go to state 286
    STRING          shift and go to state 137

    indexed_comp                   shift and go to state 119
    accept_stmt                    shift and go to state 283
    label_opt                      shift and go to state 275
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 316
    abort_stmt                     shift and go to state 310
    return_stmt                    shift and go to state 294
    procedure_call                 shift and go to state 285
    assign_stmt                    shift and go to state 320
    statement_s                    shift and go to state 926
    simple_name                    shift and go to state 153
    code_stmt                      shift and go to state 313
    case_stmt                      shift and go to state 287
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 146
    label                          shift and go to state 288
    exit_stmt                      shift and go to state 315
    select_stmt                    shift and go to state 274
    statement                      shift and go to state 299
    compound_stmt                  shift and go to state 290
    case_hdr                       shift and go to state 292
    delay_stmt                     shift and go to state 301
    unlabeled                      shift and go to state 314
    simple_stmt                    shift and go to state 277
    loop_stmt                      shift and go to state 278
    qualified                      shift and go to state 279
    pragma                         shift and go to state 303
    async_select                   shift and go to state 273
    requeue_stmt                   shift and go to state 304
    raise_stmt                     shift and go to state 305
    name                           shift and go to state 281
    if_stmt                        shift and go to state 280
    accept_hdr                     shift and go to state 302
    cond_entry_call                shift and go to state 318
    timed_entry_call               shift and go to state 307
    goto_stmt                      shift and go to state 291
    NULL_stmt                      shift and go to state 319
    block                          shift and go to state 293

state 904

    (504) record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD SEMICOLON .

    error           reduce using rule 504 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD SEMICOLON .)
    USE             reduce using rule 504 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD SEMICOLON .)
    PRAGMA          reduce using rule 504 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD SEMICOLON .)
    TYPE            reduce using rule 504 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD SEMICOLON .)
    SUBTYPE         reduce using rule 504 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD SEMICOLON .)
    TASK            reduce using rule 504 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD SEMICOLON .)
    PACKAGE         reduce using rule 504 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD SEMICOLON .)
    PROTECTED       reduce using rule 504 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD SEMICOLON .)
    FOR             reduce using rule 504 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD SEMICOLON .)
    PROCEDURE       reduce using rule 504 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD SEMICOLON .)
    FUNCTION        reduce using rule 504 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD SEMICOLON .)
    GENERIC         reduce using rule 504 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD SEMICOLON .)
    IDENTIFIER      reduce using rule 504 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD SEMICOLON .)
    END             reduce using rule 504 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD SEMICOLON .)
    PRIVATE         reduce using rule 504 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD SEMICOLON .)
    BEGIN           reduce using rule 504 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD SEMICOLON .)
    ENTRY           reduce using rule 504 (record_type_spec -> FOR mark USE RECORD align_opt comp_loc_s END RECORD SEMICOLON .)


state 905

    (508) comp_loc_s -> comp_loc_s mark AT expression . RANGE range SEMICOLON
    (196) expression -> expression . logical relation
    (197) expression -> expression . short_circuit relation
    (198) logical -> . AND
    (199) logical -> . OR
    (200) logical -> . XOR
    (201) short_circuit -> . AND THEN
    (202) short_circuit -> . OR ELSE

    RANGE           shift and go to state 927
    AND             shift and go to state 244
    OR              shift and go to state 248
    XOR             shift and go to state 245

    logical                        shift and go to state 246
    short_circuit                  shift and go to state 247

state 906

    (365) task_body -> TASK BODY simple_name IS decl_part block_body END id_opt SEMICOLON .

    PACKAGE         reduce using rule 365 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt SEMICOLON .)
    TASK            reduce using rule 365 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt SEMICOLON .)
    PROTECTED       reduce using rule 365 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt SEMICOLON .)
    error           reduce using rule 365 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt SEMICOLON .)
    USE             reduce using rule 365 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt SEMICOLON .)
    PRAGMA          reduce using rule 365 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt SEMICOLON .)
    TYPE            reduce using rule 365 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt SEMICOLON .)
    SUBTYPE         reduce using rule 365 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt SEMICOLON .)
    FOR             reduce using rule 365 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt SEMICOLON .)
    PROCEDURE       reduce using rule 365 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt SEMICOLON .)
    FUNCTION        reduce using rule 365 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt SEMICOLON .)
    GENERIC         reduce using rule 365 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt SEMICOLON .)
    IDENTIFIER      reduce using rule 365 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt SEMICOLON .)
    BEGIN           reduce using rule 365 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt SEMICOLON .)
    END             reduce using rule 365 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt SEMICOLON .)
    PRIVATE         reduce using rule 365 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt SEMICOLON .)
    WITH            reduce using rule 365 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt SEMICOLON .)
    SEPARATE        reduce using rule 365 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt SEMICOLON .)
    $end            reduce using rule 365 (task_body -> TASK BODY simple_name IS decl_part block_body END id_opt SEMICOLON .)


state 907

    (117) variant_part -> CASE simple_name . IS variant_s END CASE SEMICOLON

    IS              shift and go to state 928


state 908

    (105) comp_decl_s -> comp_decl_s comp_decl .

    error           reduce using rule 105 (comp_decl_s -> comp_decl_s comp_decl .)
    CASE            reduce using rule 105 (comp_decl_s -> comp_decl_s comp_decl .)
    IDENTIFIER      reduce using rule 105 (comp_decl_s -> comp_decl_s comp_decl .)
    END             reduce using rule 105 (comp_decl_s -> comp_decl_s comp_decl .)
    WHEN            reduce using rule 105 (comp_decl_s -> comp_decl_s comp_decl .)


state 909

    (107) variant_part_opt -> variant_part .

    END             reduce using rule 107 (variant_part_opt -> variant_part .)
    WHEN            reduce using rule 107 (variant_part_opt -> variant_part .)


state 910

    (101) comp_list -> comp_decl_s variant_part_opt .

    END             reduce using rule 101 (comp_list -> comp_decl_s variant_part_opt .)
    WHEN            reduce using rule 101 (comp_list -> comp_decl_s variant_part_opt .)


state 911

    (96) record_def -> RECORD comp_list END . RECORD

    RECORD          shift and go to state 929


state 912

    (103) comp_list -> NULL SEMICOLON .

    END             reduce using rule 103 (comp_list -> NULL SEMICOLON .)
    WHEN            reduce using rule 103 (comp_list -> NULL SEMICOLON .)


state 913

    (77) fixed_type -> DELTA expression DIGITS expression range_spec_opt .

    SEMICOLON       reduce using rule 77 (fixed_type -> DELTA expression DIGITS expression range_spec_opt .)


state 914

    (132) access_type -> ACCESS prot_opt FUNCTION formal_part_opt RETURN . mark
    (158) mark -> . simple_name
    (159) mark -> . mark TICK attribute_id
    (160) mark -> . mark DOT simple_name
    (161) simple_name -> . IDENTIFIER

    IDENTIFIER      shift and go to state 40

    simple_name                    shift and go to state 171
    mark                           shift and go to state 930

state 915

    (80) unconstr_array_type -> ARRAY LPAREN index_s RPAREN OF component_subtype_def .

    IS_ASSIGNED     reduce using rule 80 (unconstr_array_type -> ARRAY LPAREN index_s RPAREN OF component_subtype_def .)
    SEMICOLON       reduce using rule 80 (unconstr_array_type -> ARRAY LPAREN index_s RPAREN OF component_subtype_def .)


state 916

    (87) index -> name RANGE . BOX

    BOX             shift and go to state 889


state 917

    (475) generic_formal -> WITH PACKAGE simple_name IS NEW name LPAREN BOX RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 931


state 918

    (496) generic_derived_type -> ABSTRACT NEW subtype_ind WITH PRIVATE .

    SEMICOLON       reduce using rule 496 (generic_derived_type -> ABSTRACT NEW subtype_ind WITH PRIVATE .)


state 919

    (392) entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN condition . entry_body_part
    (394) entry_body_part -> . SEMICOLON
    (395) entry_body_part -> . IS decl_part block_body END id_opt SEMICOLON

    SEMICOLON       shift and go to state 932
    IS              shift and go to state 934

    entry_body_part                shift and go to state 933

state 920

    (393) entry_body -> ENTRY IDENTIFIER LPAREN iter_part discrete_range . RPAREN formal_part_opt WHEN condition entry_body_part

    RPAREN          shift and go to state 935


state 921

    (108) comp_decl -> def_id_s COLON component_subtype_def init_opt . SEMICOLON

    SEMICOLON       shift and go to state 936


state 922

    (391) entry_decl -> ENTRY IDENTIFIER LPAREN discrete_range RPAREN formal_part_opt . SEMICOLON

    SEMICOLON       shift and go to state 937


state 923

    (422) cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON .

    LLB             reduce using rule 422 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON .)
    error           reduce using rule 422 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON .)
    PRAGMA          reduce using rule 422 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON .)
    NULL            reduce using rule 422 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON .)
    EXIT            reduce using rule 422 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON .)
    RETURN          reduce using rule 422 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON .)
    GOTO            reduce using rule 422 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON .)
    DELAY           reduce using rule 422 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON .)
    ABORT           reduce using rule 422 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON .)
    RAISE           reduce using rule 422 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON .)
    REQUEUE         reduce using rule 422 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON .)
    IF              reduce using rule 422 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON .)
    CASE            reduce using rule 422 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON .)
    IDENTIFIER      reduce using rule 422 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON .)
    ACCEPT          reduce using rule 422 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON .)
    SELECT          reduce using rule 422 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON .)
    STRING          reduce using rule 422 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON .)
    WHILE           reduce using rule 422 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON .)
    DECLARE         reduce using rule 422 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON .)
    FOR             reduce using rule 422 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON .)
    LOOP            reduce using rule 422 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON .)
    BEGIN           reduce using rule 422 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON .)
    OR              reduce using rule 422 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON .)
    ELSE            reduce using rule 422 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON .)
    ELSIF           reduce using rule 422 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON .)
    END             reduce using rule 422 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON .)
    EXCEPTION       reduce using rule 422 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON .)
    WHEN            reduce using rule 422 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON .)
    THEN            reduce using rule 422 (cond_entry_call -> SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON .)


state 924

    (421) timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT . SEMICOLON

    SEMICOLON       shift and go to state 938


state 925

    (420) async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON .

    LLB             reduce using rule 420 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON .)
    error           reduce using rule 420 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON .)
    PRAGMA          reduce using rule 420 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON .)
    NULL            reduce using rule 420 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON .)
    EXIT            reduce using rule 420 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON .)
    RETURN          reduce using rule 420 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON .)
    GOTO            reduce using rule 420 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON .)
    DELAY           reduce using rule 420 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON .)
    ABORT           reduce using rule 420 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON .)
    RAISE           reduce using rule 420 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON .)
    REQUEUE         reduce using rule 420 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON .)
    IF              reduce using rule 420 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON .)
    CASE            reduce using rule 420 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON .)
    IDENTIFIER      reduce using rule 420 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON .)
    ACCEPT          reduce using rule 420 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON .)
    SELECT          reduce using rule 420 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON .)
    STRING          reduce using rule 420 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON .)
    WHILE           reduce using rule 420 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON .)
    DECLARE         reduce using rule 420 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON .)
    FOR             reduce using rule 420 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON .)
    LOOP            reduce using rule 420 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON .)
    BEGIN           reduce using rule 420 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON .)
    END             reduce using rule 420 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON .)
    ELSE            reduce using rule 420 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON .)
    ELSIF           reduce using rule 420 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON .)
    EXCEPTION       reduce using rule 420 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON .)
    WHEN            reduce using rule 420 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON .)
    OR              reduce using rule 420 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON .)
    THEN            reduce using rule 420 (async_select -> SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON .)


state 926

    (459) exception_handler -> WHEN IDENTIFIER COLON except_choice_s ARROW statement_s .
    (244) statement_s -> statement_s . statement
    (245) statement -> . unlabeled
    (246) statement -> . label statement
    (247) unlabeled -> . simple_stmt
    (248) unlabeled -> . compound_stmt
    (249) unlabeled -> . pragma
    (268) label -> . LLB IDENTIFIER RLB
    (250) simple_stmt -> . NULL_stmt
    (251) simple_stmt -> . assign_stmt
    (252) simple_stmt -> . exit_stmt
    (253) simple_stmt -> . return_stmt
    (254) simple_stmt -> . goto_stmt
    (255) simple_stmt -> . procedure_call
    (256) simple_stmt -> . delay_stmt
    (257) simple_stmt -> . abort_stmt
    (258) simple_stmt -> . raise_stmt
    (259) simple_stmt -> . code_stmt
    (260) simple_stmt -> . requeue_stmt
    (261) simple_stmt -> . error SEMICOLON
    (262) compound_stmt -> . if_stmt
    (263) compound_stmt -> . case_stmt
    (264) compound_stmt -> . loop_stmt
    (265) compound_stmt -> . block
    (266) compound_stmt -> . accept_stmt
    (267) compound_stmt -> . select_stmt
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (269) NULL_stmt -> . NULL SEMICOLON
    (270) assign_stmt -> . name IS_ASSIGNED expression SEMICOLON
    (302) exit_stmt -> . EXIT name_opt when_opt SEMICOLON
    (307) return_stmt -> . RETURN SEMICOLON
    (308) return_stmt -> . RETURN expression SEMICOLON
    (309) goto_stmt -> . GOTO name SEMICOLON
    (332) procedure_call -> . name SEMICOLON
    (404) delay_stmt -> . DELAY expression SEMICOLON
    (405) delay_stmt -> . DELAY UNTIL expression SEMICOLON
    (425) abort_stmt -> . ABORT name_s SEMICOLON
    (464) raise_stmt -> . RAISE name_opt SEMICOLON
    (510) code_stmt -> . qualified SEMICOLON
    (465) requeue_stmt -> . REQUEUE name SEMICOLON
    (466) requeue_stmt -> . REQUEUE name WITH ABORT SEMICOLON
    (271) if_stmt -> . IF cond_clause else_opt END IF SEMICOLON
    (278) case_stmt -> . case_hdr alternative_s END CASE SEMICOLON
    (283) loop_stmt -> . label_opt iteration basic_loop id_opt SEMICOLON
    (295) block -> . label_opt block_decl block_body END id_opt SEMICOLON
    (399) accept_stmt -> . accept_hdr SEMICOLON
    (400) accept_stmt -> . accept_hdr DO handled_stmt_s END id_opt SEMICOLON
    (406) select_stmt -> . select_wait
    (407) select_stmt -> . async_select
    (408) select_stmt -> . timed_entry_call
    (409) select_stmt -> . cond_entry_call
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (240) qualified -> . name TICK parenthesized_primary
    (279) case_hdr -> . CASE expression IS
    (284) label_opt -> .
    (285) label_opt -> . IDENTIFIER COLON
    (401) accept_hdr -> . ACCEPT entry_name formal_part_opt
    (410) select_wait -> . SELECT guarded_select_alt or_select else_opt END SELECT SEMICOLON
    (420) async_select -> . SELECT delay_or_entry_alt THEN ABORT statement_s END SELECT SEMICOLON
    (421) timed_entry_call -> . SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON
    (422) cond_entry_call -> . SELECT entry_call stmts_opt ELSE statement_s END SELECT SEMICOLON
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    WHEN            reduce using rule 459 (exception_handler -> WHEN IDENTIFIER COLON except_choice_s ARROW statement_s .)
    END             reduce using rule 459 (exception_handler -> WHEN IDENTIFIER COLON except_choice_s ARROW statement_s .)
    LLB             shift and go to state 289
    error           shift and go to state 309
    PRAGMA          shift and go to state 4
    NULL            shift and go to state 311
    EXIT            shift and go to state 308
    RETURN          shift and go to state 295
    GOTO            shift and go to state 276
    DELAY           shift and go to state 272
    ABORT           shift and go to state 282
    RAISE           shift and go to state 306
    REQUEUE         shift and go to state 298
    IF              shift and go to state 317
    CASE            shift and go to state 297
    WHILE           reduce using rule 284 (label_opt -> .)
    DECLARE         reduce using rule 284 (label_opt -> .)
    FOR             reduce using rule 284 (label_opt -> .)
    LOOP            reduce using rule 284 (label_opt -> .)
    BEGIN           reduce using rule 284 (label_opt -> .)
    IDENTIFIER      shift and go to state 300
    ACCEPT          shift and go to state 284
    SELECT          shift and go to state 286
    STRING          shift and go to state 137

    indexed_comp                   shift and go to state 119
    accept_stmt                    shift and go to state 283
    label_opt                      shift and go to state 275
    attribute                      shift and go to state 121
    select_wait                    shift and go to state 316
    abort_stmt                     shift and go to state 310
    return_stmt                    shift and go to state 294
    procedure_call                 shift and go to state 285
    assign_stmt                    shift and go to state 320
    simple_name                    shift and go to state 153
    code_stmt                      shift and go to state 313
    case_stmt                      shift and go to state 287
    selected_comp                  shift and go to state 120
    operator_symbol                shift and go to state 146
    label                          shift and go to state 288
    exit_stmt                      shift and go to state 315
    select_stmt                    shift and go to state 274
    statement                      shift and go to state 465
    compound_stmt                  shift and go to state 290
    case_hdr                       shift and go to state 292
    delay_stmt                     shift and go to state 301
    unlabeled                      shift and go to state 314
    simple_stmt                    shift and go to state 277
    loop_stmt                      shift and go to state 278
    qualified                      shift and go to state 279
    pragma                         shift and go to state 303
    async_select                   shift and go to state 273
    requeue_stmt                   shift and go to state 304
    raise_stmt                     shift and go to state 305
    name                           shift and go to state 281
    if_stmt                        shift and go to state 280
    accept_hdr                     shift and go to state 302
    cond_entry_call                shift and go to state 318
    timed_entry_call               shift and go to state 307
    goto_stmt                      shift and go to state 291
    NULL_stmt                      shift and go to state 319
    block                          shift and go to state 293

state 927

    (508) comp_loc_s -> comp_loc_s mark AT expression RANGE . range SEMICOLON
    (60) range -> . simple_expression DOUBLEDOT simple_expression
    (61) range -> . name TICK RANGE
    (62) range -> . name TICK RANGE LPAREN expression RPAREN
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN

    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    simple_expression              shift and go to state 356
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    factor                         shift and go to state 136
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    term                           shift and go to state 144
    name                           shift and go to state 519
    operator_symbol                shift and go to state 146
    range                          shift and go to state 939

state 928

    (117) variant_part -> CASE simple_name IS . variant_s END CASE SEMICOLON
    (118) variant_s -> . variant
    (119) variant_s -> . variant_s variant
    (120) variant -> . WHEN choice_s ARROW comp_list

    WHEN            shift and go to state 941

    variant_s                      shift and go to state 940
    variant                        shift and go to state 942

state 929

    (96) record_def -> RECORD comp_list END RECORD .

    SEMICOLON       reduce using rule 96 (record_def -> RECORD comp_list END RECORD .)


state 930

    (132) access_type -> ACCESS prot_opt FUNCTION formal_part_opt RETURN mark .
    (159) mark -> mark . TICK attribute_id
    (160) mark -> mark . DOT simple_name

    SEMICOLON       reduce using rule 132 (access_type -> ACCESS prot_opt FUNCTION formal_part_opt RETURN mark .)
    TICK            shift and go to state 323
    DOT             shift and go to state 324


state 931

    (475) generic_formal -> WITH PACKAGE simple_name IS NEW name LPAREN BOX RPAREN SEMICOLON .

    PACKAGE         reduce using rule 475 (generic_formal -> WITH PACKAGE simple_name IS NEW name LPAREN BOX RPAREN SEMICOLON .)
    PROCEDURE       reduce using rule 475 (generic_formal -> WITH PACKAGE simple_name IS NEW name LPAREN BOX RPAREN SEMICOLON .)
    FUNCTION        reduce using rule 475 (generic_formal -> WITH PACKAGE simple_name IS NEW name LPAREN BOX RPAREN SEMICOLON .)
    TYPE            reduce using rule 475 (generic_formal -> WITH PACKAGE simple_name IS NEW name LPAREN BOX RPAREN SEMICOLON .)
    WITH            reduce using rule 475 (generic_formal -> WITH PACKAGE simple_name IS NEW name LPAREN BOX RPAREN SEMICOLON .)
    error           reduce using rule 475 (generic_formal -> WITH PACKAGE simple_name IS NEW name LPAREN BOX RPAREN SEMICOLON .)
    USE             reduce using rule 475 (generic_formal -> WITH PACKAGE simple_name IS NEW name LPAREN BOX RPAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 475 (generic_formal -> WITH PACKAGE simple_name IS NEW name LPAREN BOX RPAREN SEMICOLON .)


state 932

    (394) entry_body_part -> SEMICOLON .

    PRAGMA          reduce using rule 394 (entry_body_part -> SEMICOLON .)
    END             reduce using rule 394 (entry_body_part -> SEMICOLON .)
    ENTRY           reduce using rule 394 (entry_body_part -> SEMICOLON .)
    PROCEDURE       reduce using rule 394 (entry_body_part -> SEMICOLON .)
    FUNCTION        reduce using rule 394 (entry_body_part -> SEMICOLON .)


state 933

    (392) entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN condition entry_body_part .

    PRAGMA          reduce using rule 392 (entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN condition entry_body_part .)
    END             reduce using rule 392 (entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN condition entry_body_part .)
    ENTRY           reduce using rule 392 (entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN condition entry_body_part .)
    PROCEDURE       reduce using rule 392 (entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN condition entry_body_part .)
    FUNCTION        reduce using rule 392 (entry_body -> ENTRY IDENTIFIER formal_part_opt WHEN condition entry_body_part .)


state 934

    (395) entry_body_part -> IS . decl_part block_body END id_opt SEMICOLON
    (135) decl_part -> .
    (136) decl_part -> . decl_item_or_body_s1
    (145) decl_item_or_body_s1 -> . decl_item_or_body
    (146) decl_item_or_body_s1 -> . decl_item_or_body_s1 decl_item_or_body
    (147) decl_item_or_body -> . body
    (148) decl_item_or_body -> . decl_item
    (149) body -> . subprog_body
    (150) body -> . pkg_body
    (151) body -> . task_body
    (152) body -> . prot_body
    (141) decl_item -> . decl
    (142) decl_item -> . use_clause
    (143) decl_item -> . rep_spec
    (144) decl_item -> . pragma
    (331) subprog_body -> . subprog_spec_is_push decl_part block_body END id_opt SEMICOLON
    (340) pkg_body -> . PACKAGE BODY compound_name IS decl_part body_opt END c_id_opt SEMICOLON
    (365) task_body -> . TASK BODY simple_name IS decl_part block_body END id_opt SEMICOLON
    (382) prot_body -> . PROTECTED BODY simple_name IS prot_op_body_s END id_opt SEMICOLON
    (10) decl -> . object_decl
    (11) decl -> . number_decl
    (12) decl -> . type_decl
    (13) decl -> . subtype_decl
    (14) decl -> . subprog_decl
    (15) decl -> . pkg_decl
    (16) decl -> . task_decl
    (17) decl -> . prot_decl
    (18) decl -> . exception_decl
    (19) decl -> . rename_decl
    (20) decl -> . generic_decl
    (21) decl -> . body_stub
    (22) decl -> . error SEMICOLON
    (346) use_clause -> . USE name_s SEMICOLON
    (347) use_clause -> . USE TYPE name_s SEMICOLON
    (500) rep_spec -> . attrib_def
    (501) rep_spec -> . record_type_spec
    (502) rep_spec -> . address_spec
    (2) pragma -> . PRAGMA IDENTIFIER SEMICOLON
    (3) pragma -> . PRAGMA simple_name LPAREN pragma_arg_s RPAREN SEMICOLON
    (330) subprog_spec_is_push -> . subprog_spec IS
    (23) object_decl -> . def_id_s COLON object_qualifier_opt object_subtype_def init_opt SEMICOLON
    (35) number_decl -> . def_id_s COLON CONSTANT IS_ASSIGNED expression SEMICOLON
    (36) type_decl -> . TYPE IDENTIFIER discrim_part_opt type_completion SEMICOLON
    (48) subtype_decl -> . SUBTYPE IDENTIFIER IS subtype_ind SEMICOLON
    (310) subprog_decl -> . subprog_spec SEMICOLON
    (311) subprog_decl -> . generic_subp_inst SEMICOLON
    (312) subprog_decl -> . subprog_spec_is_push ABSTRACT SEMICOLON
    (333) pkg_decl -> . pkg_spec SEMICOLON
    (334) pkg_decl -> . generic_pkg_inst SEMICOLON
    (358) task_decl -> . task_spec SEMICOLON
    (366) prot_decl -> . prot_spec SEMICOLON
    (455) exception_decl -> . def_id_s COLON EXCEPTION SEMICOLON
    (350) rename_decl -> . def_id_s COLON object_qualifier_opt subtype_ind renames SEMICOLON
    (351) rename_decl -> . def_id_s COLON EXCEPTION renames SEMICOLON
    (352) rename_decl -> . rename_unit
    (467) generic_decl -> . generic_formal_part subprog_spec SEMICOLON
    (468) generic_decl -> . generic_formal_part pkg_spec SEMICOLON
    (451) body_stub -> . TASK BODY simple_name IS SEPARATE SEMICOLON
    (452) body_stub -> . PACKAGE BODY compound_name IS SEPARATE SEMICOLON
    (453) body_stub -> . subprog_spec IS SEPARATE SEMICOLON
    (454) body_stub -> . PROTECTED BODY simple_name IS SEPARATE SEMICOLON
    (503) attrib_def -> . FOR mark USE expression SEMICOLON
    (504) record_type_spec -> . FOR mark USE RECORD align_opt comp_loc_s END RECORD SEMICOLON
    (509) address_spec -> . FOR mark USE AT expression SEMICOLON
    (313) subprog_spec -> . PROCEDURE compound_name formal_part_opt
    (314) subprog_spec -> . FUNCTION designator formal_part_opt RETURN name
    (315) subprog_spec -> . FUNCTION designator
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s COMMA def_id
    (497) generic_subp_inst -> . subprog_spec IS generic_inst
    (335) pkg_spec -> . PACKAGE compound_name IS decl_item_s private_part END c_id_opt
    (498) generic_pkg_inst -> . PACKAGE compound_name IS generic_inst
    (359) task_spec -> . TASK simple_name task_def
    (360) task_spec -> . TASK TYPE simple_name discrim_part_opt task_def
    (367) prot_spec -> . PROTECTED IDENTIFIER prot_def
    (368) prot_spec -> . PROTECTED TYPE simple_name discrim_part_opt prot_def
    (353) rename_unit -> . PACKAGE compound_name renames SEMICOLON
    (354) rename_unit -> . subprog_spec renames SEMICOLON
    (355) rename_unit -> . generic_formal_part PACKAGE compound_name renames SEMICOLON
    (356) rename_unit -> . generic_formal_part subprog_spec renames SEMICOLON
    (469) generic_formal_part -> . GENERIC
    (470) generic_formal_part -> . generic_formal_part generic_formal
    (26) def_id -> . IDENTIFIER

    BEGIN           reduce using rule 135 (decl_part -> .)
    PACKAGE         shift and go to state 80
    TASK            shift and go to state 74
    PROTECTED       shift and go to state 58
    error           shift and go to state 85
    USE             shift and go to state 46
    PRAGMA          shift and go to state 4
    TYPE            shift and go to state 87
    SUBTYPE         shift and go to state 91
    FOR             shift and go to state 70
    PROCEDURE       shift and go to state 30
    FUNCTION        shift and go to state 36
    GENERIC         shift and go to state 21
    IDENTIFIER      shift and go to state 79

    decl                           shift and go to state 57
    subprog_body                   shift and go to state 66
    task_decl                      shift and go to state 67
    type_decl                      shift and go to state 63
    rep_spec                       shift and go to state 89
    task_body                      shift and go to state 90
    subtype_decl                   shift and go to state 68
    exception_decl                 shift and go to state 92
    address_spec                   shift and go to state 59
    subprog_spec_is_push           shift and go to state 93
    decl_part                      shift and go to state 943
    prot_decl                      shift and go to state 62
    record_type_spec               shift and go to state 75
    generic_decl                   shift and go to state 76
    def_id                         shift and go to state 96
    attrib_def                     shift and go to state 77
    subprog_spec                   shift and go to state 94
    def_id_s                       shift and go to state 95
    decl_item_or_body_s1           shift and go to state 78
    decl_item                      shift and go to state 60
    task_spec                      shift and go to state 72
    body                           shift and go to state 69
    object_decl                    shift and go to state 71
    body_stub                      shift and go to state 81
    pkg_spec                       shift and go to state 37
    rename_decl                    shift and go to state 97
    generic_subp_inst              shift and go to state 28
    pragma                         shift and go to state 82
    rename_unit                    shift and go to state 98
    subprog_decl                   shift and go to state 65
    pkg_decl                       shift and go to state 64
    prot_spec                      shift and go to state 83
    generic_formal_part            shift and go to state 33
    prot_body                      shift and go to state 99
    use_clause                     shift and go to state 73
    generic_pkg_inst               shift and go to state 34
    pkg_body                       shift and go to state 84
    decl_item_or_body              shift and go to state 86
    number_decl                    shift and go to state 100

state 935

    (393) entry_body -> ENTRY IDENTIFIER LPAREN iter_part discrete_range RPAREN . formal_part_opt WHEN condition entry_body_part
    (318) formal_part_opt -> .
    (319) formal_part_opt -> . formal_part
    (320) formal_part -> . LPAREN param_s RPAREN

    WHEN            reduce using rule 318 (formal_part_opt -> .)
    LPAREN          shift and go to state 164

    formal_part                    shift and go to state 162
    formal_part_opt                shift and go to state 944

state 936

    (108) comp_decl -> def_id_s COLON component_subtype_def init_opt SEMICOLON .

    error           reduce using rule 108 (comp_decl -> def_id_s COLON component_subtype_def init_opt SEMICOLON .)
    CASE            reduce using rule 108 (comp_decl -> def_id_s COLON component_subtype_def init_opt SEMICOLON .)
    IDENTIFIER      reduce using rule 108 (comp_decl -> def_id_s COLON component_subtype_def init_opt SEMICOLON .)
    END             reduce using rule 108 (comp_decl -> def_id_s COLON component_subtype_def init_opt SEMICOLON .)
    WHEN            reduce using rule 108 (comp_decl -> def_id_s COLON component_subtype_def init_opt SEMICOLON .)
    ENTRY           reduce using rule 108 (comp_decl -> def_id_s COLON component_subtype_def init_opt SEMICOLON .)
    PROCEDURE       reduce using rule 108 (comp_decl -> def_id_s COLON component_subtype_def init_opt SEMICOLON .)
    FUNCTION        reduce using rule 108 (comp_decl -> def_id_s COLON component_subtype_def init_opt SEMICOLON .)
    PRAGMA          reduce using rule 108 (comp_decl -> def_id_s COLON component_subtype_def init_opt SEMICOLON .)
    FOR             reduce using rule 108 (comp_decl -> def_id_s COLON component_subtype_def init_opt SEMICOLON .)


state 937

    (391) entry_decl -> ENTRY IDENTIFIER LPAREN discrete_range RPAREN formal_part_opt SEMICOLON .

    error           reduce using rule 391 (entry_decl -> ENTRY IDENTIFIER LPAREN discrete_range RPAREN formal_part_opt SEMICOLON .)
    ENTRY           reduce using rule 391 (entry_decl -> ENTRY IDENTIFIER LPAREN discrete_range RPAREN formal_part_opt SEMICOLON .)
    PROCEDURE       reduce using rule 391 (entry_decl -> ENTRY IDENTIFIER LPAREN discrete_range RPAREN formal_part_opt SEMICOLON .)
    FUNCTION        reduce using rule 391 (entry_decl -> ENTRY IDENTIFIER LPAREN discrete_range RPAREN formal_part_opt SEMICOLON .)
    PRAGMA          reduce using rule 391 (entry_decl -> ENTRY IDENTIFIER LPAREN discrete_range RPAREN formal_part_opt SEMICOLON .)
    FOR             reduce using rule 391 (entry_decl -> ENTRY IDENTIFIER LPAREN discrete_range RPAREN formal_part_opt SEMICOLON .)
    IDENTIFIER      reduce using rule 391 (entry_decl -> ENTRY IDENTIFIER LPAREN discrete_range RPAREN formal_part_opt SEMICOLON .)
    END             reduce using rule 391 (entry_decl -> ENTRY IDENTIFIER LPAREN discrete_range RPAREN formal_part_opt SEMICOLON .)
    PRIVATE         reduce using rule 391 (entry_decl -> ENTRY IDENTIFIER LPAREN discrete_range RPAREN formal_part_opt SEMICOLON .)


state 938

    (421) timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON .

    LLB             reduce using rule 421 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON .)
    error           reduce using rule 421 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON .)
    PRAGMA          reduce using rule 421 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON .)
    NULL            reduce using rule 421 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON .)
    EXIT            reduce using rule 421 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON .)
    RETURN          reduce using rule 421 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON .)
    GOTO            reduce using rule 421 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON .)
    DELAY           reduce using rule 421 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON .)
    ABORT           reduce using rule 421 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON .)
    RAISE           reduce using rule 421 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON .)
    REQUEUE         reduce using rule 421 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON .)
    IF              reduce using rule 421 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON .)
    CASE            reduce using rule 421 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON .)
    IDENTIFIER      reduce using rule 421 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON .)
    ACCEPT          reduce using rule 421 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON .)
    SELECT          reduce using rule 421 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON .)
    STRING          reduce using rule 421 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON .)
    WHILE           reduce using rule 421 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON .)
    DECLARE         reduce using rule 421 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON .)
    FOR             reduce using rule 421 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON .)
    LOOP            reduce using rule 421 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON .)
    BEGIN           reduce using rule 421 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON .)
    WHEN            reduce using rule 421 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON .)
    END             reduce using rule 421 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON .)
    EXCEPTION       reduce using rule 421 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON .)
    OR              reduce using rule 421 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON .)
    ELSE            reduce using rule 421 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON .)
    THEN            reduce using rule 421 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON .)
    ELSIF           reduce using rule 421 (timed_entry_call -> SELECT entry_call stmts_opt OR delay_stmt stmts_opt END SELECT SEMICOLON .)


state 939

    (508) comp_loc_s -> comp_loc_s mark AT expression RANGE range . SEMICOLON

    SEMICOLON       shift and go to state 945


state 940

    (117) variant_part -> CASE simple_name IS variant_s . END CASE SEMICOLON
    (119) variant_s -> variant_s . variant
    (120) variant -> . WHEN choice_s ARROW comp_list

    END             shift and go to state 946
    WHEN            shift and go to state 941

    variant                        shift and go to state 947

state 941

    (120) variant -> WHEN . choice_s ARROW comp_list
    (121) choice_s -> . choice
    (122) choice_s -> . choice_s | choice
    (123) choice -> . expression
    (124) choice -> . discrete_with_range
    (125) choice -> . OTHERS
    (195) expression -> . relation
    (196) expression -> . expression logical relation
    (197) expression -> . expression short_circuit relation
    (126) discrete_with_range -> . name range_constraint
    (127) discrete_with_range -> . range
    (203) relation -> . simple_expression
    (204) relation -> . simple_expression relational simple_expression
    (205) relation -> . simple_expression membership range
    (206) relation -> . simple_expression membership name
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (60) range -> . simple_expression DOUBLEDOT simple_expression
    (61) range -> . name TICK RANGE
    (62) range -> . name TICK RANGE LPAREN expression RPAREN
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN

    OTHERS          shift and go to state 222
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137
    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    relation                       shift and go to state 127
    simple_expression              shift and go to state 379
    indexed_comp                   shift and go to state 119
    allocator                      shift and go to state 132
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    choice_s                       shift and go to state 948
    factor                         shift and go to state 136
    choice                         shift and go to state 227
    qualified                      shift and go to state 147
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    discrete_with_range            shift and go to state 515
    term                           shift and go to state 144
    name                           shift and go to state 230
    operator_symbol                shift and go to state 146
    range                          shift and go to state 232
    expression                     shift and go to state 516

state 942

    (118) variant_s -> variant .

    END             reduce using rule 118 (variant_s -> variant .)
    WHEN            reduce using rule 118 (variant_s -> variant .)


state 943

    (395) entry_body_part -> IS decl_part . block_body END id_opt SEMICOLON
    (298) block_body -> . BEGIN handled_stmt_s

    BEGIN           shift and go to state 168

    block_body                     shift and go to state 949

state 944

    (393) entry_body -> ENTRY IDENTIFIER LPAREN iter_part discrete_range RPAREN formal_part_opt . WHEN condition entry_body_part

    WHEN            shift and go to state 950


state 945

    (508) comp_loc_s -> comp_loc_s mark AT expression RANGE range SEMICOLON .

    END             reduce using rule 508 (comp_loc_s -> comp_loc_s mark AT expression RANGE range SEMICOLON .)
    IDENTIFIER      reduce using rule 508 (comp_loc_s -> comp_loc_s mark AT expression RANGE range SEMICOLON .)


state 946

    (117) variant_part -> CASE simple_name IS variant_s END . CASE SEMICOLON

    CASE            shift and go to state 951


state 947

    (119) variant_s -> variant_s variant .

    END             reduce using rule 119 (variant_s -> variant_s variant .)
    WHEN            reduce using rule 119 (variant_s -> variant_s variant .)


state 948

    (120) variant -> WHEN choice_s . ARROW comp_list
    (122) choice_s -> choice_s . | choice

    ARROW           shift and go to state 952
    |               shift and go to state 366


state 949

    (395) entry_body_part -> IS decl_part block_body . END id_opt SEMICOLON

    END             shift and go to state 953


state 950

    (393) entry_body -> ENTRY IDENTIFIER LPAREN iter_part discrete_range RPAREN formal_part_opt WHEN . condition entry_body_part
    (274) condition -> . expression
    (195) expression -> . relation
    (196) expression -> . expression logical relation
    (197) expression -> . expression short_circuit relation
    (203) relation -> . simple_expression
    (204) relation -> . simple_expression relational simple_expression
    (205) relation -> . simple_expression membership range
    (206) relation -> . simple_expression membership name
    (215) simple_expression -> . unary term
    (216) simple_expression -> . term
    (217) simple_expression -> . simple_expression adding term
    (218) unary -> . PLUS
    (219) unary -> . MINUS
    (223) term -> . factor
    (224) term -> . term multiplying factor
    (229) factor -> . primary
    (230) factor -> . NOT primary
    (231) factor -> . ABS primary
    (232) factor -> . primary POW primary
    (233) primary -> . literal
    (234) primary -> . allocator
    (235) primary -> . qualified
    (236) primary -> . parenthesized_primary
    (237) primary -> . name
    (184) literal -> . NUMBER
    (185) literal -> . used_char
    (186) literal -> . NULL
    (241) allocator -> . NEW name
    (242) allocator -> . NEW qualified
    (240) qualified -> . name TICK parenthesized_primary
    (238) parenthesized_primary -> . aggregate
    (239) parenthesized_primary -> . LPAREN expression RPAREN
    (153) name -> . simple_name
    (154) name -> . indexed_comp
    (155) name -> . selected_comp
    (156) name -> . attribute
    (157) name -> . operator_symbol
    (166) used_char -> . CHARACTER
    (187) aggregate -> . LPAREN comp_assoc RPAREN
    (188) aggregate -> . LPAREN value_s_2 RPAREN
    (189) aggregate -> . LPAREN expression WITH value_s RPAREN
    (190) aggregate -> . LPAREN expression WITH NULL RECORD RPAREN
    (191) aggregate -> . LPAREN NULL RECORD RPAREN
    (161) simple_name -> . IDENTIFIER
    (168) indexed_comp -> . name LPAREN value_s RPAREN
    (175) selected_comp -> . name DOT simple_name
    (176) selected_comp -> . name DOT used_char
    (177) selected_comp -> . name DOT operator_symbol
    (178) selected_comp -> . name DOT ALL
    (179) attribute -> . name TICK attribute_id
    (167) operator_symbol -> . STRING

    PLUS            shift and go to state 134
    MINUS           shift and go to state 131
    NOT             shift and go to state 148
    ABS             shift and go to state 140
    NUMBER          shift and go to state 138
    NULL            shift and go to state 130
    NEW             shift and go to state 128
    LPAREN          shift and go to state 142
    CHARACTER       shift and go to state 122
    IDENTIFIER      shift and go to state 40
    STRING          shift and go to state 137

    selected_comp                  shift and go to state 120
    attribute                      shift and go to state 121
    primary                        shift and go to state 123
    used_char                      shift and go to state 143
    unary                          shift and go to state 125
    relation                       shift and go to state 127
    simple_expression              shift and go to state 129
    indexed_comp                   shift and go to state 119
    simple_name                    shift and go to state 153
    literal                        shift and go to state 135
    allocator                      shift and go to state 132
    factor                         shift and go to state 136
    parenthesized_primary          shift and go to state 141
    aggregate                      shift and go to state 126
    condition                      shift and go to state 954
    term                           shift and go to state 144
    name                           shift and go to state 145
    operator_symbol                shift and go to state 146
    qualified                      shift and go to state 147
    expression                     shift and go to state 470

state 951

    (117) variant_part -> CASE simple_name IS variant_s END CASE . SEMICOLON

    SEMICOLON       shift and go to state 955


state 952

    (120) variant -> WHEN choice_s ARROW . comp_list
    (101) comp_list -> . comp_decl_s variant_part_opt
    (102) comp_list -> . variant_part
    (103) comp_list -> . NULL SEMICOLON
    (104) comp_decl_s -> . comp_decl
    (105) comp_decl_s -> . comp_decl_s comp_decl
    (117) variant_part -> . CASE simple_name IS variant_s END CASE SEMICOLON
    (108) comp_decl -> . def_id_s COLON component_subtype_def init_opt SEMICOLON
    (109) comp_decl -> . error SEMICOLON
    (24) def_id_s -> . def_id
    (25) def_id_s -> . def_id_s COMMA def_id
    (26) def_id -> . IDENTIFIER

    NULL            shift and go to state 877
    CASE            shift and go to state 872
    error           shift and go to state 779
    IDENTIFIER      shift and go to state 79

    comp_decl                      shift and go to state 873
    def_id_s                       shift and go to state 775
    comp_list                      shift and go to state 956
    def_id                         shift and go to state 96
    variant_part                   shift and go to state 875
    comp_decl_s                    shift and go to state 874

state 953

    (395) entry_body_part -> IS decl_part block_body END . id_opt SEMICOLON
    (293) id_opt -> .
    (294) id_opt -> . designator
    (316) designator -> . compound_name
    (317) designator -> . STRING
    (162) compound_name -> . simple_name
    (163) compound_name -> . compound_name DOT simple_name
    (161) simple_name -> . IDENTIFIER

    SEMICOLON       reduce using rule 293 (id_opt -> .)
    STRING          shift and go to state 114
    IDENTIFIER      shift and go to state 40

    designator                     shift and go to state 471
    id_opt                         shift and go to state 957
    compound_name                  shift and go to state 113
    simple_name                    shift and go to state 41

state 954

    (393) entry_body -> ENTRY IDENTIFIER LPAREN iter_part discrete_range RPAREN formal_part_opt WHEN condition . entry_body_part
    (394) entry_body_part -> . SEMICOLON
    (395) entry_body_part -> . IS decl_part block_body END id_opt SEMICOLON

    SEMICOLON       shift and go to state 932
    IS              shift and go to state 934

    entry_body_part                shift and go to state 958

state 955

    (117) variant_part -> CASE simple_name IS variant_s END CASE SEMICOLON .

    END             reduce using rule 117 (variant_part -> CASE simple_name IS variant_s END CASE SEMICOLON .)
    WHEN            reduce using rule 117 (variant_part -> CASE simple_name IS variant_s END CASE SEMICOLON .)


state 956

    (120) variant -> WHEN choice_s ARROW comp_list .

    END             reduce using rule 120 (variant -> WHEN choice_s ARROW comp_list .)
    WHEN            reduce using rule 120 (variant -> WHEN choice_s ARROW comp_list .)


state 957

    (395) entry_body_part -> IS decl_part block_body END id_opt . SEMICOLON

    SEMICOLON       shift and go to state 959


state 958

    (393) entry_body -> ENTRY IDENTIFIER LPAREN iter_part discrete_range RPAREN formal_part_opt WHEN condition entry_body_part .

    PRAGMA          reduce using rule 393 (entry_body -> ENTRY IDENTIFIER LPAREN iter_part discrete_range RPAREN formal_part_opt WHEN condition entry_body_part .)
    END             reduce using rule 393 (entry_body -> ENTRY IDENTIFIER LPAREN iter_part discrete_range RPAREN formal_part_opt WHEN condition entry_body_part .)
    ENTRY           reduce using rule 393 (entry_body -> ENTRY IDENTIFIER LPAREN iter_part discrete_range RPAREN formal_part_opt WHEN condition entry_body_part .)
    PROCEDURE       reduce using rule 393 (entry_body -> ENTRY IDENTIFIER LPAREN iter_part discrete_range RPAREN formal_part_opt WHEN condition entry_body_part .)
    FUNCTION        reduce using rule 393 (entry_body -> ENTRY IDENTIFIER LPAREN iter_part discrete_range RPAREN formal_part_opt WHEN condition entry_body_part .)


state 959

    (395) entry_body_part -> IS decl_part block_body END id_opt SEMICOLON .

    PRAGMA          reduce using rule 395 (entry_body_part -> IS decl_part block_body END id_opt SEMICOLON .)
    END             reduce using rule 395 (entry_body_part -> IS decl_part block_body END id_opt SEMICOLON .)
    ENTRY           reduce using rule 395 (entry_body_part -> IS decl_part block_body END id_opt SEMICOLON .)
    PROCEDURE       reduce using rule 395 (entry_body_part -> IS decl_part block_body END id_opt SEMICOLON .)
    FUNCTION        reduce using rule 395 (entry_body_part -> IS decl_part block_body END id_opt SEMICOLON .)

